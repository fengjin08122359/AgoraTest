(function()
{
    var __root = typeof(window) !== "undefined" ? window : self;
    __root.Ice = __root.Ice || {};
    Ice.Slice = Ice.Slice || {};
    __root.IceMX = __root.IceMX || {};
    __root.IceSSL = __root.IceSSL || {};
    var Slice = Ice.Slice;

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        /* globals self */
        var __root = typeof(window) !== "undefined" ? window : self;
        /* globals -self */
        
        var __M =
        {
            module: function(name)
            {
                var m =  __root[name];
                if(m === undefined)
                {
                    m = {};
                    __root[name] =  m;
                }
                return m;
            },
            require: function(name)
            {
                return __root;
            },
            type: function(scoped)
            {
                if(scoped === undefined)
                {
                    return undefined;
                }
                var components = scoped.split(".");
                var T = __root;
        
                for(var i = 0, length = components.length; i < length; ++i)
                {
                    T = T[components[i]];
                    if(T === undefined)
                    {
                        return undefined;
                    }
                }
                return T;
            }
        };
        
        
        Ice.__require = function()
        {
            return __root;
        };
        
        Ice.Slice = Ice.Slice || {};
        Ice.__M = __M;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
            
        var __M = Ice.__M;
        var Slice = Ice.Slice;
        
        var eq = function(e1, e2)
        {
            if(e1 === e2)
            {
                return true; // If identity compare equals members are equal.
            }
            else if(e1 === null || e1 === undefined || e2 === null || e2 === undefined)
            {
                return false;
            }
            else if(e1.prototype !== e2.prototype)
            {
                return false;
            }
            else if(typeof e1.equals == "function")
            {
                return e1.equals(e2);
            }
            else if(e1 instanceof Array)
            {
                return ArrayUtil.equals(e1, e2, eq);
            }
            return false;
        };
        
        var ArrayUtil =
        {
            clone: function(arr)
            {
                if(arr === undefined)
                {
                    return arr;
                }
                else if(arr === null)
                {
                    return [];
                }
                else
                {
                    return arr.slice();
                }
            },
            equals: function(v1, v2, valuesEqual)
            {        
                if(v1.length != v2.length)
                {
                    return false;
                }
        
                var i, length, equalFn = valuesEqual || eq;
                for(i = 0, length = v1.length; i < length; ++i)
                {
                    if(!equalFn.call(equalFn, v1[i], v2[i]))
                    {
                        return false;
                    }
                }
        
                return true;
            },
            shuffle: function(arr)
            {
                for(var i = arr.length; i > 1; --i)
                {
                    var e = arr[i - 1];
                    var rand = Math.floor(Math.random() * i);
                    arr[i - 1] = arr[rand];
                    arr[rand] = e;
                }
            },
            indexOf: function(arr, elem, equalFn)
            {
                if(equalFn !== undefined && equalFn !== null)
                {
                    for(var i = 0; i < arr.length; ++i)
                    {
                        if(equalFn.call(equalFn, arr[i], elem))
                        {
                            return i;
                        }
                    }
                }
                else
                {
                    return arr.indexOf(elem);
                }
        
                return -1;
            },
            filter: function(arr, includeFn, obj)
            {
                obj = obj === undefined ? includeFn : obj;
                var result = [];
                for(var i = 0; i < arr.length; ++i)
                {
                    if(includeFn.call(obj, arr[i], i, arr))
                    {
                        result.push(arr[i]);
                    }
                }
                return result;
            }
        };
        
        ArrayUtil.eq = eq;
        
        Slice.defineSequence = function(module, name, valueHelper, fixed, elementType)
        {
            var helper = null;
            Object.defineProperty(module, name, 
            {
                get: function()
                    {
                        if(helper === null)
                        {
                            /*jshint -W061 */
                            helper = Ice.StreamHelpers.generateSeqHelper(__M.type(valueHelper), fixed, __M.type(elementType));
                            /*jshint +W061 */
                        }
                        return helper;
                    }
            });
        };
        
        Ice.ArrayUtil = ArrayUtil;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        Ice.Class = function()
        {
            var base;
            var desc;
            var constructor;
            
            if(arguments.length == 1)
            {
                desc = arguments[0];
            }
            else if(arguments.length == 2)
            {
                base = arguments[0];
                desc = arguments[1];
            }
        
            if(desc !== undefined)
            {
                constructor = desc.__init__;
                if(constructor)
                {
                    delete desc.__init__;
                }
            }
            
            var o = constructor || function(){};
        
            if(base !== undefined)
            {
                o.prototype = new base();
                o.prototype.constructor = o;
            }
        
            if(desc !== undefined)
            {
                for(var key in desc)
                {
                    o.prototype[key] = desc[key];
                }
            }
            return o;
        };
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        var Class = Ice.Class;
        
        var toString = function(key, object, objectTable, ident)
        {
            ident += "  ";
            if(object === null)
            {
                return "\n" + ident + key + ": (null)";
            }
            if(object === undefined)
            {
                return "\n" + ident + key + ": (undefined)";
            }
            if(key == "stack" || typeof object == "function")
            {
                return "";
            }
            if(typeof object != "object")
            {
                return "\n" + ident + key + ": \"" + object + "\"";
            }
            if(objectTable.indexOf(object) != -1)
            {
                return "\n" + ident + key + ": (recursive)";
            }
        
            objectTable.push(object);
            var s = "\n" + ident + key + ":";
            for(var k in object)
            {
                if(key.indexOf("_") === 0)
                {
                    continue;
                }
        
                if(typeof object[k] == "function")
                {
                    continue;
                }
                s += ident + toString(k, object[k], objectTable, ident);
            }
            return s;
        };
        
        //
        // Ice.Exception
        //
        var Exception = Class(Error, {
            __init__: function(cause)
            {
                if(cause)
                {
                    this.ice_cause = cause;
                }
            },
            ice_name: function()
            {
                return "Ice::Exception";
            },
            toString: function()
            {
                //
                // We have a guard here to prevent being re-entered. With some browsers (IE), accessing
                // the stack property ends up calling toString on the exception to print it out with the
                // stack.
                //
                if(this._inToStringAlready)
                {
                    return "";
                }
        
                this._inToStringAlready = true;
                var s = this.ice_name();
                for(var key in this)
                {
                    if(key != "_inToStringAlready")
                    {
                        s += toString(key, this[key], [], "");
                    }
                }
        
                if(Ice.__printStackTraces === true && this.stack)
                {
                    s += "\n" + this.stack;
                }
                this._inToStringAlready = false;
                return s;
            }
        });
        
        Exception.captureStackTrace = function(object)
        {
            var stack = new Error().stack;
            //
            // In IE 10 and greater the stack will be filled once the Error is throw
            // we don't need to do anything.
            //
            if(stack !== undefined)
            {
                Object.defineProperty(object, "stack", {
                    get: function(){
                        return stack;
                    }
                });
            }
        };
        
        Ice.Exception = Exception;
        
        //
        // Ice.LocalException
        //
        var LocalException = Class(Exception, {
            __init__: function(cause)
            {
                Exception.call(this, cause);
                Exception.captureStackTrace(this);
            },
            ice_name: function()
            {
                return "Ice::LocalException";
            }
        });
        
        Ice.LocalException = LocalException;
        
        var Slice = Ice.Slice;
        Slice.defineLocalException = function(constructor, base, name)
        {
            var ex = constructor;
            ex.prototype = new base();
            ex.prototype.constructor = ex;
            ex.prototype.ice_name = function()
            {
                return name;
            };
            return ex;
        };
        
        //
        // Ice.UserException
        //
        var UserException = Class(Exception, {
            __init__: function(cause)
            {
                Exception.call(this, cause);
                Exception.captureStackTrace(this);
            },
            ice_name: function()
            {
                return "Ice::UserException";
            },
            __write: function(os)
            {
                os.startWriteException(null);
                __writeImpl(this, os, this.__mostDerivedType());
                os.endWriteException();
            },
            __read: function(is)
            {
                is.startReadException();
                __readImpl(this, is, this.__mostDerivedType());
                is.endReadException(false);
            },
            __usesClasses: function()
            {
                return false;
            }
        });
        Ice.UserException = UserException;
        
        //
        // Private methods
        //
        
        var __writeImpl = function(obj, os, type)
        {
            //
            // The __writeImpl method is a recursive method that goes down the
            // class hierarchy to marshal each slice of the class using the
            // generated __writeMemberImpl method.
            //
        
            if(type === undefined || type === UserException)
            {
                return; // Don't marshal anything for Ice.UserException
            }
        
            os.startWriteSlice(type.__id, -1, type.__parent === UserException);
            if(type.prototype.__writeMemberImpl)
            {
                type.prototype.__writeMemberImpl.call(obj, os);
            }
            os.endWriteSlice();
            __writeImpl(obj, os, type.__parent);
        };
        
        var __readImpl = function(obj, is, type)
        {
            //
            // The __readImpl method is a recursive method that goes down the
            // class hierarchy to marshal each slice of the class using the
            // generated __readMemberImpl method.
            //
        
            if(type === undefined || type === UserException)
            {
                return; // Don't marshal anything for UserException
            }
        
            is.startReadSlice();
            if(type.prototype.__readMemberImpl)
            {
                type.prototype.__readMemberImpl.call(obj, is);
            }
            is.endReadSlice();
            __readImpl(obj, is, type.__parent);
        };
        
        var __writePreserved = function(os)
        {
            //
            // For Slice exceptions which are marked "preserved", the implementation of this method
            // replaces the Ice.Object.prototype.__write method.
            //
            os.startWriteException(this.__slicedData);
            __writeImpl(this, os, this.__mostDerivedType());
            os.endWriteException();
        };
        
        var __readPreserved = function(is)
        {
            //
            // For Slice exceptions which are marked "preserved", the implementation of this method
            // replaces the Ice.Object.prototype.__read method.
            //
            is.startReadException();
            __readImpl(this, is, this.__mostDerivedType());
            this.__slicedData = is.endReadException(true);
        };
        
        Slice.defineUserException = function(constructor, base, name, writeImpl, readImpl, preserved, usesClasses)
        {
            var ex = constructor;
            ex.__parent = base;
            ex.prototype = new base();
            ex.__id = "::" + name;
            ex.prototype.ice_name = function()
            {
                return name;
            };
        
            ex.prototype.constructor = ex;
            ex.prototype.__mostDerivedType = function() { return ex; };
            if(preserved)
            {
                ex.prototype.__write = __writePreserved;
                ex.prototype.__read = __readPreserved;
            }
            ex.prototype.__writeMemberImpl = writeImpl;
            ex.prototype.__readMemberImpl = readImpl;
        
            if(usesClasses)
            {
                ex.prototype.__usesClasses = function()
                {
                    return true;
                };
            }
        
            return ex;
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        Ice.AsyncStatus = {Queued: 0, Sent: 1};
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        //
        // The Long type represents a signed 64-bit integer as two 32-bit values
        // corresponding to the high and low words.
        //
        
        var Long = Ice.Class({
            __init__: function(high, low)
            {
                if(low < 0 || low > Long.MAX_UINT32)
                {
                    throw new RangeError("Low word must be between 0 and 0xFFFFFFFF");
                }
                if(high < 0 || high > Long.MAX_UINT32)
                {
                    throw new RangeError("High word must be between 0 and 0xFFFFFFFF");
                }
                
                this.high = high;
                this.low = low;
            },
            hashCode: function()
            {
                return this.low;
            },
            equals: function(rhs)
            {
                if(this === rhs)
                {
                    return true;
                }
                if(!(rhs instanceof Long))
                {
                    return false;
                }
                return this.high === rhs.high && this.low === rhs.low;
            },
            toString: function()
            {
                return this.high + ":" + this.low;
            },
            toNumber: function()
            {
        
                if((this.high & Long.SIGN_MASK) !== 0)
                {
                    if(this.high === Long.MAX_UINT32 && this.low !== 0)
                    {
                        return -(~this.low + 1);
                    }
         
                    var high = ~this.high + 1;
        
                    if(high > Long.HIGH_MAX)
                    {
                        return Number.NEGATIVE_INFINITY;
                    }
        
                    return -1 * (high * Long.HIGH_MASK) + this.low;
                }
                else
                {
                    if(this.high > Long.HIGH_MAX)
                    {
                        return Number.POSITIVE_INFINITY;
                    }
                    return (this.high * Long.HIGH_MASK) + this.low;
                }
            }
        });
        
        //
        // 2^32
        // 
        Long.MAX_UINT32 = 0xFFFFFFFF;
        
        //
        // (high & SIGN_MASK) != 0 denotes a negative number;
        // that is, the most significant bit is set.
        //
        Long.SIGN_MASK = 0x80000000;
        
        //
        // When converting to a JavaScript Number we left shift the
        // high word by 32 bits. As that isn't possible using JavaScript's
        // left shift operator, we multiply the value by 2^32 which will
        // produce the same result.
        //
        Long.HIGH_MASK = 0x100000000;
        
        //
        // The maximum value for the high word when coverting to
        // a JavaScript Number is 2^21 - 1, in which case all
        // 53 bits are used.
        //
        Long.HIGH_MAX = 0x1FFFFF;
        
        Ice.Long = Long;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        Ice.AssertionFailedException = Ice.Class(Error, 
            {
                __init__: function(message)
                {
                    Error.call(this);
                    Ice.Exception.captureStackTrace(this);
                    this.message = message;
                }
            });
        
        Ice.Debug =
        {
            assert: function(b, msg)
            {
                if(!b)
                {
                    Cr.Utils.log(msg === undefined ? "assertion failed" : msg);
                    Cr.Utils.log(Error().stack);
                    throw new Ice.AssertionFailedException(msg === undefined ? "assertion failed" : msg);
                }
            }
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        Ice.DispatchStatus = {DispatchOK: 0, DispatchUserException: 1, DispatchAsync: 2};
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        //
        // Ice.EnumBase
        //
        var EnumBase = Ice.Class({
            __init__: function(name, value)
            {
                this._name = name;
                this._value = value;
            },
            equals: function(rhs)
            {
                if(this === rhs)
                {
                    return true;
                }
        
                var proto = Object.getPrototypeOf(this);
                if(!(rhs instanceof proto.constructor))
                {
                    return false;
                }
        
                return this._value == rhs._value;
            },
            hashCode: function()
            {
                return this._value;
            },
            toString: function()
            {
                return this._name;
            }
        });
        Ice.EnumBase = EnumBase;
        
        var prototype2 = EnumBase.prototype;
        try
		{
			 Object.defineProperty(prototype2, 'name', {
				enumerable: true,
				get: function() { return this._name; }
			});
			
			Object.defineProperty(prototype2, 'value', {
				enumerable: true,
				get: function() { return this._value; }
			});
		}catch(err)
		{

		}
       
        
        var EnumHelper = Ice.Class({
            __init__: function(enumType)
            {
                this._enumType = enumType;
            },
            write: function(os, v)
            {
                this._enumType.__write(os, v);
            },
            writeOpt: function(os, tag, v)
            {
                this._enumType.__writeOpt(os, tag, v);
            },
            read: function(is)
            {
                return this._enumType.__read(is);
            },
            readOpt: function(is, tag)
            {
                return this._enumType.__readOpt(is, tag);
            }
        });
        
        Ice.EnumHelper = EnumHelper;
        
        var Slice = Ice.Slice;
        Slice.defineEnum = function(enumerators)
        {
            var type = function(n, v)
            {
                EnumBase.call(this, n, v);
            };
        
            type.prototype = new EnumBase();
            type.prototype.constructor = type;
        
            var enums = [];
            var maxValue = 0;
            var firstEnum = null;
            for(var idx in enumerators)
            {
                var e = enumerators[idx][0], value = enumerators[idx][1];
                var enumerator = new type(e, value);
                enums[value] = enumerator;
                if(!firstEnum)
                {
                    firstEnum = enumerator;
                }
                Object.defineProperty(type, e, {
                    enumerable: true,
                    value: enumerator
                });
                if(value > maxValue)
                {
                    maxValue = value;
                }
            }
        
            Object.defineProperty(type, "minWireSize", {
                get: function(){ return 1; }
            });
        
            type.__write = function(os, v)
            {
                if(v)
                {
                    os.writeEnum(v);
                }
                else
                {
                    os.writeEnum(firstEnum);
                }
            };
            type.__read = function(is)
            {
                return is.readEnum(type);
            };
            type.__writeOpt = function(os, tag, v)
            {
                if(v !== undefined)
                {
                    if(os.writeOpt(tag, Ice.OptionalFormat.Size))
                    {
                        type.__write(os, v);
                    }
                }
            };
            type.__readOpt = function(is, tag)
            {
                return is.readOptEnum(tag, type);
            };
        
            type.__helper = new EnumHelper(type);
        
            Object.defineProperty(type, 'valueOf', {
                value: function(v) {
                    if(v === undefined)
                    {
                        return type;
                    }
                    return enums[v];
                }
            });
        
            Object.defineProperty(type, 'maxValue', {
                value: maxValue
            });
        
            Object.defineProperty(type.prototype, 'maxValue', {
                value: maxValue
            });
        
            return type;
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        function generateUUID()
        {
            var d = new Date().getTime();
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);
            });
            return uuid;
        }
        
        Ice.generateUUID = generateUUID;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        Ice.FormatType  = Ice.Slice.defineEnum([['DefaultFormat', 0], ['CompactFormat',1], ['SlicedFormat',2]]);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        var Debug = Ice.Debug;
        
        Ice.StringUtil =
        {
            //
            // Return the index of the first character in str to
            // appear in match, starting from start. Returns -1 if none is
            // found.
            //
            findFirstOf: function(str, match, start)
            {
                start = start === undefined ? 0 : start;
        
                var len = str.length;
                for(var i = start; i < len; i++)
                {
                    var ch = str.charAt(i);
                    if(match.indexOf(ch) != -1)
                    {
                        return i;
                    }
                }
        
                return -1;
            },
            //
            // Return the index of the first character in str which does
            // not appear in match, starting from start. Returns -1 if none is
            // found.
            //
            findFirstNotOf: function(str, match, start)
            {
                start = start === undefined ? 0 : start;
        
                var len = str.length;
                for(var i = start; i < len; i++)
                {
                    var ch = str.charAt(i);
                    if(match.indexOf(ch) == -1)
                    {
                        return i;
                    }
                }
        
                return -1;
            },
            //
            // Add escape sequences (such as "\n", or "\007") to make a string
            // readable in ASCII. Any characters that appear in special are
            // prefixed with a backlash in the returned string.
            //
            escapeString: function(s, special)
            {
                special = special === undefined ? null : special;
        
                var i, length;
                if(special !== null)
                {
                    for(i = 0, length = special.length; i < length; ++i)
                    {
                        if(special.charCodeAt(i) < 32 || special.charCodeAt(i) > 126)
                        {
                            throw new Error("special characters must be in ASCII range 32-126");
                        }
                    }
                }
        
                var result = [], c;
                for(i = 0, length = s.length; i < length; ++i)
                {
                    c = s.charCodeAt(i);
                    if(c < 128)
                    {
                        encodeChar(c, result, special);
                    }
                    else if(c > 127 && c < 2048)
                    {
                        encodeChar((c >> 6) | 192, result, special);
                        encodeChar((c & 63) | 128, result, special);
                    }
                    else
                    {
                        encodeChar((c >> 12) | 224, result, special);
                        encodeChar(((c >> 6) & 63) | 128, result, special);
                        encodeChar((c & 63) | 128, result, special);
                    }
                }
        
                return result.join("");
            },
            //
            // Remove escape sequences added by escapeString. Throws Error
            // for an invalid input string.
            //
            unescapeString: function(s, start, end)
            {
                start = start === undefined ? 0 : start;
                end = end === undefined ? s.length : end;
        
                Debug.assert(start >= 0 && start <= end && end <= s.length);
        
                var arr = [];
                decodeString(s, start, end, arr);
        
                return arr.join("");
            },
            //
            // Split string helper; returns null for unmatched quotes
            //
            splitString: function(str, delim)
            {
                var v = [];
                var s = "";
                var pos = 0;
        
                var quoteChar = null;
                while(pos < str.length)
                {
                    if(quoteChar === null && (str.charAt(pos) === '"' || str.charAt(pos) === '\''))
                    {
                        quoteChar = str.charAt(pos++);
                        continue; // Skip the quote.
                    }
                    else if(quoteChar === null && str.charAt(pos) === '\\' && pos + 1 < str.length &&
                            (str.charAt(pos + 1) === '"' || str.charAt(pos + 1) === '\''))
                    {
                        ++pos; // Skip the backslash
                    }
                    else if(quoteChar !== null && str.charAt(pos) === '\\' && pos + 1 < str.length &&
                            str.charAt(pos + 1) === quoteChar)
                    {
                        ++pos; // Skip the backslash
                    }
                    else if(quoteChar !== null && str.charAt(pos) === quoteChar)
                    {
                        ++pos;
                        quoteChar = null;
                        continue; // Skip the quote.
                    }
                    else if(delim.indexOf(str.charAt(pos)) !== -1)
                    {
                        if(quoteChar === null)
                        {
                            ++pos;
                            if(s.length > 0)
                            {
                                v.push(s);
                                s = "";
                            }
                            continue;
                        }
                    }
        
                    if(pos < str.length)
                    {
                        s += str.charAt(pos++);
                    }
                }
        
                if(s.length > 0)
                {
                    v.push(s);
                }
                if(quoteChar !== null)
                {
                    return null; // Unmatched quote.
                }
        
                return v;
            },
            //
            // If a single or double quotation mark is found at the start position,
            // then the position of the matching closing quote is returned. If no
            // quotation mark is found at the start position, then 0 is returned.
            // If no matching closing quote is found, then -1 is returned.
            //
            checkQuote: function(s, start)
            {
                start = start === undefined ? 0 : start;
        
                var quoteChar = s.charAt(start);
                if(quoteChar == '"' || quoteChar == '\'')
                {
                    start++;
                    var len = s.length;
                    var pos;
                    while(start < len && (pos = s.indexOf(quoteChar, start)) != -1)
                    {
                        if(s.charAt(pos - 1) != '\\')
                        {
                            return pos;
                        }
                        start = pos + 1;
                    }
                    return -1; // Unmatched quote
                }
                return 0; // Not quoted
            },
            hashCode: function(s)
            {
                var hash = 0;
                var n = s.length;
        
                for(var i = 0; i < n; i++)
                {
                    hash = 31 * hash + s.charCodeAt(i);
                }
        
                return hash;
            },
            toInt: function(s)
            {
                var n = parseInt(s, 10);
                if(isNaN(n))
                {
                    throw new Error("conversion of `" + s + "' to int failed");
                }
                return n;
            }
        };
        
        //
        // Write the byte b as an escape sequence if it isn't a printable ASCII
        // character and append the escape sequence to sb. Additional characters
        // that should be escaped can be passed in special. If b is any of these
        // characters, b is preceded by a backslash in sb.
        //
        function encodeChar(b, sb, special)
        {
            switch(b)
            {
                case 92: // '\\'
                {
                    sb.push("\\\\");
                    break;
                }
                case 39: // '\''
                {
                    sb.push("\\'");
                    break;
                }
                case 34: // '"'
                {
                    sb.push("\\\"");
                    break;
                }
                case 8: // '\b'
                {
                    sb.push("\\b");
                    break;
                }
                case 12: // '\f'
                {
                    sb.push("\\f");
                    break;
                }
                case 10: // '\n'
                {
                    sb.push("\\n");
                    break;
                }
                case 13: // '\r'
                {
                    sb.push("\\r");
                    break;
                }
                case 9: // '\t'
                {
                    sb.push("\\t");
                    break;
                }
                default:
                {
                    if(!(b >= 32 && b <= 126))
                    {
                        sb.push('\\');
                        var octal = b.toString(8);
                        //
                        // Add leading zeroes so that we avoid problems during
                        // decoding. For example, consider the encoded string
                        // \0013 (i.e., a character with value 1 followed by
                        // the character '3'). If the leading zeroes were omitted,
                        // the result would be incorrectly interpreted by the
                        // decoder as a single character with value 11.
                        //
                        for(var j = octal.length; j < 3; j++)
                        {
                            sb.push('0');
                        }
                        sb.push(octal);
                    }
                    else
                    {
                        var c = String.fromCharCode(b);
                        if(special !== null && special.indexOf(c) !== -1)
                        {
                            sb.push('\\');
                            sb.push(c);
                        }
                        else
                        {
                            sb.push(c);
                        }
                    }
                }
            }
        }
        function checkChar(s, pos)
        {
            var n = s.charCodeAt(pos);
            if(!(n >= 32 && n <= 126))
            {
                var msg;
                if(pos > 0)
                {
                    msg = "character after `" + s.substring(0, pos) + "'";
                }
                else
                {
                    msg = "first character";
                }
                msg += " is not a printable ASCII character (ordinal " + n + ")";
                throw new Error(msg);
            }
            return n;
        }
        
        //
        // Decode the character or escape sequence starting at start and return it.
        // nextStart is set to the index of the first character following the decoded
        // character or escape sequence.
        //
        function decodeChar(s, start, end, nextStart)
        {
            Debug.assert(start >= 0);
            Debug.assert(end <= s.length);
        
            if(start >= end)
            {
                throw new Error("EOF while decoding string");
            }
        
            var c;
        
            if(s.charAt(start) != '\\')
            {
                c = checkChar(s, start++);
            }
            else
            {
                if(start + 1 == end)
                {
                    throw new Error("trailing backslash");
                }
                switch(s.charAt(++start))
                {
                    case '\\':
                    case '\'':
                    case '"':
                    {
                        c = s.charCodeAt(start++);
                        break;
                    }
                    case 'b':
                    {
                        ++start;
                        c = "\b".charCodeAt(0);
                        break;
                    }
                    case 'f':
                    {
                        ++start;
                        c = "\f".charCodeAt(0);
                        break;
                    }
                    case 'n':
                    {
                        ++start;
                        c = "\n".charCodeAt(0);
                        break;
                    }
                    case 'r':
                    {
                        ++start;
                        c = "\r".charCodeAt(0);
                        break;
                    }
                    case 't':
                    {
                        ++start;
                        c = "\t".charCodeAt(0);
                        break;
                    }
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    {
                        var octalChars = "01234567";
                        var val = 0;
                        for(var j = 0; j < 3 && start < end; ++j)
                        {
                            var ch = s.charAt(start++);
                            if(octalChars.indexOf(ch) == -1)
                            {
                                --start;
                                break;
                            }
                            val = val * 8 + parseInt(ch);
                        }
                        if(val > 255)
                        {
                            var msg = "octal value \\" + val.toString(8) + " (" + val + ") is out of range";
                            throw new Error(msg);
                        }
                        c = val;
                        break;
                    }
                    default:
                    {
                        c = checkChar(s, start++);
                        break;
                    }
                }
            }
            nextStart.value = start;
            return c;
        }
        
        //
        // Remove escape sequences from s and append the result to sb.
        // Return true if successful, false otherwise.
        //
        function decodeString(s, start, end, arr)
        {
            var nextStart = { 'value': 0 }, c, c2, c3;
            while(start < end)
            {
                c = decodeChar(s, start, end, nextStart);
                start = nextStart.value;
        
                if(c < 128)
                {
                    arr.push(String.fromCharCode(c));
                }
                else if(c > 191 && c < 224)
                {
                    c2 = decodeChar(s, start, end, nextStart);
                    start = nextStart.value;
                    arr.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
                }
                else
                {
                    c2 = decodeChar(s, start, end, nextStart);
                    start = nextStart.value;
                    c3 = decodeChar(s, start, end, nextStart);
                    start = nextStart.value;
                    arr.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                }
            }
        }
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        var __M = Ice.__M;
        var StringUtil = Ice.StringUtil;
        
        function setInternal(map, key, value, hash, index)
        {
            //
            // Search for an entry with the same key.
            //
            for(var e = map._table[index]; e !== null; e = e._nextInBucket)
            {
                if(e._hash === hash && map.keysEqual(key, e._key))
                {
                    //
                    // Found a match, update the value.
                    //
                    e._value = value;
                    return undefined;
                }
            }
        
            //
            // No match found, add a new entry.
            //
            map.add(key, value, hash, index);
            return undefined;
        }
        
        function compareEquals(v1, v2)
        {
            if(v1 === v2)
            {
                return true;
            }
            if(v1 === undefined || v1 === null || v2 === undefined || v2 === null)
            {
                return false;
            }
            return v1.equals(v2);
        }
        
        function compareIdentity(v1, v2)
        {
            return v1 === v2;
        }
        
        var HashMap = Ice.Class({
            __init__: function(arg1, arg2)
            {
                //
                // The first argument can be a HashMap or the keyComparator, the second
                // argument if present is always the value comparator.
                // 
                var args = arguments;
        
                var h, keyComparator, valueComparator;
        
                if(typeof arg1 == "function")
                {
                    keyComparator = arg1;
                    valueComparator = arg2;
                }
                else if(arg1 instanceof HashMap)
                {
                    h = arg1;
                    keyComparator = h.keyComparator;
                    valueComparator = h.valueComparator;
                }
        
                this._size = 0;
                this._head = null;
                this._initialCapacity = 32;
                this._loadFactor = 0.75;
                this._table = [];
        
                this._keyComparator = (typeof keyComparator == "function") ? keyComparator : compareIdentity;
                this._valueComparator = (typeof valueComparator == "function") ? valueComparator : compareIdentity;
        
                var i, length;
                if(h instanceof HashMap && h._size > 0)
                {
                    this._threshold = h._threshold;
                    length = h._table.length;
                    this._table.length = length;
                    for(i = 0; i < length; i++)
                    {
                        this._table[i] = null;
                    }
                    this.merge(h);
                }
                else
                {
                    this._threshold = this._initialCapacity * this._loadFactor;
                    for(i = 0; i < this._initialCapacity; i++)
                    {
                        this._table[i] = null;
                    }
                }
            },
            set: function(key, value)
            {
                var r = this.computeHash(key); // Returns an object with key,hash members.
        
                var index = this.hashIndex(r.hash, this._table.length);
        
                return setInternal(this, r.key, value, r.hash, index);
            },
            get: function(key)
            {
                var r = this.computeHash(key); // Returns an object with key,hash members.
                var e = this.findEntry(r.key, r.hash);
                return e !== undefined ? e._value : undefined;
            },
            has: function(key)
            {
                var r = this.computeHash(key); // Returns an object with key,hash members.
                return this.findEntry(r.key, r.hash) !== undefined;
            },
            del: function(key)
            {
                var r = this.computeHash(key); // Returns an object with key,hash members.
        
                var index = this.hashIndex(r.hash, this._table.length);
        
                //
                // Search for an entry with the same key.
                //
                var prev = null;
                for(var e = this._table[index]; e !== null; e = e._nextInBucket)
                {
                    if(e._hash === r.hash && this.keysEqual(r.key, e._key))
                    {
                        //
                        // Found a match.
                        //
                        this._size--;
        
                        //
                        // Remove from bucket.
                        //
                        if(prev !== null)
                        {
                            prev._nextInBucket = e._nextInBucket;
                        }
                        else
                        {
                            this._table[index] = e._nextInBucket;
                        }
        
                        //
                        // Unlink the entry.
                        //
                        if(e._prev !== null)
                        {
                            e._prev._next = e._next;
                        }
                        if(e._next !== null)
                        {
                            e._next._prev = e._prev;
                        }
        
                        if(this._head === e)
                        {
                            this._head = e._next;
                        }
        
                        return e._value;
                    }
        
                    prev = e;
                }
        
                return undefined;
            },
            clear: function()
            {
                for(var i = 0; i < this._table.length; ++i)
                {
                    this._table[i] = null;
                }
                this._head = null;
                this._size = 0;
            },
            forEach: function(fn, obj)
            {
                obj = obj === undefined ? fn : obj;
                for(var e = this._head; e !== null; e = e._next)
                {
                    fn.call(obj, e._key, e._value);
                }
            },
            keys: function()
            {
                var k = [];
                var i = 0;
                for(var e = this._head; e !== null; e = e._next)
                {
                    k[i++] = e._key;
                }
                return k;
            },
            values: function()
            {
                var v = [];
                var i = 0;
                for(var e = this._head; e !== null; e = e._next)
                {
                    v[i++] = e._value;
                }
                return v;
            },
            equals: function(other, valuesEqual)
            {
                if(other === null || !(other instanceof HashMap) || this._size !== other._size)
                {
                    return false;
                }
        
                var self = this;
                var eq = valuesEqual || function(v1, v2)
                    {
                        return self._valueComparator.call(self._valueComparator, v1, v2);
                    };
                
                for(var e = this._head; e !== null; e = e._next)
                {
                    var oe = other.findEntry(e._key, e._hash);
                    if(oe === undefined || !eq(e._value, oe._value))
                    {
                        return false;
                    }
                }
        
                return true;
            },
            clone: function()
            {
                return new HashMap(this);
            },
            merge: function(from)
            {
                for(var e = from._head; e !== null; e = e._next)
                {
                    setInternal(this, e._key, e._value, e._hash, this.hashIndex(e._hash, this._table.length));
                }
            },
            add: function(key, value, hash, index)
            {
                //
                // Create a new table entry.
                //
                var e = Object.create(null, {
                    "key": {
                        enumerable: true,
                        get: function() { return this._key; }
                    },
                    "value": {
                        enumerable: true,
                        get: function() { return this._value; }
                    },
                    "next": {
                        enumerable: true,
                        get: function() { return this._next; }
                    },
                    "_key": {
                        enumerable: false,
                        writable: true,
                        value: key
                    },
                    "_value": {
                        enumerable: false,
                        writable: true,
                        value: value
                    },
                    "_prev": {
                        enumerable: false,
                        writable: true,
                        value: null
                    },
                    "_next": {
                        enumerable: false,
                        writable: true,
                        value: null
                    },
                    "_nextInBucket": {
                        enumerable: false,
                        writable: true,
                        value: null
                    },
                    "_hash": {
                        enumerable: false,
                        writable: true,
                        value: hash
                    }
                });
                e._nextInBucket = this._table[index];
                this._table[index] = e;
        
                e._next = this._head;
                if(this._head !== null)
                {
                    this._head._prev = e;
                }
                this._head = e;
        
                this._size++;
                if(this._size >= this._threshold)
                {
                    this.resize(this._table.length * 2);
                }
            },
            resize: function(capacity)
            {
                var oldTable = this._table;
        
                var newTable = [];
                for(var i = 0; i < capacity; i++)
                {
                    newTable[i] = null;
                }
        
                //
                // Re-assign all entries to buckets.
                //
                for(var e = this._head; e !== null; e = e._next)
                {
                    var index = this.hashIndex(e._hash, capacity);
                    e._nextInBucket = newTable[index];
                    newTable[index] = e;
                }
        
                this._table = newTable;
                this._threshold = (capacity * this._loadFactor);
            },
            findEntry: function(key, hash)
            {
                var index = this.hashIndex(hash, this._table.length);
                //
                // Search for an entry with the same key.
                //
                for(var e = this._table[index]; e !== null; e = e._nextInBucket)
                {
                    if(e._hash === hash && this.keysEqual(key, e._key))
                    {
                        return e;
                    }
                }
        
                return undefined;
            },
            hashIndex: function(hash, len)
            {
                return hash & (len - 1);
            },
            computeHash: function(v)
            {
                var uuid;
                if(v === 0 || v === -0)
                {
                    return {key:0, hash:0};
                }
        
                if(v === null)
                {
                    if(HashMap._null === null)
                    {
                        uuid = Ice.generateUUID();
                        HashMap._null = {key:uuid, hash:StringUtil.hashCode(uuid)};
                    }
                    return HashMap._null;
                }
        
                if(v === undefined)
                {
                    throw new Error("cannot compute hash for undefined value");
                }
        
                if(typeof(v.hashCode) === "function")
                {
                    return {key:v, hash:v.hashCode()};
                }
        
                var type = typeof(v);
                if(type === "string" || v instanceof String)
                {
                    return {key:v, hash:StringUtil.hashCode(v)};
                }
                else if(type === "number" || v instanceof Number)
                {
                    if(isNaN(v))
                    {
                        if(HashMap._nan === null)
                        {
                            uuid = Ice.generateUUID();
                            HashMap._nan = {key:uuid, hash:StringUtil.hashCode(uuid)};
                        }
                        return HashMap._nan;
                    }
                    return {key:v, hash:v.toFixed(0)};
                }
                else if(type === "boolean" || v instanceof Boolean)
                {
                    return {key:v, hash:v ? 1 : 0};
                }
        
                throw new Error("cannot compute hash for value of type " + type);
            },
            keysEqual: function(k1, k2)
            {
                return this._keyComparator.call(this._keyComparator, k1, k2);
            }
        });
        Ice.HashMap = HashMap;
        
        HashMap.compareEquals = compareEquals;
        HashMap.compareIdentity = compareIdentity;
        HashMap._null = null;
        HashMap._nan = null;
        
        var prototype = HashMap.prototype;
        
        Object.defineProperty(prototype, "size", {
            get: function() { return this._size; }
        });
        
        Object.defineProperty(prototype, "entries", {
            get: function() { return this._head; }
        });
        
        var Slice = Ice.Slice;
        Slice.defineDictionary = function(module, name, helperName, keyHelper, valueHelper, fixed, keysEqual, valueType, valuesEqual)
        {
            if(keysEqual !== undefined || valuesEqual !== undefined)
            {
                //
                // Define a constructor function for a dictionary whose key type requires
                // comparison using an equals() method instead of the native comparison
                // operators.
                //
                module[name] = function(h)
                {
                    return new HashMap(h || keysEqual, valuesEqual);
                };
            }
            else
            {
                module[name] = HashMap;
            }
        
            var helper = null;
            Object.defineProperty(module, helperName,
            {
                get: function()
                    {
                        if(helper === null)
                        {
                            /*jshint -W061 */
                            helper = Ice.StreamHelpers.generateDictHelper(__M.type(keyHelper), __M.type(valueHelper), fixed, 
                                                                          __M.type(valueType), module[name]);
                            /*jshint +W061 */
                        }
                        return helper;
                    }
            });
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        Ice.OptionalFormat = Ice.Slice.defineEnum([['F1', 0], ['F2', 1], ['F4', 2], ['F8', 3], ['Size', 4], ['VSize', 5], ['FSize', 6], ['Class', 7]]);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Class = Ice.Class;
        var defineProperty = Object.defineProperty;
        var HashMap = Ice.HashMap;
        var OptionalFormat = Ice.OptionalFormat;
        
        var StreamHelpers = {};
        
        StreamHelpers.FSizeOptHelper = function()
        {
            this.writeOpt = function(os, tag, v)
            {
                if(v !== undefined && os.writeOpt(tag, OptionalFormat.FSize))
                {
                    var pos = os.startSize();
                    this.write(os, v);
                    os.endSize(pos);
                }
            };
        
            this.readOpt = function(is, tag)
            {
                var v;
                if(is.readOpt(tag, OptionalFormat.FSize))
                {
                    is.skip(4);
                    v = this.read(is);
                }
                return v;
            };
        };
        
        StreamHelpers.VSizeOptHelper = function()
        {
            this.writeOpt = function(os, tag, v)
            {
                if(v !== undefined && os.writeOpt(tag, OptionalFormat.VSize))
                {
                    os.writeSize(this.minWireSize);
                    this.write(os, v);
                }
            };
        
            this.readOpt = function(is, tag)
            {
                var v;
                if(is.readOpt(tag, OptionalFormat.VSize))
                {
                    is.skipSize();
                    v = this.read(is);
                }
                return v;
            };
        };
        
        StreamHelpers.VSizeContainerOptHelper = function(elementSize)
        {
            this.writeOpt = function(os, tag, v)
            {
                if(v !== undefined && os.writeOpt(tag, OptionalFormat.VSize))
                {
                    var sz = this.size(v);
                    os.writeSize(sz > 254 ? sz * elementSize + 5 : sz * elementSize + 1);
                    this.write(os, v);
                }
            };
        
            this.readOpt = function(is, tag)
            {
                var v;
                if(is.readOpt(tag, OptionalFormat.VSize))
                {
                    is.skipSize();
                    v = this.read(is);
                }
                return v;
            };
        };
        
        StreamHelpers.VSizeContainer1OptHelper = function()
        {
            this.writeOpt = function(os, tag, v)
            {
                if(v !== undefined && os.writeOpt(tag, OptionalFormat.VSize))
                {
                    this.write(os, v);
                }
            };
        
            this.readOpt = function(is, tag)
            {
                var v;
                if(is.readOpt(tag, OptionalFormat.VSize))
                {
                    v = this.read(is);
                }
                return v;
            };
        };
        
        //
        // Sequence helper to write sequences
        //
        var SequenceHelper = Class({
            write: function(os, v)
            {
                if(v === null || v.length === 0)
                {
                    os.writeSize(0);
                }
                else
                {
                    var helper = this.elementHelper;
                    os.writeSize(v.length);
                    for(var i = 0; i < v.length; ++i)
                    {
                        helper.write(os, v[i]);
                    }
                }
            },
            read: function(is)
            {
                var helper = this.elementHelper; // Cache the element helper.
                var sz = is.readAndCheckSeqSize(helper.minWireSize);
                var v = [];
                v.length = sz;
                for(var i = 0; i < sz; ++i)
                {
                    v[i] = helper.read(is);
                }
                return v;
            },
            size: function(v)
            {
                return (v === null || v === undefined) ? 0 : v.length;
            }
        });
        
        defineProperty(SequenceHelper.prototype, "minWireSize", {
            get: function(){ return 1; }
        });
        
        // Speacialization optimized for ByteSeq
        var byteSeqHelper = new SequenceHelper();
        byteSeqHelper.write = function(os, v) { return os.writeByteSeq(v); };
        byteSeqHelper.read = function(is) { return is.readByteSeq(); };
        defineProperty(byteSeqHelper, "elementHelper", {
            get: function(){ return Ice.ByteHelper; }
        });
        StreamHelpers.VSizeContainer1OptHelper.call(byteSeqHelper);
        
        // Read method for object sequences
        var objectSequenceHelperRead = function(is)
        {
            var sz = is.readAndCheckSeqSize(1);
            var v = [];
            v.length = sz;
            var elementType = this.elementType;
            var readObjectAtIndex = function(idx)
            {
                is.readObject(function(obj) { v[idx] = obj; }, elementType);
            };
        
            for(var i = 0; i < sz; ++i)
            {
                readObjectAtIndex(i);
            }
            return v;
        };
        
        StreamHelpers.generateSeqHelper = function(elementHelper, fixed, elementType)
        {
            if(elementHelper === Ice.ByteHelper)
            {
                return byteSeqHelper;
            }
        
            var helper = new SequenceHelper();
            if(fixed)
            {
                if(elementHelper.minWireSize === 1)
                {
                    StreamHelpers.VSizeContainer1OptHelper.call(helper);
                }
                else
                {
                    StreamHelpers.VSizeContainerOptHelper.call(helper, elementHelper.minWireSize);
                }
            }
            else
            {
                StreamHelpers.FSizeOptHelper.call(helper);
            }
        
            defineProperty(helper, "elementHelper", {
                get: function(){ return elementHelper; }
            });
        
            if(elementHelper == Ice.ObjectHelper)
            {
                defineProperty(helper, "elementType", {
                    get: function(){ return elementType; }
                });
                helper.read = objectSequenceHelperRead;
            }
        
            return helper;
        };
        
        //
        // Dictionary helper to write dictionaries
        //
        var DictionaryHelper = Class({
            write: function(os, v)
            {
                if(v === null || v === undefined || v.size === 0)
                {
                    os.writeSize(0);
                }
                else
                {
                    var keyHelper = this.keyHelper;
                    var valueHelper = this.valueHelper;
                    os.writeSize(v.size);
                    for(var e = v.entries; e !== null; e = e.next)
                    {
                        keyHelper.write(os, e.key);
                        valueHelper.write(os, e.value);
                    }
                }
            },
            read: function(is)
            {
                var mapType = this.mapType;
                var v = new mapType();
                var sz = is.readSize();
                var keyHelper = this.keyHelper;
                var valueHelper = this.valueHelper;
                for(var i = 0; i < sz; ++i)
                {
                    v.set(keyHelper.read(is), valueHelper.read(is));
                }
                return v;
            },
            size: function(v)
            {
                return (v === null || v === undefined) ? 0 : v.size;
            }
        });
        
        Object.defineProperty(DictionaryHelper.prototype, "minWireSize", {
            get: function(){ return 1; }
        });
        
        // Read method for dictionaries of objects
        var objectDictionaryHelperRead = function(is)
        {
            var sz = is.readSize();
            var mapType = this.mapType;
            var v = new mapType();
            var valueType = this.valueType;
        
            var readObjectForKey = function(key)
            {
                is.readObject(function(obj) { v.set(key, obj); }, valueType);
            };
        
            var keyHelper = this.keyHelper;
            for(var i = 0; i < sz; ++i)
            {
                readObjectForKey(keyHelper.read(is));
            }
            return v;
        };
        
        StreamHelpers.generateDictHelper = function(keyHelper, valueHelper, fixed, valueType, mapType)
        {
            var helper = new DictionaryHelper();
            if(fixed)
            {
                StreamHelpers.VSizeContainerOptHelper.call(helper, keyHelper.minWireSize + valueHelper.minWireSize);
            }
            else
            {
                StreamHelpers.FSizeOptHelper.call(helper);
            }
            defineProperty(helper, "mapType", {
                get: function(){ return mapType; }
            });
            defineProperty(helper, "keyHelper", {
                get: function(){ return keyHelper; }
            });
            defineProperty(helper, "valueHelper", {
                get: function(){ return valueHelper; }
            });
        
            if(valueHelper == Ice.ObjectHelper)
            {
                defineProperty(helper, "valueType", {
                    get: function(){ return valueType; }
                });
                helper.read = objectDictionaryHelperRead;
            }
        
            return helper;
        };
        
        Ice.StreamHelpers = StreamHelpers;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        //
        // jshint browser: true
        //
        
        /* global WorkerGlobalScope */
        
        
        
        //
        // Create a timer object that uses the default browser methods. Note that we also
        // have to use apply with null as the first argument to workaround an issue where
        // IE doesn't like these functions to be called with an unknown object (it reports
        // an "Invalid calling object" error).
        //
        function createTimerObject()
        {
            var Timer = {};
            Timer.setTimeout = function () { setTimeout.apply(null, arguments); };
            Timer.clearTimeout = function () { clearTimeout.apply(null, arguments); };
            Timer.setInterval = function () { setInterval.apply(null, arguments); };
            Timer.clearInterval = function () { clearInterval.apply(null, arguments); };
            Timer.setImmediate = typeof(setImmediate) == "function" ?
                function () { setImmediate.apply(null, arguments); } : 
                function () { setTimeout.apply(null, arguments); };
            return Timer;
        }
        
        
        
        var HashMap = Ice.HashMap;
        
        var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER  || 9007199254740991;
        
        var _timers = new HashMap();
        
        var _SetTimeoutType = 0,
            _SetIntervalType = 1,
            _SetImmediateType = 2,
            _ClearTimeoutType = 3,
            _ClearIntervalType = 4;
        
        var Timer = {};
        var worker;
        
        var _nextId = 0;
        
        var nextId = function()
        {
            if(_nextId == MAX_SAFE_INTEGER)
            {
                _nextId = 0;
            }
            return _nextId++;
        };
        
        Timer.setTimeout = function(cb, ms)
        {
            var id = nextId();
            _timers.set(id, cb);
            worker.postMessage({type: _SetTimeoutType, id: id, ms: ms});
            return id;
        };
        
        Timer.clearTimeout = function(id)
        {
            _timers.del(id);
            worker.postMessage({type: _ClearTimeoutType, id: id});
        };
        
        Timer.setInterval = function(cb, ms)
        {
            var id = nextId();
            _timers.set(id, cb);
            worker.postMessage({type: _SetIntervalType, id: id, ms: ms});
            return id;
        };
        
        Timer.clearInterval = function(id)
        {
            _timers.del(id);
            worker.postMessage({type: _ClearIntervalType, id: id});
        };
        
        Timer.setImmediate = function(cb)
        {
            var id = nextId();
            _timers.set(id, cb);
            worker.postMessage({type: _SetImmediateType, id: id});
            return id;
        };
        
        Timer.onmessage = function(e)
        {
            var cb;
            if(e.data.type === _SetIntervalType)
            {
                cb = _timers.get(e.data.id);
            }
            else
            {
                cb = _timers.del(e.data.id);
            }
        
            if(cb !== undefined)
            {
                cb.call();
            }
        };
        
        var workerCode = function()
        {
            return "(" +
            function()
            {
                //
                // jshint worker: true
                //
                var _wSetTimeoutType = 0,
                    _wSetIntervalType = 1,
                    _wSetImmediateType = 2,
                    _wClearTimeoutType = 3,
                    _wClearIntervalType = 4;
        
                var timers = {};
        
                self.onmessage = function(e)
                {
                    if(e.data.type == _wSetTimeoutType)
                    {
                        timers[e.data.id] = setTimeout(function()
                            {
                                self.postMessage(e.data);
                            },
                            e.data.ms);
                    }
                    else if(e.data.type == _wSetIntervalType)
                    {
                        timers[e.data.id] = setInterval(function()
                            {
                                self.postMessage(e.data);
                            },
                            e.data.ms);
                    }
                    else if(e.data.type == _wSetImmediateType)
                    {
                        self.postMessage(e.data);
                    }
                    else if(e.data.type == _wClearTimeoutType)
                    {
                        clearTimeout(timers[e.data.id]);
                        delete timers[e.data.id];
                    }
                    else if(e.data.type == _wClearIntervalType)
                    {
                        clearInterval(timers[e.data.id]);
                        delete timers[e.data.id];
                    }
                };
        
                //
                // jshint worker: false
                //
            }.toString() + "());";
        };
        
        if(worker === undefined)
        {
            var url;
            try
            {
                url = URL.createObjectURL(new Blob([workerCode()], {type : 'text/javascript'}));
                worker = new Worker(url);
                worker.onmessage = Timer.onmessage;
                Ice.Timer = Timer;
            }
            catch(ex)
            {
                URL.revokeObjectURL(url);
        
                //
                // Fallback on setInterval/setTimeout if the worker creating failed. Some IE10 and IE11 don't
                // support creating workers from blob URLs for instance.
                //
                Ice.Timer = createTimerObject();
            }
        }
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        //
        // Ice.Object
        //
        // Using IceObject in this file to avoid collisions with the native Object.
        //
        
        var Class = Ice.Class;
        
        var nextAddress = 0;
        
        var IceObject = Class({
            __init__: function()
            {
                // Fake Address used as the hashCode for this object instance.
                this.__address = nextAddress++;
            },
            hashCode: function()
            {
                return this.__address;
            },
            ice_isA: function(s, current)
            {
                return this.__mostDerivedType().__ids.indexOf(s) >= 0;
            },
            ice_ping: function(current)
            {
            },
            ice_ids: function(current)
            {
                return this.__mostDerivedType().__ids;
            },
            ice_id: function(current)
            {
                return this.__mostDerivedType().__id;
            },
            toString: function()
            {
                return "[object " + this.ice_id() + "]";
            },
            ice_preMarshal: function()
            {
            },
            ice_postUnmarshal: function()
            {
            },
            __write: function(os)
            {
                os.startWriteObject(null);
                __writeImpl(this, os, this.__mostDerivedType());
                os.endWriteObject();
            },
            __read: function(is)
            {
                is.startReadObject();
                __readImpl(this, is, this.__mostDerivedType());
                is.endReadObject(false);
            },
            ice_instanceof: function(T)
            {
                if(T)
                {
                    if(this instanceof T)
                    {
                        return true;
                    }
                    return this.__mostDerivedType().__instanceof(T);
                }
                return false;
            },
            //
            // __mostDerivedType returns the the most derived Ice generated class. This is
            // necessary because the user might extend Slice generated classes. The user
            // class extensions don't have __id, __ids, __instanceof etc static members so
            // the implementation of ice_id, ice_ids and ice_instanceof would fail trying
            // to access those members of the user defined class. Instead, ice_id, ice_ids
            // and ice_instanceof call __mostDerivedType to get the most derived Ice class.
            //
            // The __mostDerivedType is overriden by each Slice generated class, see the
            // Slice.defineObject method implementation for details.
            //
            __mostDerivedType: function()
            {
                return IceObject;
            },
            //
            // The default implementation of equals compare references.
            // 
            equals: function(other)
            {
                return this === other;
            }
        });
        
        //
        // These methods are used for object parameters.
        //
        IceObject.write = function(os, v)
        {
            os.writeObject(v);
        };
        
        IceObject.writeOpt = function(os, tag, v)
        {
            os.writeOptObject(tag, v);
        };
        
        IceObject.read = function(is)
        {
            var v = { value: null };
            is.readObject(function(o) { v.value = o; }, IceObject);
            return v;
        };
        
        IceObject.readOpt = function(is, tag)
        {
            var v = { value: undefined };
            is.readOptObject(tag, function(o) { v.value = o; }, IceObject);
            return v;
        };
        
        IceObject.ice_staticId = function()
        {
            return IceObject.__id;
        };
        
        IceObject.__instanceof = function(T)
        {
            if(T === this)
            {
                return true;
            }
        
            for(var i in this.__implements)
            {
                if(this.__implements[i].__instanceof(T))
                {
                    return true;
                }
            }
        
            if(this.__parent)
            {
                return this.__parent.__instanceof(T);
            }
            return false;
        };
        
        IceObject.__ids = ["::Ice::Object"];
        IceObject.__id = IceObject.__ids[0];
        IceObject.__compactId = -1;
        IceObject.__preserved = false;
        
        //
        // Private methods
        //
        
        var __writeImpl = function(obj, os, type)
        {
            //
            // The __writeImpl method is a recursive method that goes down the
            // class hierarchy to marshal each slice of the class using the
            // generated __writeMemberImpl method.
            //
        
            if(type === undefined || type === IceObject)
            {
                return; // Don't marshal anything for IceObject
            }
        
            os.startWriteSlice(type.__id, type.__compactId, type.__parent === IceObject);
            if(type.prototype.__writeMemberImpl)
            {
                type.prototype.__writeMemberImpl.call(obj, os);
            }
            os.endWriteSlice();
            __writeImpl(obj, os, type.__parent);
        };
        
        var __readImpl = function(obj, is, type)
        {
            //
            // The __readImpl method is a recursive method that goes down the
            // class hierarchy to marshal each slice of the class using the
            // generated __readMemberImpl method.
            //
        
            if(type === undefined || type === IceObject)
            {
                return; // Don't marshal anything for IceObject
            }
        
            is.startReadSlice();
            if(type.prototype.__readMemberImpl)
            {
                type.prototype.__readMemberImpl.call(obj, is);
            }
            is.endReadSlice();
            __readImpl(obj, is, type.__parent);
        };
        
        var __writePreserved = function(os)
        {
            //
            // For Slice classes which are marked "preserved", the implementation of this method
            // replaces the Ice.Object.prototype.__write method.
            //
            os.startWriteObject(this.__slicedData);
            __writeImpl(this, os, this.__mostDerivedType());
            os.endWriteObject();
        };
        
        var __readPreserved = function(is)
        {
            //
            // For Slice classes which are marked "preserved", the implementation of this method
            // replaces the Ice.Object.prototype.__read method.
            //
            is.startReadObject();
            __readImpl(this, is, this.__mostDerivedType());
            this.__slicedData = is.endReadObject(true);
        };
        
        Ice.Object = IceObject;
        
        var Slice = Ice.Slice;
        Slice.defineLocalObject = function(constructor, base)
        {
            var obj = constructor || function(){};
        
            if(base !== undefined)
            {
                obj.prototype = new base();
                obj.__parent = base;
                obj.prototype.constructor = constructor;
            }
        
            return obj;
        };
        
        Slice.defineObject = function(constructor, base, intfs, scope, ids, compactId, writeImpl, readImpl, preserved)
        {
            var obj = constructor || function(){};
        
            obj.prototype = new base();
            obj.__parent = base;
            obj.__ids = ids;
            obj.__id = ids[scope];
            obj.__compactId = compactId;
            obj.__instanceof = IceObject.__instanceof;
            obj.__implements = intfs;
        
            //
            // These methods are used for object parameters.
            //
            obj.write = function(os, v)
            {
                os.writeObject(v);
            };
            obj.writeOpt = function(os, tag, v)
            {
                os.writeOptObject(tag, v);
            };
            obj.read = function(is)
            {
                var v = { value: null };
                is.readObject(function(o) { v.value = o; }, obj);
                return v;
            };
            obj.readOpt = function(is, tag)
            {
                var v = { value: undefined };
                is.readOptObject(tag, function(o) { v.value = o; }, obj);
                return v;
            };
        
            obj.ice_staticId = function()
            {
                return ids[scope];
            };
        
            obj.prototype.constructor = obj;
            obj.prototype.__mostDerivedType = function() { return obj; };
            if(preserved)
            {
                obj.prototype.__write = __writePreserved;
                obj.prototype.__read = __readPreserved;
            }
            obj.prototype.__writeMemberImpl = writeImpl;
            obj.prototype.__readMemberImpl = readImpl;
        
            return obj;
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        var StringUtil = Ice.StringUtil;
        
        Ice.HashUtil =
        {
            addBoolean: function(h, b)
            {
                return ((h << 5) + h) ^ (b ? 0 : 1);
            },
            addString: function(h, str)
            {
                if(str !== undefined && str !== null)
                {
                    h = ((h << 5) + h) ^ StringUtil.hashCode(str);
                }
                return h;
            },
            addNumber: function(h, num)
            {
                return ((h << 5) + h) ^ num;
            },
            addHashable: function(h, obj)
            {
                if(obj !== undefined && obj !== null)
                {
                    h = ((h << 5) + h) ^ obj.hashCode();
                }
                return h;
            },
            addArray: function(h, arr, hashCode)
            {
                if(arr !== undefined && arr !== null)
                {
                    for(var i = 0; i < arr.length; ++i)
                    {
                        h = hashCode(h, arr[i]);
                    }
                }
                return h;
            }
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var ArrayUtil = Ice.ArrayUtil;
        
        //
        // Use generic equality test from ArrayUtil.
        //
        var eq = ArrayUtil.eq;
        
        var equals = function(other)
        {
            if(this === other)
            {
                return true;
            }
        
            if(other === null || other === undefined)
            {
                return false;
            }
        
            if(this.prototype !== other.prototype)
            {
                return false;
            }
        
            var e1, e2;
            for(var key in this)
            {
                e1 = this[key];
                e2 = other[key];
                if(typeof e1 == "function")
                {
                    continue; // Don't need to compare functions
                }
                else if(!eq(e1, e2))
                {
                    return false;
                }
            }
            return true;
        };
        
        var clone = function()
        {
            var other = new this.constructor();
            var e;
            for(var key in this)
            {
                e = this[key];
                if(e === undefined || e === null)
                {
                    other[key] = e;
                }
                else if(typeof e == "function")
                {
                    continue;
                }
                else if(typeof e.clone == "function")
                {
                    other[key] = e.clone();
                }
                else if(e instanceof Array)
                {
                    other[key] = ArrayUtil.clone(e);
                }
                else
                {
                    other[key] = e;
                }
            }
            return other;
        };
        
        var memberHashCode = function(h, e)
        {
            if(typeof e.hashCode == "function")
            {
                return Ice.HashUtil.addHashable(h, e);
            }
            else if(e instanceof Array)
            {
                return Ice.HashUtil.addArray(h, e, memberHashCode);
            }
            else
            {
                var t = typeof(e);
                if(e instanceof String || t == "string")
                {
                    return Ice.HashUtil.addString(h, e);
                }
                else if(e instanceof Number || t == "number")
                {
                    return Ice.HashUtil.addNumber(h, e);
                }
                else if(e instanceof Boolean || t == "boolean")
                {
                    return Ice.HashUtil.addBoolean(h, e);
                }
            }
        };
        
        var hashCode = function()
        {
            var __h = 5381;
            var e;
            for(var key in this)
            {
                e = this[key];
                if(e === undefined || e === null || typeof e == "function")
                {
                    continue;
                }
                __h = memberHashCode(__h, e);
            }
            return __h;
        };
        
        Ice.Slice.defineStruct = function(constructor, legalKeyType, writeImpl, readImpl, minWireSize, fixed)
        {
            var obj = constructor;
        
            obj.prototype.clone = clone;
        
            obj.prototype.equals = equals;
        
            //
            // Only generate hashCode if this structure type is a legal dictionary key type.
            //
            if(legalKeyType)
            {
                obj.prototype.hashCode = hashCode;
            }
        
            if(readImpl && writeImpl)
            {
                obj.prototype.__write = writeImpl;
                obj.prototype.__read = readImpl;
                obj.write = function(os, v)
                {
                    if(!v)
                    {
                        if(!obj.prototype._nullMarshalValue)
                        {
                            obj.prototype._nullMarshalValue = new this();
                        }
                        v = obj.prototype._nullMarshalValue;
                    }
                    v.__write(os);
                };
                obj.read = function(is, v)
                {
                    if(!v || !(v instanceof this))
                    {
                        v = new this();
                    }
                    v.__read(is);
                    return v;
                };
                Object.defineProperty(obj, "minWireSize", {
                    get: function() { return minWireSize; }
                });
                if(fixed)
                {
                    Ice.StreamHelpers.VSizeOptHelper.call(obj);
                }
                else
                {
                    Ice.StreamHelpers.FSizeOptHelper.call(obj);
                }
            }
            return obj;
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        Ice.CompactIdRegistry = new Ice.HashMap();
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `BuiltinSequences.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
            Slice.defineSequence(Ice, "BoolSeqHelper", "Ice.BoolHelper", true);
            Slice.defineSequence(Ice, "ByteSeqHelper", "Ice.ByteHelper", true);
            Slice.defineSequence(Ice, "ShortSeqHelper", "Ice.ShortHelper", true);
            Slice.defineSequence(Ice, "IntSeqHelper", "Ice.IntHelper", true);
            Slice.defineSequence(Ice, "LongSeqHelper", "Ice.LongHelper", true);
            Slice.defineSequence(Ice, "FloatSeqHelper", "Ice.FloatHelper", true);
            Slice.defineSequence(Ice, "DoubleSeqHelper", "Ice.DoubleHelper", true);
            Slice.defineSequence(Ice, "StringSeqHelper", "Ice.StringHelper", false);
            Slice.defineSequence(Ice, "ObjectSeqHelper", "Ice.ObjectHelper", false, "Ice.Object");
            Slice.defineSequence(Ice, "ObjectProxySeqHelper", "Ice.ObjectPrx", false);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        //
        // Using a separate module for these constants so that ObjectPrx does
        // not need to include Reference.
        //
        Ice.ReferenceMode = 
        {
            ModeTwoway: 0, 
            ModeOneway: 1, 
            ModeBatchOneway: 2, 
            ModeDatagram: 3, 
            ModeBatchDatagram: 4,
            ModeLast: 4
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        
        var Long = Ice.Long;
        
        //
        // IE 10 doesn't implement ArrayBuffer.slice
        //
        
        if(!ArrayBuffer.prototype.slice)
        {
            ArrayBuffer.prototype.slice = function (start, end)
            {
                var b = new Uint8Array(this);
                end = end === undefined ? b.length : end;
                var result = new Uint8Array(new ArrayBuffer(end - start));
                for(var i = 0, length = result.length; i < length; i++)
                {
                    result[i] = b[i + start];
                }
                return result.buffer;
            };
        }
        
        var __BufferOverflowException__ = "BufferOverflowException";
        var __BufferUnderflowException__ = "BufferUnderflowException";
        var __IndexOutOfBoundsException__ = "IndexOutOfBoundsException";
        
        //
        // Buffer implementation to be used by web browsers, it uses ArrayBuffer as
        // the store.
        //
        var Buffer = Ice.Class({
            __init__: function(buffer)
            {
                if(buffer !== undefined)
                {
                    this.b = buffer;
                    this.v = new DataView(this.b);
                }
                else
                {
                    this.b = null; // ArrayBuffer
                    this.v = null; // DataView
                }
                this._position = 0;
                this._limit = 0;
                this._shrinkCounter = 0;
            },
            empty: function()
            {
                return this._limit === 0;
            },
            resize: function(n)
            {
                if(n === 0)
                {
                    this.clear();
                }
                else if(n > this.capacity)
                {
                    this.reserve(n);
                }
                this._limit = n;
            },
            clear: function()
            {
                this.b = null;
                this.v = null;
                this._position = 0;
                this._limit = 0;
            },
            //
            // Call expand(n) to add room for n additional bytes. Note that expand()
            // examines the current position of the buffer first; we don't want to
            // expand the buffer if the caller is writing to a location that is
            // already in the buffer.
            //
            expand: function(n)
            {
                var sz = this.capacity === 0 ? n : this._position + n;
                if(sz > this._limit)
                {
                    this.resize(sz);
                }
            },
            reset: function()
            {
                if(this._limit > 0 && this._limit * 2 < this.capacity)
                {
                    //
                    // If the current buffer size is smaller than the
                    // buffer capacity, we shrink the buffer memory to the
                    // current size. This is to avoid holding on to too much
                    // memory if it's not needed anymore.
                    //
                    if(++this._shrinkCounter > 2)
                    {
                        this.reserve(this._limit);
                        this._shrinkCounter = 0;
                    }
                }
                else
                {
                    this._shrinkCounter = 0;
                }
                this._limit = 0;
                this._position = 0;
            },
            reserve: function(n)
            {
                if(n > this.capacity)
                {
                    var capacity = Math.max(n, 2 * this.capacity);
                    capacity = Math.max(1024, capacity);
                    if(!this.b)
                    {
                        this.b = new ArrayBuffer(capacity);
                    }
                    else
                    {
                        var b = new Uint8Array(capacity);
                        b.set(new Uint8Array(this.b));
                        this.b = b.buffer;
                    }
                    this.v = new DataView(this.b);
                }
                else if(n < this.capacity)
                {
                    this.b = this.b.slice(0, this.capacity);
                    this.v = new DataView(this.b);
                }
                else
                {
                    return;
                }
            },
            put: function(v)
            {
                if(this._position === this._limit)
                {
                    throw new Error(__BufferOverflowException__);
                }
                this.v.setUint8(this._position, v);
                this._position++;
            },
            putAt: function(i, v)
            {
                if(i >= this._limit)
                {
                    throw new Error(__IndexOutOfBoundsException__);
                }
                this.v.setUint8(i, v);
            },
            putArray: function(v)
            {
                //Expects an Uint8Array
                if(!(v instanceof Uint8Array))
                {
                    throw new TypeError('argument is not a Uint8Array');
                }
                if(v.byteLength > 0)
                {
                    if(this._position + v.length > this._limit)
                    {
                        throw new Error(__BufferOverflowException__);
                    }
                    new Uint8Array(this.b, 0, this.b.byteLength).set(v, this._position);
                    this._position += v.byteLength;
                }
            },
            putShort: function(v)
            {
                if(this._position + 2 > this._limit)
                {
                    throw new Error(__BufferOverflowException__);
                }
                this.v.setInt16(this._position, v, true);
                this._position += 2;
            },
            putInt: function(v)
            {
                if(this._position + 4 > this._limit)
                {
                    throw new Error(__BufferOverflowException__);
                }
                this.v.setInt32(this._position, v, true);
                this._position += 4;
            },
            putIntAt: function(i, v)
            {
                if(i + 4 > this._limit || i < 0)
                {
                    throw new Error(__IndexOutOfBoundsException__);
                }
                this.v.setInt32(i, v, true);
            },
            putFloat: function(v)
            {
                if(this._position + 4 > this._limit)
                {
                    throw new Error(__BufferOverflowException__);
                }
                this.v.setFloat32(this._position, v, true);
                this._position += 4;
            },
            putDouble: function(v)
            {
                if(this._position + 8 > this._limit)
                {
                    throw new Error(__BufferOverflowException__);
                }
                this.v.setFloat64(this._position, v, true);
                this._position += 8;
            },
            putLong: function(v)
            {
                if(this._position + 8 > this._limit)
                {
                    throw new Error(__BufferOverflowException__);
                }
                this.v.setInt32(this._position, v.low, true);
                this._position += 4;
                this.v.setInt32(this._position, v.high, true);
                this._position += 4;
            },
            writeString: function(stream, v)
            {
                //
                // Encode the string as utf8
                //
                var encoded = unescape(encodeURIComponent(v));
        
                stream.writeSize(encoded.length);
                stream.expand(encoded.length);
                this.putString(encoded, encoded.length);
            },
            putString: function(v, sz)
            {
                if(this._position + sz > this._limit)
                {
                    throw new Error(__BufferOverflowException__);
                }
                for(var i = 0; i < sz; ++i)
                {
                    this.v.setUint8(this._position, v.charCodeAt(i));
                    this._position++;
                }
            },
            get: function()
            {
                if(this._position >= this._limit)
                {
                    throw new Error(__BufferUnderflowException__);
                }
                var v = this.v.getUint8(this._position);
                this._position++;
                return v;
            },
            getAt: function(i)
            {
                if(i < 0 || i >= this._limit)
                {
                    throw new Error(__IndexOutOfBoundsException__);
                }
                return this.v.getUint8(i);
            },
            getArray: function(length)
            {
                if(this._position + length > this._limit)
                {
                    throw new Error(__BufferUnderflowException__);
                }
                var buffer = this.b.slice(this._position, this._position + length);
                this._position += length;
                return new Uint8Array(buffer);
            },
            getArrayAt: function(position, length)
            {
                if(position + length > this._limit)
                {
                    throw new Error(__BufferUnderflowException__);
                }
                length = length === undefined ? (this.b.byteLength - position) : length;
                return new Uint8Array(this.b.slice(position, position + length));
            },
            getShort: function()
            {
                if(this._limit - this._position < 2)
                {
                    throw new Error(__BufferUnderflowException__);
                }
                var v = this.v.getInt16(this._position, true);
                this._position += 2;
                return v;
            },
            getInt: function()
            {
                if(this._limit - this._position < 4)
                {
                    throw new Error(__BufferUnderflowException__);
                }
                var v = this.v.getInt32(this._position, true);
                this._position += 4;
                return v;
            },
            getFloat: function()
            {
                if(this._limit - this._position < 4)
                {
                    throw new Error(__BufferUnderflowException__);
                }
                var v = this.v.getFloat32(this._position, true);
                this._position += 4;
                return v;
            },
            getDouble: function()
            {
                if(this._limit - this._position < 8)
                {
                    throw new Error(__BufferUnderflowException__);
                }
                var v = this.v.getFloat64(this._position, true);
                this._position += 8;
                return v;
            },
            getLong: function()
            {
                if(this._limit - this._position < 8)
                {
                    throw new Error(__BufferUnderflowException__);
                }
                var v = new Long();
                v.low = this.v.getUint32(this._position, true);
                this._position += 4;
                v.high = this.v.getUint32(this._position, true);
                this._position += 4;
                return v;
            },
            getString: function(length)
            {
                if(this._position + length > this._limit)
                {
                    throw new Error(__BufferUnderflowException__);
                }
        
                var data = new DataView(this.b, this._position, length);
                var s = "";
        
                for(var i = 0; i < length; ++i)
                {
                    s += String.fromCharCode(data.getUint8(i));
                }
                this._position += length;
                s = decodeURIComponent(escape(s));
                return s;
            }
        });
        
        var prototype = Buffer.prototype;
        
        Object.defineProperty(prototype, "position", {
            get: function() { return this._position; },
            set: function(position){
                if(position >= 0 && position <= this._limit)
                {
                    this._position = position;
                }
            }
        });
        
        Object.defineProperty(prototype, "limit", {
            get: function() { return this._limit; },
            set: function(limit){
                if(limit <= this.capacity)
                {
                    this._limit = limit;
                    if(this._position > limit)
                    {
                        this._position = limit;
                    }
                }
            }
        });
        
        Object.defineProperty(prototype, "capacity", {
            get: function() { return this.b === null ? 0 : this.b.byteLength; }
        });
        
        Object.defineProperty(prototype, "remaining", {
            get: function() { return this._limit - this._position; }
        });
        
        //
        // Create a native buffer from an array of bytes.
        //
        Buffer.createNative = function(data)
        {
            if(data === undefined)
            {
                return new Uint8Array(0);
            }
            else
            {
                return new Uint8Array(data);
            }
        };
        
        Ice.Buffer = Buffer;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Buffer = Ice.Buffer;
        
        var Base64 = {};
        
        var _codeA = "A".charCodeAt(0);
        var _codea = "a".charCodeAt(0);
        var _code0 = "0".charCodeAt(0);
        
        Base64.encode = function(buf) // Expects native Buffer
        {
            if(buf === null || buf.length === 0)
            {
                return "";
            }
        
            var base64Bytes = (((buf.length * 4) / 3) + 1);
            var newlineBytes = (((base64Bytes * 2) / 76) + 1);
            var totalBytes = base64Bytes + newlineBytes;
        
            var v = [];
        
            var by1;
            var by2;
            var by3;
            var by4;
            var by5;
            var by6;
            var by7;
        
            for(var i = 0; i < buf.length; i += 3)
            {
                by1 = buf[i] & 0xff;
                by2 = 0;
                by3 = 0;
        
                if((i + 1) < buf.length)
                {
                    by2 = buf[i + 1] & 0xff;
                }
        
                if((i + 2) < buf.length)
                {
                    by3 = buf[i + 2] & 0xff;
                }
        
                by4 = (by1 >> 2) & 0xff;
                by5 = (((by1 & 0x3) << 4) | (by2 >> 4)) & 0xff;
                by6 = (((by2 & 0xf) << 2) | (by3 >> 6)) & 0xff;
                by7 = by3 & 0x3f;
        
                v.push(encodeChar(by4));
                v.push(encodeChar(by5));
        
                if((i + 1) < buf.length)
                {
                    v.push(encodeChar(by6));
                }
                else
                {
                    v.push("=");
                }
        
                if((i + 2) < buf.length)
                {
                    v.push(encodeChar(by7));
                }
                else
                {
                    v.push("=");
                }
            }
        
            var retval = v.join("");
            var outString = [];
            var iter = 0;
        
            while((retval.length - iter) > 76)
            {
                outString.push(retval.substring(iter, iter + 76));
                outString.push("\r\n");
                iter += 76;
            }
        
            outString.push(retval.substring(iter));
        
            return outString.join("");
        };
        
        Base64.decode = function(str) // Returns native Buffer
        {
            var newStr = [];
        
            for(var j = 0; j < str.length; j++)
            {
                var c = str.charAt(j);
                if(Base64.isBase64(c))
                {
                    newStr.push(c);
                }
            }
        
            if(newStr.length === 0)
            {
                return null;
            }
        
            // Note: This is how we were previously computing the size of the return
            //       sequence.  The method below is more efficient (and correct).
            // size_t lines = str.size() / 78;
            // size_t totalBytes = (lines * 76) + (((str.size() - (lines * 78)) * 3) / 4);
        
            // Figure out how long the final sequence is going to be.
            var totalBytes = (newStr.length * 3 / 4) + 1;
        
            var retval = new Buffer();
            retval.resize(totalBytes);
        
            var by1;
            var by2;
            var by3;
            var by4;
        
            var c1;
            var c2;
            var c3;
            var c4;
        
            var off = 0;
        
            for(var i = 0; i < newStr.length; i += 4)
            {
                c1 = "A";
                c2 = "A";
                c3 = "A";
                c4 = "A";
        
                c1 = newStr[i];
        
                if((i + 1) < newStr.length)
                {
                    c2 = newStr[i + 1];
                }
        
                if((i + 2) < newStr.length)
                {
                    c3 = newStr[i + 2];
                }
        
                if((i + 3) < newStr.length)
                {
                    c4 = newStr[i + 3];
                }
        
                by1 = decodeChar(c1) & 0xff;
                by2 = decodeChar(c2) & 0xff;
                by3 = decodeChar(c3) & 0xff;
                by4 = decodeChar(c4) & 0xff;
        
                retval.put((by1 << 2) | (by2 >> 4));
        
                if(c3 != "=")
                {
                    retval.put(((by2 & 0xf) << 4) | (by3 >> 2));
                }
        
                if(c4 != "=")
                {
                    retval.put(((by3 & 0x3) << 6) | by4);
                }
            }
        
            return retval.remaining > 0 ? retval.getArrayAt(0, retval.position) : retval.getArrayAt(0);
        };
        
        Base64.isBase64 = function(c)
        {
            if(c >= 'A' && c <= 'Z')
            {
                return true;
            }
        
            if(c >= 'a' && c <= 'z')
            {
                return true;
            }
        
            if(c >= '0' && c <= '9')
            {
                return true;
            }
        
            if(c == '+')
            {
                return true;
            }
        
            if(c == '/')
            {
                return true;
            }
        
            if(c == '=')
            {
                return true;
            }
        
            return false;
        };
        
        function encodeChar(uc)
        {
            if(uc < 26)
            {
                return String.fromCharCode(_codeA + uc);
            }
        
            if(uc < 52)
            {
                return String.fromCharCode(_codea + (uc - 26));
            }
        
            if(uc < 62)
            {
                return String.fromCharCode(_code0 + (uc - 52));
            }
        
            if(uc == 62)
            {
                return "+";
            }
        
            return "/";
        }
        
        function decodeChar(c)
        {
            if(c >= 'A' && c <= 'Z')
            {
                return c.charCodeAt(0) - _codeA;
            }
        
            if(c >= 'a' && c <= 'z')
            {
                return c.charCodeAt(0) - _codea + 26;
            }
        
            if(c >= '0' && c <= '9')
            {
                return c.charCodeAt(0) - _code0 + 52;
            }
        
            if(c == '+')
            {
                return 62;
            }
        
            return 63;
        }
        
        Ice.Base64 = Base64;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Identity.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * The identity of an Ice object. In a proxy, an empty {@link Identity#name} denotes a nil
             * proxy. An identity with an empty {@link Identity#name} and a non-empty {@link Identity#category}
             * is illegal. You cannot add a servant with an empty name to the Active Servant Map.
             * 
             * @see ServantLocator
             * @see ObjectAdapter#addServantLocator
             * 
             **/
            Ice.Identity = Slice.defineStruct(
                function(name, category)
                {
                    this.name = name !== undefined ? name : "";
                    this.category = category !== undefined ? category : "";
                },
                true,
                function(__os)
                {
                    __os.writeString(this.name);
                    __os.writeString(this.category);
                },
                function(__is)
                {
                    this.name = __is.readString();
                    this.category = __is.readString();
                },
                2, 
                false);
            Slice.defineDictionary(Ice, "ObjectDict", "ObjectDictHelper", "Ice.Identity", "Ice.ObjectHelper", false, Ice.HashMap.compareEquals, "Ice.Object");
            Slice.defineSequence(Ice, "IdentitySeqHelper", "Ice.Identity", false);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `ConnectionF.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Version.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * A version structure for the protocol version.
             * 
             **/
            Ice.ProtocolVersion = Slice.defineStruct(
                function(major, minor)
                {
                    this.major = major !== undefined ? major : 0;
                    this.minor = minor !== undefined ? minor : 0;
                },
                true,
                function(__os)
                {
                    __os.writeByte(this.major);
                    __os.writeByte(this.minor);
                },
                function(__is)
                {
                    this.major = __is.readByte();
                    this.minor = __is.readByte();
                },
                2, 
                true);
        
            /**
             * A version structure for the encoding version.
             * 
             **/
            Ice.EncodingVersion = Slice.defineStruct(
                function(major, minor)
                {
                    this.major = major !== undefined ? major : 0;
                    this.minor = minor !== undefined ? minor : 0;
                },
                true,
                function(__os)
                {
                    __os.writeByte(this.major);
                    __os.writeByte(this.minor);
                },
                function(__is)
                {
                    this.major = __is.readByte();
                    this.minor = __is.readByte();
                },
                2, 
                true);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
            
        var SliceInfo = function()
        {
            /**
            * The Slice type ID for this slice.
            **/
            this.typeId = "";
        
            /**
            * The Slice compact type ID for this slice.
            **/
            this.compactId = -1;
        
            /**
            * The encoded bytes for this slice, including the leading size integer.
            **/
            this.bytes = [];
        
            /**
            * The Ice objects referenced by this slice.
            **/
            this.objects = [];
        
            /**
            * Whether or not the slice contains optional members.
            **/
            this.hasOptionalMembers = false;
        
            /**
            * Whether or not this is the last slice.
            **/
            this.isLastSlice = false;
        };
        Ice.SliceInfo = SliceInfo;
        
        var SlicedData = function(slices)
        {
            this.slices = slices;
        };
        Ice.SlicedData = SlicedData;
        
        var UnknownSlicedObject = Ice.Class(Ice.Object,
            {
                __init__: function(unknownTypeId)
                {
                    this._unknownTypeId = unknownTypeId;
                },
                getUnknownTypeId: function()
                {
                    return this._unknownTypeId;
                },
                __write: function(os)
                {
                    os.startWriteObject(this._slicedData);
                    os.endWriteObject();
                },
                __read: function(is)
                {
                    is.startReadObject();
                    this._slicedData = is.endReadObject(true);
                }
            });
        Ice.UnknownSlicedObject = UnknownSlicedObject;
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `ObjectAdapterF.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var HashMap = Ice.HashMap;
        var Debug = Ice.Debug;
        
        var LocatorTable = Ice.Class({
            __init__: function()
            {
                this._adapterEndpointsTable = new HashMap(); // Map<String, EndpointTableEntry>
                this._objectTable = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, ReferenceTableEntry>
            },
            clear: function()
            {
                this._adapterEndpointsTable.clear();
                this._objectTable.clear();
            },
            getAdapterEndpoints: function(adapter, ttl, cached)
            {
                if(ttl === 0) // Locator cache disabled.
                {
                    cached.value = false;
                    return null;
                }
        
                var entry = this._adapterEndpointsTable.get(adapter);
                if(entry !== undefined)
                {
                    cached.value = this.checkTTL(entry.time, ttl);
                    return entry.endpoints;
                }
                cached.value = false;
                return null;
            },
            addAdapterEndpoints: function(adapter, endpoints)
            {
                this._adapterEndpointsTable.set(adapter, new EndpointTableEntry(Date.now(), endpoints));
            },
            removeAdapterEndpoints: function(adapter)
            {
                var entry = this._adapterEndpointsTable.get(adapter);
                this._adapterEndpointsTable.del(adapter);
                return entry !== undefined ? entry.endpoints : null;
            },
            getObjectReference: function(id, ttl, cached)
            {
                if(ttl === 0) // Locator cache disabled.
                {
                    cached.value = false;
                    return null;
                }
        
                var entry = this._objectTable.get(id);
                if(entry !== undefined)
                {
                    cached.value = this.checkTTL(entry.time, ttl);
                    return entry.reference;
                }
                cached.value = false;
                return null;
            },
            addObjectReference: function(id, ref)
            {
                this._objectTable.set(id, new ReferenceTableEntry(Date.now(), ref));
            },
            removeObjectReference: function(id)
            {
                var entry = this._objectTable.get(id);
                this._objectTable.del(id);
                return entry !== undefined ? entry.reference : null;
            },
            checkTTL: function(time, ttl)
            {
                Debug.assert(ttl !== 0);
                if(ttl < 0) // TTL = infinite
                {
                    return true;
                }
                else
                {
                    return Date.now() - time <= (ttl * 1000);
                }
            }
        });
        
        Ice.LocatorTable = LocatorTable;
        
        var EndpointTableEntry = function(time, endpoints)
        {
            this.time = time;
            this.endpoints = endpoints;
        };
        
        var ReferenceTableEntry = function(time, reference)
        {
            this.time = time;
            this.reference = reference;
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Timer = Ice.Timer;
        
        //
        // Promise State
        //
        var State = {Pending: 0, Success: 1, Failed: 2};
        
        var resolveImp = function(self, listener)
        {
            var callback = self.__state === State.Success ? listener.onResponse : listener.onException;
            try
            {
                if(typeof callback !== "function")
                {
                    listener.promise.setState(self.__state, self._args);
                }
                else
                {
                    var result = callback.apply(null, self._args);
        
                    //
                    // Callback can return a new promise.
                    //
                    if(result && typeof result.then == "function")
                    {
                        result.then(
                            function()
                            {
                                var args = arguments;
                                listener.promise.succeed.apply(listener.promise, args);
                            },
                            function()
                            {
                                var args = arguments;
                                listener.promise.fail.apply(listener.promise, args);
                            });
                    }
                    else
                    {
                        listener.promise.succeed(result);
                    }
                }
            }
            catch(e)
            {
                listener.promise.fail.call(listener.promise, e);
            }
        };
        
        var Promise = Ice.Class({
            __init__: function()
            {
                this.__state = State.Pending;
                this.__listeners = [];
            },
            then: function(onResponse, onException)
            {
                var promise = new Promise();
                var self = this;
                //
                // Use setImmediate so the listeners are not resolved until the call stack is empty.
                //
                Timer.setImmediate(
                    function()
                    {
                        self.__listeners.push(
                            {
                                promise:promise,
                                onResponse:onResponse,
                                onException:onException
                            });
                        self.resolve();
                    });
                return promise;
            },
            exception: function(onException)
            {
                return this.then(null, onException);
            },
            finally2: function(cb)
            {
                var p = new Promise();
                var self = this;
                
                var finallyHandler = function(method)
                {
                    return function()
                    {
                        var args = arguments;
                        try
                        {
                            var result = cb.apply(null, args);
                            if(result && typeof result.then == "function")
                            {
                                var handler = function(){ method.apply(p, args); };
                                result.then(handler).exception(handler);
                            }
                            else
                            {
                                method.apply(p, args);
                            }
                        }
                        catch(e)
                        {
                            method.apply(p, args);
                        }
                    };
                };
                
                Timer.setImmediate(
                    function(){
                        self.then(finallyHandler(p.succeed), finallyHandler(p.fail));
                    });
                return p;
            },
            delay: function(ms)
            {
                var p = new Promise();
                
                var self = this;
                
                var delayHandler = function(promise, method)
                {
                    return function()
                    {
                        var args = arguments;
                        Timer.setTimeout(
                            function()
                            {
                                method.apply(promise, args);
                            },
                            ms);
                    };
                };
                
                Timer.setImmediate(function()
                           {
                               self.then(delayHandler(p, p.succeed), delayHandler(p, p.fail));
                           });
                return p;
            },
            resolve: function()
            {
                if(this.__state === State.Pending)
                {
                    return;
                }
        
                var obj;
                while((obj = this.__listeners.pop()))
                {
                    //
                    // We use a separate function here to capture the listeners
                    // in the loop.
                    //
                    resolveImp(this, obj);
                }
            },
            setState: function(state, args)
            {
                if(this.__state === State.Pending && state !== State.Pending)
                {
                    this.__state = state;
                    this._args = args;
                    //
                    // Use setImmediate so the listeners are not resolved until the call stack is empty.
                    //
                    var self = this;
                    Timer.setImmediate(function(){ self.resolve(); });
                }
            },
            succeed: function()
            {
                var args = arguments;
                this.setState(State.Success, args);
                return this;
            },
            fail: function()
            {
                var args = arguments;
                this.setState(State.Failed, args);
                return this;
            },
            succeeded: function()
            {
                return this.__state === State.Success;
            },
            failed: function()
            {
                return this.__state === State.Failed;
            },
            completed: function()
            {
                return this.__state !== State.Pending;
            }
        });
        
        //
        // Create a new promise object that is fulfilled when all the promise arguments
        // are fulfilled or is rejected when one of the promises is rejected.
        //
        Promise.all = function()
        {
            // If only one argument is provided, check if the argument is an array
            if(arguments.length === 1 && arguments[0] instanceof Array)
            {
                return Promise.all.apply(this, arguments[0]);
            }
        
            var promise = new Promise();
            var promises = Array.prototype.slice.call(arguments);
            var results = new Array(arguments.length);
        
            var pending = promises.length;
            if(pending === 0)
            {
                promise.succeed.apply(promise, results);
            }
            for(var i = 0; i < promises.length; ++i)
            {
                //
                // Create an anonymous function to capture the loop index
                //
                
                /*jshint -W083 */
                (function(j)
                {
                    if(promises[j] && typeof promises[j].then == "function")
                    {
                        promises[j].then(
                            function()
                            {
                                results[j] = arguments;
                                pending--;
                                if(pending === 0)
                                {
                                    promise.succeed.apply(promise, results);
                                }
                            },
                            function()
                            {
                                promise.fail.apply(promise, arguments);
                            });
                    }
                    else
                    {
                        results[j] = promises[j];
                        pending--;
                        if(pending === 0)
                        {
                            promise.succeed.apply(promise, results);
                        }
                    }
                }(i));
                /*jshint +W083 */
            }
            return promise;
        };
        
        Promise.try2 = function(onResponse)
        {
            return new Promise().succeed().then(onResponse);
        };
        
        Promise.delay = function(ms)
        {
            if(arguments.length > 1)
            {
                var p = new Promise();
                var args = Array.prototype.slice.call(arguments);
                ms = args.pop();
                return p.succeed.apply(p, args).delay(ms);
            }
            else
            {
                return new Promise().succeed().delay(ms);
            }
        };
        
        Ice.Promise = Promise;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
            
            
        var Logger = Ice.Class({
            __init__: function(prefix)
            {
                if(prefix !== undefined && prefix.length > 0)
                {
                    this._prefix = prefix + ": ";
                }
                else
                {
                    this._prefix = "";
                }
                this._dateformat = 
                {
                    year: 'numeric',
                    month: 'numeric',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    hour12: false
                };
            },
            print: function(message)
            {
                this.write(message, false);
            },
            trace: function(category, message)
            {
                var s = [];
                var d = new Date();
                s.push("-- ");
                s.push(this.timestamp());
                s.push(' ');
                s.push(this._prefix);
                s.push(category);
                s.push(": ");
                s.push(message);
                this.write(s.join(""), true);
            },
            warning: function(message)
            {
                var s = [];
                var d = new Date();
                s.push("-! ");
                s.push(this.timestamp());
                s.push(' ');
                s.push(this._prefix);
                s.push("warning: ");
                s.push(message);
                this.write(s.join(""), true);
            },
            error: function(message)
            {
                var s = [];
                var d = new Date();
                s.push("!! ");
                s.push(this.timestamp());
                s.push(' ');
                s.push(this._prefix);
                s.push("error: ");
                s.push(message);
                this.write(s.join(""), true);
            },
            cloneWithPrefix: function(prefix)
            {
                return new Logger(prefix);
            },
            write: function(message, indent)
            {
                if(indent)
                {
                    message = message.replace(/\n/g, "\n   ");
                }
        
                Cr.Utils.log(message);
            },
            timestamp: function()
            {
                var d = new Date();
                return d.toLocaleString("en-US", this._dateformat) + "." + d.getMilliseconds();
            }
        });
        Ice.Logger = Logger;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `LocalException.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * This exception is raised when a failure occurs during initialization.
             * 
             **/
            Ice.InitializationException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.reason = reason !== undefined ? reason : "";
                },
                Ice.LocalException,
                "Ice::InitializationException");
        
            /**
             * This exception indicates that a failure occurred while initializing
             * a plug-in.
             * 
             **/
            Ice.PluginInitializationException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.reason = reason !== undefined ? reason : "";
                },
                Ice.LocalException,
                "Ice::PluginInitializationException");
        
            /**
             * This exception is raised if a feature is requested that is not
             * supported with collocation optimization.
             * 
             * @deprecated this exception isn't used anymore by the Ice runtime
             **/
            Ice.CollocationOptimizationException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::CollocationOptimizationException");
        
            /**
             * An attempt was made to register something more than once with
             * the Ice run time.
             * 
             * This exception is raised if an attempt is made to register a
             * servant, servant locator, facet, object factory, plug-in, object
             * adapter, object, or user exception factory more than once for the
             * same ID.
             * 
             **/
            Ice.AlreadyRegisteredException = Slice.defineLocalException(
                function(kindOfObject, id, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.kindOfObject = kindOfObject !== undefined ? kindOfObject : "";
                    this.id = id !== undefined ? id : "";
                },
                Ice.LocalException,
                "Ice::AlreadyRegisteredException");
        
            /**
             * An attempt was made to find or deregister something that is not
             * registered with the Ice run time or Ice locator.
             * 
             * This exception is raised if an attempt is made to remove a servant,
             * servant locator, facet, object factory, plug-in, object adapter,
             * object, or user exception factory that is not currently registered.
             * 
             * It's also raised if the Ice locator can't find an object or object
             * adapter when resolving an indirect proxy or when an object adapter
             * is activated.
             * 
             **/
            Ice.NotRegisteredException = Slice.defineLocalException(
                function(kindOfObject, id, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.kindOfObject = kindOfObject !== undefined ? kindOfObject : "";
                    this.id = id !== undefined ? id : "";
                },
                Ice.LocalException,
                "Ice::NotRegisteredException");
        
            /**
             * The operation can only be invoked with a twoway request.
             * 
             * This exception is raised if an attempt is made to invoke an
             * operation with <tt>ice_oneway</tt>, <tt>ice_batchOneway</tt>, <tt>ice_datagram</tt>,
             * or <tt>ice_batchDatagram</tt> and the operation has a return value,
             * out-parameters, or an exception specification.
             * 
             **/
            Ice.TwowayOnlyException = Slice.defineLocalException(
                function(operation, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.operation = operation !== undefined ? operation : "";
                },
                Ice.LocalException,
                "Ice::TwowayOnlyException");
        
            /**
             * An attempt was made to clone a class that does not support
             * cloning.
             * 
             * This exception is raised if <tt>ice_clone</tt> is called on
             * a class that is derived from an abstract Slice class (that is,
             * a class containing operations), and the derived class does not
             * provide an implementation of the <tt>ice_clone</tt> operation (C++ only).
             * 
             **/
            Ice.CloneNotImplementedException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::CloneNotImplementedException");
        
            /**
             * This exception is raised if an operation call on a server raises an
             * unknown exception. For example, for C++, this exception is raised
             * if the server throws a C++ exception that is not directly or
             * indirectly derived from <tt>Ice::LocalException</tt> or
             * <tt>Ice::UserException</tt>.
             * 
             **/
            Ice.UnknownException = Slice.defineLocalException(
                function(unknown, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.unknown = unknown !== undefined ? unknown : "";
                },
                Ice.LocalException,
                "Ice::UnknownException");
        
            /**
             * This exception is raised if an operation call on a server raises a
             * local exception. Because local exceptions are not transmitted by
             * the Ice protocol, the client receives all local exceptions raised
             * by the server as {@link UnknownLocalException}. The only exception to this
             * rule are all exceptions derived from {@link RequestFailedException},
             * which are transmitted by the Ice protocol even though they are
             * declared <tt>local</tt>.
             * 
             **/
            Ice.UnknownLocalException = Slice.defineLocalException(
                function(unknown, _cause)
                {
                    Ice.UnknownException.call(this, unknown, _cause);
                },
                Ice.UnknownException,
                "Ice::UnknownLocalException");
        
            /**
             * An operation raised an incorrect user exception.
             * 
             * This exception is raised if an operation raises a
             * user exception that is not declared in the exception's
             * <tt>throws</tt> clause. Such undeclared exceptions are
             * not transmitted from the server to the client by the Ice
             * protocol, but instead the client just gets an
             * {@link UnknownUserException}. This is necessary in order to not violate
             * the contract established by an operation's signature: Only local
             * exceptions and user exceptions declared in the
             * <tt>throws</tt> clause can be raised.
             * 
             **/
            Ice.UnknownUserException = Slice.defineLocalException(
                function(unknown, _cause)
                {
                    Ice.UnknownException.call(this, unknown, _cause);
                },
                Ice.UnknownException,
                "Ice::UnknownUserException");
        
            /**
             * This exception is raised if the Ice library version does not match
             * the version in the Ice header files.
             * 
             **/
            Ice.VersionMismatchException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::VersionMismatchException");
        
            /**
             * This exception is raised if the {@link Communicator} has been destroyed.
             * 
             * @see Communicator#destroy
             * 
             **/
            Ice.CommunicatorDestroyedException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::CommunicatorDestroyedException");
        
            /**
             * This exception is raised if an attempt is made to use a deactivated
             * {@link ObjectAdapter}.
             * 
             * @see ObjectAdapter#deactivate
             * @see Communicator#shutdown
             * 
             **/
            Ice.ObjectAdapterDeactivatedException = Slice.defineLocalException(
                function(name, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.name = name !== undefined ? name : "";
                },
                Ice.LocalException,
                "Ice::ObjectAdapterDeactivatedException");
        
            /**
             * This exception is raised if an {@link ObjectAdapter} cannot be activated.
             * 
             * This happens if the {@link Locator} detects another active {@link ObjectAdapter} with
             * the same adapter id.
             * 
             **/
            Ice.ObjectAdapterIdInUseException = Slice.defineLocalException(
                function(id, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.id = id !== undefined ? id : "";
                },
                Ice.LocalException,
                "Ice::ObjectAdapterIdInUseException");
        
            /**
             * This exception is raised if no suitable endpoint is available.
             * 
             **/
            Ice.NoEndpointException = Slice.defineLocalException(
                function(proxy, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.proxy = proxy !== undefined ? proxy : "";
                },
                Ice.LocalException,
                "Ice::NoEndpointException");
        
            /**
             * This exception is raised if there was an error while parsing an
             * endpoint.
             * 
             **/
            Ice.EndpointParseException = Slice.defineLocalException(
                function(str, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.str = str !== undefined ? str : "";
                },
                Ice.LocalException,
                "Ice::EndpointParseException");
        
            /**
             * This exception is raised if there was an error while parsing an
             * endpoint selection type.
             * 
             **/
            Ice.EndpointSelectionTypeParseException = Slice.defineLocalException(
                function(str, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.str = str !== undefined ? str : "";
                },
                Ice.LocalException,
                "Ice::EndpointSelectionTypeParseException");
        
            /**
             * This exception is raised if there was an error while parsing a
             * version.
             * 
             **/
            Ice.VersionParseException = Slice.defineLocalException(
                function(str, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.str = str !== undefined ? str : "";
                },
                Ice.LocalException,
                "Ice::VersionParseException");
        
            /**
             * This exception is raised if there was an error while parsing a
             * stringified identity.
             * 
             **/
            Ice.IdentityParseException = Slice.defineLocalException(
                function(str, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.str = str !== undefined ? str : "";
                },
                Ice.LocalException,
                "Ice::IdentityParseException");
        
            /**
             * This exception is raised if there was an error while parsing a
             * stringified proxy.
             * 
             **/
            Ice.ProxyParseException = Slice.defineLocalException(
                function(str, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.str = str !== undefined ? str : "";
                },
                Ice.LocalException,
                "Ice::ProxyParseException");
        
            /**
             * This exception is raised if an illegal identity is encountered.
             * 
             **/
            Ice.IllegalIdentityException = Slice.defineLocalException(
                function(id, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.id = id !== undefined ? id : new Ice.Identity();
                },
                Ice.LocalException,
                "Ice::IllegalIdentityException");
        
            /**
             * This exception is raised to reject an illegal servant (typically
             * a null servant)
             * 
             **/
            Ice.IllegalServantException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.reason = reason !== undefined ? reason : "";
                },
                Ice.LocalException,
                "Ice::IllegalServantException");
        
            /**
             * This exception is raised if a request failed. This exception, and
             * all exceptions derived from {@link RequestFailedException}, are
             * transmitted by the Ice protocol, even though they are declared
             * <tt>local</tt>.
             * 
             **/
            Ice.RequestFailedException = Slice.defineLocalException(
                function(id, facet, operation, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.id = id !== undefined ? id : new Ice.Identity();
                    this.facet = facet !== undefined ? facet : "";
                    this.operation = operation !== undefined ? operation : "";
                },
                Ice.LocalException,
                "Ice::RequestFailedException");
        
            /**
             * This exception is raised if an object does not exist on the server,
             * that is, if no facets with the given identity exist.
             * 
             **/
            Ice.ObjectNotExistException = Slice.defineLocalException(
                function(id, facet, operation, _cause)
                {
                    Ice.RequestFailedException.call(this, id, facet, operation, _cause);
                },
                Ice.RequestFailedException,
                "Ice::ObjectNotExistException");
        
            /**
             * This exception is raised if no facet with the given name exists,
             * but at least one facet with the given identity exists.
             * 
             **/
            Ice.FacetNotExistException = Slice.defineLocalException(
                function(id, facet, operation, _cause)
                {
                    Ice.RequestFailedException.call(this, id, facet, operation, _cause);
                },
                Ice.RequestFailedException,
                "Ice::FacetNotExistException");
        
            /**
             * This exception is raised if an operation for a given object does
             * not exist on the server. Typically this is caused by either the
             * client or the server using an outdated Slice specification.
             * 
             **/
            Ice.OperationNotExistException = Slice.defineLocalException(
                function(id, facet, operation, _cause)
                {
                    Ice.RequestFailedException.call(this, id, facet, operation, _cause);
                },
                Ice.RequestFailedException,
                "Ice::OperationNotExistException");
        
            /**
             * This exception is raised if a system error occurred in the server
             * or client process. There are many possible causes for such a system
             * exception. For details on the cause, {@link SyscallException#error}
             * should be inspected.
             * 
             **/
            Ice.SyscallException = Slice.defineLocalException(
                function(error, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.error = error !== undefined ? error : 0;
                },
                Ice.LocalException,
                "Ice::SyscallException");
        
            /**
             * This exception indicates socket errors.
             * 
             **/
            Ice.SocketException = Slice.defineLocalException(
                function(error, _cause)
                {
                    Ice.SyscallException.call(this, error, _cause);
                },
                Ice.SyscallException,
                "Ice::SocketException");
        
            /**
             * This exception indicates file errors.
             * 
             **/
            Ice.FileException = Slice.defineLocalException(
                function(error, path, _cause)
                {
                    Ice.SyscallException.call(this, error, _cause);
                    this.path = path !== undefined ? path : "";
                },
                Ice.SyscallException,
                "Ice::FileException");
        
            /**
             * This exception indicates connection failures.
             * 
             **/
            Ice.ConnectFailedException = Slice.defineLocalException(
                function(error, _cause)
                {
                    Ice.SocketException.call(this, error, _cause);
                },
                Ice.SocketException,
                "Ice::ConnectFailedException");
        
            /**
             * This exception indicates a connection failure for which
             * the server host actively refuses a connection.
             * 
             **/
            Ice.ConnectionRefusedException = Slice.defineLocalException(
                function(error, _cause)
                {
                    Ice.ConnectFailedException.call(this, error, _cause);
                },
                Ice.ConnectFailedException,
                "Ice::ConnectionRefusedException");
        
            /**
             * This exception indicates a lost connection.
             * 
             **/
            Ice.ConnectionLostException = Slice.defineLocalException(
                function(error, _cause)
                {
                    Ice.SocketException.call(this, error, _cause);
                },
                Ice.SocketException,
                "Ice::ConnectionLostException");
        
            /**
             * This exception indicates a DNS problem. For details on the cause,
             * {@link DNSException#error} should be inspected.
             * 
             **/
            Ice.DNSException = Slice.defineLocalException(
                function(error, host, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.error = error !== undefined ? error : 0;
                    this.host = host !== undefined ? host : "";
                },
                Ice.LocalException,
                "Ice::DNSException");
        
            /**
             * This exception indicates a request was interrupted.
             * 
             **/
            Ice.OperationInterruptedException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::OperationInterruptedException");
        
            /**
             * This exception indicates a timeout condition.
             * 
             **/
            Ice.TimeoutException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::TimeoutException");
        
            /**
             * This exception indicates a connection establishment timeout condition.
             * 
             **/
            Ice.ConnectTimeoutException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.TimeoutException.call(this, _cause);
                },
                Ice.TimeoutException,
                "Ice::ConnectTimeoutException");
        
            /**
             * This exception indicates a connection closure timeout condition.
             * 
             **/
            Ice.CloseTimeoutException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.TimeoutException.call(this, _cause);
                },
                Ice.TimeoutException,
                "Ice::CloseTimeoutException");
        
            /**
             * This exception indicates that a connection has been shut down because it has been
             * idle for some time.
             * 
             **/
            Ice.ConnectionTimeoutException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.TimeoutException.call(this, _cause);
                },
                Ice.TimeoutException,
                "Ice::ConnectionTimeoutException");
        
            /**
             * This exception indicates that an invocation failed because it timed
             * out.
             * 
             **/
            Ice.InvocationTimeoutException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.TimeoutException.call(this, _cause);
                },
                Ice.TimeoutException,
                "Ice::InvocationTimeoutException");
        
            /**
             * This exception indicates that an asynchronous invocation failed
             * because it was canceled explicitly by the user using the
             * <tt>Ice::AsyncResult::cancel</tt> method.
             * 
             **/
            Ice.InvocationCanceledException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::InvocationCanceledException");
        
            /**
             * A generic exception base for all kinds of protocol error
             * conditions.
             * 
             **/
            Ice.ProtocolException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.reason = reason !== undefined ? reason : "";
                },
                Ice.LocalException,
                "Ice::ProtocolException");
        
            /**
             * This exception indicates that a message did not start with the expected
             * magic number ('I', 'c', 'e', 'P').
             * 
             **/
            Ice.BadMagicException = Slice.defineLocalException(
                function(reason, badMagic, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                    this.badMagic = badMagic !== undefined ? badMagic : null;
                },
                Ice.ProtocolException,
                "Ice::BadMagicException");
        
            /**
             * This exception indicates an unsupported protocol version.
             * 
             **/
            Ice.UnsupportedProtocolException = Slice.defineLocalException(
                function(reason, bad, supported, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                    this.bad = bad !== undefined ? bad : new Ice.ProtocolVersion();
                    this.supported = supported !== undefined ? supported : new Ice.ProtocolVersion();
                },
                Ice.ProtocolException,
                "Ice::UnsupportedProtocolException");
        
            /**
             * This exception indicates an unsupported data encoding version.
             * 
             **/
            Ice.UnsupportedEncodingException = Slice.defineLocalException(
                function(reason, bad, supported, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                    this.bad = bad !== undefined ? bad : new Ice.EncodingVersion();
                    this.supported = supported !== undefined ? supported : new Ice.EncodingVersion();
                },
                Ice.ProtocolException,
                "Ice::UnsupportedEncodingException");
        
            /**
             * This exception indicates that an unknown protocol message has been received.
             * 
             **/
            Ice.UnknownMessageException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::UnknownMessageException");
        
            /**
             * This exception is raised if a message is received over a connection
             * that is not yet validated.
             * 
             **/
            Ice.ConnectionNotValidatedException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::ConnectionNotValidatedException");
        
            /**
             * This exception indicates that a response for an unknown request ID has been
             * received.
             * 
             **/
            Ice.UnknownRequestIdException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::UnknownRequestIdException");
        
            /**
             * This exception indicates that an unknown reply status has been received.
             * 
             **/
            Ice.UnknownReplyStatusException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::UnknownReplyStatusException");
        
            /**
             * This exception indicates that the connection has been gracefully shut down by the
             * server. The operation call that caused this exception has not been
             * executed by the server. In most cases you will not get this
             * exception, because the client will automatically retry the
             * operation call in case the server shut down the connection. However,
             * if upon retry the server shuts down the connection again, and the
             * retry limit has been reached, then this exception is propagated to
             * the application code.
             * 
             **/
            Ice.CloseConnectionException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::CloseConnectionException");
        
            /**
             * This exception is raised by an operation call if the application
             * forcefully closes the connection {@link Connection#close}.
             * 
             * @see Connection#close
             * 
             **/
            Ice.ForcedCloseConnectionException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::ForcedCloseConnectionException");
        
            /**
             * This exception indicates that a message size is less
             * than the minimum required size.
             * 
             **/
            Ice.IllegalMessageSizeException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::IllegalMessageSizeException");
        
            /**
             * This exception indicates a problem with compressing or uncompressing data.
             * 
             **/
            Ice.CompressionException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::CompressionException");
        
            /**
             * A datagram exceeds the configured size.
             * 
             * This exception is raised if a datagram exceeds the configured send or receive buffer
             * size, or exceeds the maximum payload size of a UDP packet (65507 bytes).
             * 
             **/
            Ice.DatagramLimitException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::DatagramLimitException");
        
            /**
             * This exception is raised for errors during marshaling or unmarshaling data.
             * 
             **/
            Ice.MarshalException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.ProtocolException.call(this, reason, _cause);
                },
                Ice.ProtocolException,
                "Ice::MarshalException");
        
            /**
             * This exception is raised if inconsistent data is received while unmarshaling a proxy.
             * 
             **/
            Ice.ProxyUnmarshalException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.MarshalException.call(this, reason, _cause);
                },
                Ice.MarshalException,
                "Ice::ProxyUnmarshalException");
        
            /**
             * This exception is raised if an out-of-bounds condition occurs during unmarshaling.
             * 
             **/
            Ice.UnmarshalOutOfBoundsException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.MarshalException.call(this, reason, _cause);
                },
                Ice.MarshalException,
                "Ice::UnmarshalOutOfBoundsException");
        
            /**
             * This exception is raised if no suitable object factory was found during
             * unmarshaling of a Slice class instance.
             * 
             * @see ObjectFactory
             * @see Communicator#addObjectFactory
             * @see Communicator#findObjectFactory
             * 
             **/
            Ice.NoObjectFactoryException = Slice.defineLocalException(
                function(reason, type, _cause)
                {
                    Ice.MarshalException.call(this, reason, _cause);
                    this.type = type !== undefined ? type : "";
                },
                Ice.MarshalException,
                "Ice::NoObjectFactoryException");
        
            /**
             * This exception is raised if the type of an unmarshaled Slice class instance does
             * not match its expected type.
             * This can happen if client and server are compiled with mismatched Slice
             * definitions or if a class of the wrong type is passed as a parameter
             * or return value using dynamic invocation. This exception can also be
             * raised if {@link IceStorm} is used to send Slice class instances and
             * an operation is subscribed to the wrong topic.
             * 
             **/
            Ice.UnexpectedObjectException = Slice.defineLocalException(
                function(reason, type, expectedType, _cause)
                {
                    Ice.MarshalException.call(this, reason, _cause);
                    this.type = type !== undefined ? type : "";
                    this.expectedType = expectedType !== undefined ? expectedType : "";
                },
                Ice.MarshalException,
                "Ice::UnexpectedObjectException");
        
            /**
             * This exception is raised when Ice receives a request or reply
             * message whose size exceeds the limit specified by the
             * <tt>Ice.MessageSizeMax</tt> property.
             * 
             **/
            Ice.MemoryLimitException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.MarshalException.call(this, reason, _cause);
                },
                Ice.MarshalException,
                "Ice::MemoryLimitException");
        
            /**
             * This exception is raised when a string conversion to or from UTF-8
             * fails during marshaling or unmarshaling.
             * 
             **/
            Ice.StringConversionException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.MarshalException.call(this, reason, _cause);
                },
                Ice.MarshalException,
                "Ice::StringConversionException");
        
            /**
             * This exception indicates a malformed data encapsulation.
             * 
             **/
            Ice.EncapsulationException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.MarshalException.call(this, reason, _cause);
                },
                Ice.MarshalException,
                "Ice::EncapsulationException");
        
            /**
             * This exception is raised if an unsupported feature is used. The
             * unsupported feature string contains the name of the unsupported
             * feature
             * 
             **/
            Ice.FeatureNotSupportedException = Slice.defineLocalException(
                function(unsupportedFeature, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.unsupportedFeature = unsupportedFeature !== undefined ? unsupportedFeature : "";
                },
                Ice.LocalException,
                "Ice::FeatureNotSupportedException");
        
            /**
             * This exception indicates a failure in a security subsystem,
             * such as the IceSSL plug-in.
             * 
             **/
            Ice.SecurityException = Slice.defineLocalException(
                function(reason, _cause)
                {
                    Ice.LocalException.call(this, _cause);
                    this.reason = reason !== undefined ? reason : "";
                },
                Ice.LocalException,
                "Ice::SecurityException");
        
            /**
             * This exception indicates that an attempt has been made to
             * change the connection properties of a fixed proxy.
             * 
             **/
            Ice.FixedProxyException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::FixedProxyException");
        
            /**
             * Indicates that the response to a request has already been sent;
             * re-dispatching such a request is not possible.
             * 
             **/
            Ice.ResponseSentException = Slice.defineLocalException(
                function(_cause)
                {
                    Ice.LocalException.call(this, _cause);
                },
                Ice.LocalException,
                "Ice::ResponseSentException");
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var StringUtil = Ice.StringUtil;
        
        var Protocol = {};
        
        Ice.Encoding_1_0 = new Ice.EncodingVersion(1, 0);
        Ice.Encoding_1_1 = new Ice.EncodingVersion(1, 1);
        
        Ice.Protocol_1_0 = new Ice.ProtocolVersion(1, 0);
        
        //
        // Size of the Ice protocol header
        //
        // Magic number (4 bytes)
        // Protocol version major (Byte)
        // Protocol version minor (Byte)
        // Encoding version major (Byte)
        // Encoding version minor (Byte)
        // Message type (Byte)
        // Compression status (Byte)
        // Message size (Int)
        //
        Protocol.headerSize = 14;
        
        //
        // The magic number at the front of each message
        //
        //Protocol.magic = [ 0x49, 0x63, 0x65, 0x50 ];      // 'I', 'c', 'e', 'P'
        Protocol.magic = Ice.Buffer.createNative([ 0x49, 0x63, 0x65, 0x50 ]);      // 'I', 'c', 'e', 'P'
        
        //
        // The current Ice protocol and encoding version
        //
        Protocol.protocolMajor = 1;
        Protocol.protocolMinor = 0;
        Protocol.protocolEncodingMajor = 1;
        Protocol.protocolEncodingMinor = 0;
        
        Protocol.encodingMajor = 1;
        Protocol.encodingMinor = 1;
        
        //
        // The Ice protocol message types
        //
        Protocol.requestMsg = 0;
        Protocol.requestBatchMsg = 1;
        Protocol.replyMsg = 2;
        Protocol.validateConnectionMsg = 3;
        Protocol.closeConnectionMsg = 4;
        
        //
        // Reply status
        //
        Protocol.replyOK = 0;
        Protocol.replyUserException = 1;
        Protocol.replyObjectNotExist = 2;
        Protocol.replyFacetNotExist = 3;
        Protocol.replyOperationNotExist = 4;
        Protocol.replyUnknownLocalException = 5;
        Protocol.replyUnknownUserException = 6;
        Protocol.replyUnknownException = 7;
        
        Protocol.requestHdr = Ice.Buffer.createNative([
            Protocol.magic[0],
            Protocol.magic[1],
            Protocol.magic[2],
            Protocol.magic[3],
            Protocol.protocolMajor,
            Protocol.protocolMinor,
            Protocol.protocolEncodingMajor,
            Protocol.protocolEncodingMinor,
            Protocol.requestMsg,
            0, // Compression status.
            0, 0, 0, 0, // Message size (placeholder).
            0, 0, 0, 0  // Request ID (placeholder).
        ]);
        
        Protocol.requestBatchHdr = Ice.Buffer.createNative([
            Protocol.magic[0],
            Protocol.magic[1],
            Protocol.magic[2],
            Protocol.magic[3],
            Protocol.protocolMajor,
            Protocol.protocolMinor,
            Protocol.protocolEncodingMajor,
            Protocol.protocolEncodingMinor,
            Protocol.requestBatchMsg,
            0, // Compression status.
            0, 0, 0, 0, // Message size (placeholder).
            0, 0, 0, 0  // Number of requests in batch (placeholder).
        ]);
        
        Protocol.replyHdr = Ice.Buffer.createNative([
            Protocol.magic[0],
            Protocol.magic[1],
            Protocol.magic[2],
            Protocol.magic[3],
            Protocol.protocolMajor,
            Protocol.protocolMinor,
            Protocol.protocolEncodingMajor,
            Protocol.protocolEncodingMinor,
            Protocol.replyMsg,
            0, // Compression status.
            0, 0, 0, 0 // Message size (placeholder).
        ]);
        
        Protocol.currentProtocol = new Ice.ProtocolVersion(Protocol.protocolMajor, Protocol.protocolMinor);
        Protocol.currentProtocolEncoding = new Ice.EncodingVersion(Protocol.protocolEncodingMajor, 
                                                                    Protocol.protocolEncodingMinor);
        
        Protocol.currentEncoding = new Ice.EncodingVersion(Protocol.encodingMajor, Protocol.encodingMinor);
        
        Protocol.checkSupportedProtocol = function(v)
        {
            if(v.major !== Protocol.currentProtocol.major || v.minor > Protocol.currentProtocol.minor)
            {
                throw new Ice.UnsupportedProtocolException("", v, Protocol.currentProtocol);
            }
        };
        
        Protocol.checkSupportedProtocolEncoding = function(v)
        {
            if(v.major !== Protocol.currentProtocolEncoding.major ||
            v.minor > Protocol.currentProtocolEncoding.minor)
            {
                throw new Ice.UnsupportedEncodingException("", v, Protocol.currentProtocolEncoding);
            }
        };
        
        Protocol.checkSupportedEncoding = function(v)
        {
            if(v.major !== Protocol.currentEncoding.major || v.minor > Protocol.currentEncoding.minor)
            {
                throw new Ice.UnsupportedEncodingException("", v, Protocol.currentEncoding);
            }
        };
        
        //
        // Either return the given protocol if not compatible, or the greatest
        // supported protocol otherwise.
        //
        Protocol.getCompatibleProtocol = function(v)
        {
            if(v.major !== Protocol.currentProtocol.major)
            {
                return v; // Unsupported protocol, return as is.
            }
            else if(v.minor < Protocol.currentProtocol.minor)
            {
                return v; // Supported protocol.
            }
            else
            {
                //
                // Unsupported but compatible, use the currently supported
                // protocol, that's the best we can do.
                //
                return Protocol.currentProtocol; 
            }
        };
        
        //
        // Either return the given encoding if not compatible, or the greatest
        // supported encoding otherwise.
        //
        Protocol.getCompatibleEncoding = function(v)
        {
            if(v.major !== Protocol.currentEncoding.major)
            {
                return v; // Unsupported encoding, return as is.
            }
            else if(v.minor < Protocol.currentEncoding.minor)
            {
                return v; // Supported encoding.
            }
            else
            {
                //
                // Unsupported but compatible, use the currently supported
                // encoding, that's the best we can do.
                //
                return Protocol.currentEncoding; 
            }
        };
        
        Protocol.isSupported = function(version, supported)
        {
            return version.major === supported.major && version.minor <= supported.minor;
        };
        
        /**
        * Converts a string to a protocol version.
        *
        * @param version The string to convert.
        *
        * @return The converted protocol version.
        **/
        Ice.stringToProtocolVersion = function(version)
        {
            return new Ice.ProtocolVersion(stringToMajor(version), stringToMinor(version));
        };
        
        /**
        * Converts a string to an encoding version.
        *
        * @param version The string to convert.
        *
        * @return The converted object identity.
        **/
        Ice.stringToEncodingVersion = function(version)
        {
            return new Ice.EncodingVersion(stringToMajor(version), stringToMinor(version));
        };
        
        /**
        * Converts a protocol version to a string.
        *
        * @param v The protocol version to convert.
        *
        * @return The converted string.
        **/
        Ice.protocolVersionToString = function(v)
        {
            return majorMinorToString(v.major, v.minor);
        };
        
        /**
        * Converts an encoding version to a string.
        *
        * @param v The encoding version to convert.
        *
        * @return The converted string.
        **/
        Ice.encodingVersionToString = function(v)
        {
            return majorMinorToString(v.major, v.minor);
        };
        
        Ice.Protocol = Protocol;
        
        function stringToMajor(str)
        {
            var pos = str.indexOf('.');
            if(pos === -1)
            {
                throw new Ice.VersionParseException("malformed version value `" + str + "'");
            }
                
            var majStr = str.substring(0, pos);
            var majVersion;
            try
            {
                majVersion = StringUtil.toInt(majStr);
            }
            catch(ex)
            {
                throw new Ice.VersionParseException("invalid version value `" + str + "'");
            }
            
            if(majVersion < 1 || majVersion > 255)
            {
                throw new Ice.VersionParseException("range error in version `" + str + "'");
            }
        
            return majVersion;
        }
        
        function stringToMinor(str)
        {
            var pos = str.indexOf('.');
            if(pos === -1)
            {
                throw new Ice.VersionParseException("malformed version value `" + str + "'");
            }
                
            var minStr = str.substring(pos + 1);
            var minVersion;
            try
            {
                minVersion = StringUtil.toInt(minStr);
            }
            catch(ex)
            {
                throw new Ice.VersionParseException("invalid version value `" + str + "'");
            }
            
            if(minVersion < 0 || minVersion > 255)
            {
                throw new Ice.VersionParseException("range error in version `" + str + "'");
            }
        
            return minVersion;
        }
        
        function majorMinorToString(major, minor)
        {
            return major + "." + minor;
        }
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        var Property = function Property(pattern, deprecated, deprecatedBy)
        {
            this._pattern = pattern;
            this._deprecated = deprecated;
            this._deprecatedBy = deprecatedBy;
        };
        
        Object.defineProperty(Property.prototype, "pattern",{
            get: function() { return this._pattern; }
        });
        
        Object.defineProperty(Property.prototype, "deprecated",{
            get: function() { return this._deprecated; }
        });
        
        Object.defineProperty(Property.prototype, "deprecatedBy",{
            get: function() { return this._deprecatedBy; }
        });
        
        Ice.Property = Property;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        // Generated by makeprops.py from file ./config/PropertyNames.xml, Tue Apr 28 22:03:41 2015
        
        // IMPORTANT: Do not edit this file -- any edits made here will be lost!
        
        var PropertyNames = {};
        var Property = Ice.Property;
        /* jshint -W044*/
        
        PropertyNames.IceProps =
        [
            new Property("/^Ice\.ACM\.Client/", true, null),
            new Property("/^Ice\.ACM\.Server/", true, null),
            new Property("/^Ice\.ACM\.Timeout/", false, null),
            new Property("/^Ice\.ACM\.Heartbeat/", false, null),
            new Property("/^Ice\.ACM\.Close/", false, null),
            new Property("/^Ice\.ACM/", false, null),
            new Property("/^Ice\.ACM\.Client\.Timeout/", false, null),
            new Property("/^Ice\.ACM\.Client\.Heartbeat/", false, null),
            new Property("/^Ice\.ACM\.Client\.Close/", false, null),
            new Property("/^Ice\.ACM\.Client/", false, null),
            new Property("/^Ice\.ACM\.Server\.Timeout/", false, null),
            new Property("/^Ice\.ACM\.Server\.Heartbeat/", false, null),
            new Property("/^Ice\.ACM\.Server\.Close/", false, null),
            new Property("/^Ice\.ACM\.Server/", false, null),
            new Property("/^Ice\.Admin\.ACM\.Timeout/", false, null),
            new Property("/^Ice\.Admin\.ACM\.Heartbeat/", false, null),
            new Property("/^Ice\.Admin\.ACM\.Close/", false, null),
            new Property("/^Ice\.Admin\.ACM/", false, null),
            new Property("/^Ice\.Admin\.AdapterId/", false, null),
            new Property("/^Ice\.Admin\.Endpoints/", false, null),
            new Property("/^Ice\.Admin\.Locator\.EndpointSelection/", false, null),
            new Property("/^Ice\.Admin\.Locator\.ConnectionCached/", false, null),
            new Property("/^Ice\.Admin\.Locator\.PreferSecure/", false, null),
            new Property("/^Ice\.Admin\.Locator\.LocatorCacheTimeout/", false, null),
            new Property("/^Ice\.Admin\.Locator\.InvocationTimeout/", false, null),
            new Property("/^Ice\.Admin\.Locator\.Locator/", false, null),
            new Property("/^Ice\.Admin\.Locator\.Router/", false, null),
            new Property("/^Ice\.Admin\.Locator\.CollocationOptimized/", false, null),
            new Property("/^Ice\.Admin\.Locator\.Context\../", false, null),
            new Property("/^Ice\.Admin\.Locator/", false, null),
            new Property("/^Ice\.Admin\.PublishedEndpoints/", false, null),
            new Property("/^Ice\.Admin\.ReplicaGroupId/", false, null),
            new Property("/^Ice\.Admin\.Router\.EndpointSelection/", false, null),
            new Property("/^Ice\.Admin\.Router\.ConnectionCached/", false, null),
            new Property("/^Ice\.Admin\.Router\.PreferSecure/", false, null),
            new Property("/^Ice\.Admin\.Router\.LocatorCacheTimeout/", false, null),
            new Property("/^Ice\.Admin\.Router\.InvocationTimeout/", false, null),
            new Property("/^Ice\.Admin\.Router\.Locator/", false, null),
            new Property("/^Ice\.Admin\.Router\.Router/", false, null),
            new Property("/^Ice\.Admin\.Router\.CollocationOptimized/", false, null),
            new Property("/^Ice\.Admin\.Router\.Context\../", false, null),
            new Property("/^Ice\.Admin\.Router/", false, null),
            new Property("/^Ice\.Admin\.ProxyOptions/", false, null),
            new Property("/^Ice\.Admin\.ThreadPool\.Size/", false, null),
            new Property("/^Ice\.Admin\.ThreadPool\.SizeMax/", false, null),
            new Property("/^Ice\.Admin\.ThreadPool\.SizeWarn/", false, null),
            new Property("/^Ice\.Admin\.ThreadPool\.StackSize/", false, null),
            new Property("/^Ice\.Admin\.ThreadPool\.Serialize/", false, null),
            new Property("/^Ice\.Admin\.ThreadPool\.ThreadIdleTime/", false, null),
            new Property("/^Ice\.Admin\.ThreadPool\.ThreadPriority/", false, null),
            new Property("/^Ice\.Admin\.MessageSizeMax/", false, null),
            new Property("/^Ice\.Admin\.DelayCreation/", false, null),
            new Property("/^Ice\.Admin\.Enabled/", false, null),
            new Property("/^Ice\.Admin\.Facets/", false, null),
            new Property("/^Ice\.Admin\.InstanceName/", false, null),
            new Property("/^Ice\.Admin\.Logger\.KeepLogs/", false, null),
            new Property("/^Ice\.Admin\.Logger\.KeepTraces/", false, null),
            new Property("/^Ice\.Admin\.Logger\.Properties/", false, null),
            new Property("/^Ice\.Admin\.ServerId/", false, null),
            new Property("/^Ice\.BackgroundLocatorCacheUpdates/", false, null),
            new Property("/^Ice\.BatchAutoFlush/", true, null),
            new Property("/^Ice\.BatchAutoFlushSize/", false, null),
            new Property("/^Ice\.ChangeUser/", false, null),
            new Property("/^Ice\.ClientAccessPolicyProtocol/", false, null),
            new Property("/^Ice\.Compression\.Level/", false, null),
            new Property("/^Ice\.CollectObjects/", false, null),
            new Property("/^Ice\.Config/", false, null),
            new Property("/^Ice\.ConsoleListener/", false, null),
            new Property("/^Ice\.Default\.CollocationOptimized/", false, null),
            new Property("/^Ice\.Default\.EncodingVersion/", false, null),
            new Property("/^Ice\.Default\.EndpointSelection/", false, null),
            new Property("/^Ice\.Default\.Host/", false, null),
            new Property("/^Ice\.Default\.Locator\.EndpointSelection/", false, null),
            new Property("/^Ice\.Default\.Locator\.ConnectionCached/", false, null),
            new Property("/^Ice\.Default\.Locator\.PreferSecure/", false, null),
            new Property("/^Ice\.Default\.Locator\.LocatorCacheTimeout/", false, null),
            new Property("/^Ice\.Default\.Locator\.InvocationTimeout/", false, null),
            new Property("/^Ice\.Default\.Locator\.Locator/", false, null),
            new Property("/^Ice\.Default\.Locator\.Router/", false, null),
            new Property("/^Ice\.Default\.Locator\.CollocationOptimized/", false, null),
            new Property("/^Ice\.Default\.Locator\.Context\../", false, null),
            new Property("/^Ice\.Default\.Locator/", false, null),
            new Property("/^Ice\.Default\.LocatorCacheTimeout/", false, null),
            new Property("/^Ice\.Default\.InvocationTimeout/", false, null),
            new Property("/^Ice\.Default\.Package/", false, null),
            new Property("/^Ice\.Default\.PreferSecure/", false, null),
            new Property("/^Ice\.Default\.Protocol/", false, null),
            new Property("/^Ice\.Default\.Router\.EndpointSelection/", false, null),
            new Property("/^Ice\.Default\.Router\.ConnectionCached/", false, null),
            new Property("/^Ice\.Default\.Router\.PreferSecure/", false, null),
            new Property("/^Ice\.Default\.Router\.LocatorCacheTimeout/", false, null),
            new Property("/^Ice\.Default\.Router\.InvocationTimeout/", false, null),
            new Property("/^Ice\.Default\.Router\.Locator/", false, null),
            new Property("/^Ice\.Default\.Router\.Router/", false, null),
            new Property("/^Ice\.Default\.Router\.CollocationOptimized/", false, null),
            new Property("/^Ice\.Default\.Router\.Context\../", false, null),
            new Property("/^Ice\.Default\.Router/", false, null),
            new Property("/^Ice\.Default\.SlicedFormat/", false, null),
            new Property("/^Ice\.Default\.SourceAddress/", false, null),
            new Property("/^Ice\.Default\.Timeout/", false, null),
            new Property("/^Ice\.EventLog\.Source/", false, null),
            new Property("/^Ice\.FactoryAssemblies/", false, null),
            new Property("/^Ice\.HTTPProxyHost/", false, null),
            new Property("/^Ice\.HTTPProxyPort/", false, null),
            new Property("/^Ice\.ImplicitContext/", false, null),
            new Property("/^Ice\.InitPlugins/", false, null),
            new Property("/^Ice\.IPv4/", false, null),
            new Property("/^Ice\.IPv6/", false, null),
            new Property("/^Ice\.LogFile/", false, null),
            new Property("/^Ice\.LogStdErr\.Convert/", false, null),
            new Property("/^Ice\.MessageSizeMax/", false, null),
            new Property("/^Ice\.Nohup/", false, null),
            new Property("/^Ice\.NullHandleAbort/", false, null),
            new Property("/^Ice\.Override\.CloseTimeout/", false, null),
            new Property("/^Ice\.Override\.Compress/", false, null),
            new Property("/^Ice\.Override\.ConnectTimeout/", false, null),
            new Property("/^Ice\.Override\.Timeout/", false, null),
            new Property("/^Ice\.Override\.Secure/", false, null),
            new Property("/^Ice\.Package\../", false, null),
            new Property("/^Ice\.Plugin\../", false, null),
            new Property("/^Ice\.PluginLoadOrder/", false, null),
            new Property("/^Ice\.PreferIPv6Address/", false, null),
            new Property("/^Ice\.PrintAdapterReady/", false, null),
            new Property("/^Ice\.PrintProcessId/", false, null),
            new Property("/^Ice\.PrintStackTraces/", false, null),
            new Property("/^Ice\.ProgramName/", false, null),
            new Property("/^Ice\.RetryIntervals/", false, null),
            new Property("/^Ice\.ServerIdleTime/", false, null),
            new Property("/^Ice\.SOCKSProxyHost/", false, null),
            new Property("/^Ice\.SOCKSProxyPort/", false, null),
            new Property("/^Ice\.StdErr/", false, null),
            new Property("/^Ice\.StdOut/", false, null),
            new Property("/^Ice\.SyslogFacility/", false, null),
            new Property("/^Ice\.ThreadPool\.Client\.Size/", false, null),
            new Property("/^Ice\.ThreadPool\.Client\.SizeMax/", false, null),
            new Property("/^Ice\.ThreadPool\.Client\.SizeWarn/", false, null),
            new Property("/^Ice\.ThreadPool\.Client\.StackSize/", false, null),
            new Property("/^Ice\.ThreadPool\.Client\.Serialize/", false, null),
            new Property("/^Ice\.ThreadPool\.Client\.ThreadIdleTime/", false, null),
            new Property("/^Ice\.ThreadPool\.Client\.ThreadPriority/", false, null),
            new Property("/^Ice\.ThreadPool\.Server\.Size/", false, null),
            new Property("/^Ice\.ThreadPool\.Server\.SizeMax/", false, null),
            new Property("/^Ice\.ThreadPool\.Server\.SizeWarn/", false, null),
            new Property("/^Ice\.ThreadPool\.Server\.StackSize/", false, null),
            new Property("/^Ice\.ThreadPool\.Server\.Serialize/", false, null),
            new Property("/^Ice\.ThreadPool\.Server\.ThreadIdleTime/", false, null),
            new Property("/^Ice\.ThreadPool\.Server\.ThreadPriority/", false, null),
            new Property("/^Ice\.ThreadPriority/", false, null),
            new Property("/^Ice\.Trace\.Admin\.Properties/", false, null),
            new Property("/^Ice\.Trace\.Admin\.Logger/", false, null),
            new Property("/^Ice\.Trace\.Locator/", false, null),
            new Property("/^Ice\.Trace\.Network/", false, null),
            new Property("/^Ice\.Trace\.Protocol/", false, null),
            new Property("/^Ice\.Trace\.Retry/", false, null),
            new Property("/^Ice\.Trace\.Slicing/", false, null),
            new Property("/^Ice\.Trace\.ThreadPool/", false, null),
            new Property("/^Ice\.UDP\.RcvSize/", false, null),
            new Property("/^Ice\.UDP\.SndSize/", false, null),
            new Property("/^Ice\.TCP\.Backlog/", false, null),
            new Property("/^Ice\.TCP\.RcvSize/", false, null),
            new Property("/^Ice\.TCP\.SndSize/", false, null),
            new Property("/^Ice\.UseApplicationClassLoader/", false, null),
            new Property("/^Ice\.UseSyslog/", false, null),
            new Property("/^Ice\.Warn\.AMICallback/", false, null),
            new Property("/^Ice\.Warn\.Connections/", false, null),
            new Property("/^Ice\.Warn\.Datagrams/", false, null),
            new Property("/^Ice\.Warn\.Dispatch/", false, null),
            new Property("/^Ice\.Warn\.Endpoints/", false, null),
            new Property("/^Ice\.Warn\.UnknownProperties/", false, null),
            new Property("/^Ice\.Warn\.UnusedProperties/", false, null),
            new Property("/^Ice\.CacheMessageBuffers/", false, null),
            new Property("/^Ice\.ThreadInterruptSafe/", false, null),
            new Property("/^Ice\.Voip/", false, null),
        ];
        
        /* jshint +W044*/
        
        PropertyNames.validProps =
        [
            PropertyNames.IceProps,
        ];
        
        PropertyNames.clPropNames =
        [
            "Ice",
        ];
        
        Ice.PropertyNames = PropertyNames;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
            
        var HashMap = Ice.HashMap;
        var AlreadyRegisteredException = Ice.AlreadyRegisteredException;
        var NotRegisteredException = Ice.NotRegisteredException;
        
        //
        // Only for use by Instance
        //
        var ObjectFactoryManager = Ice.Class({
            __init__: function()
            {
                this._factoryMap = new HashMap(); // Map<String, ObjectFactory>
            },
            add: function(factory, id)
            {
                var o, ex;
                o = this._factoryMap.get(id);
                if(o !== undefined)
                {
                    ex = new AlreadyRegisteredException();
                    ex.id = id;
                    ex.kindOfObject = "object factory";
                    throw ex;
                }
                this._factoryMap.set(id, factory);
            },
            remove: function(id)
            {
                var factory, ex;
                factory = this._factoryMap.get(id);
                if(factory === undefined)
                {
                    ex = new NotRegisteredException();
                    ex.id = id;
                    ex.kindOfObject = "object factory";
                    throw ex;
                }
                this._factoryMap.del(id);
                factory.destroy();
            },
            find: function(id)
            {
                return this._factoryMap.get(id);
            },
            destroy: function()
            {
                var oldMap = this._factoryMap,
                    e = oldMap.entries;
                this._factoryMap = new HashMap(); // Map<String, ObjectFactory>
        
                while(e !== null)
                {
                    e.value.destroy();
                    e = e.next;
                }
            }
        });
        
        Ice.ObjectFactoryManager = ObjectFactoryManager;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Promise = Ice.Promise;
        
        var AsyncResultBase = Ice.Class(Promise, {
            __init__: function(communicator, op, connection, proxy, adapter)
            {
                //
                // AsyncResultBase can be constructed by a sub-type's prototype, in which case the
                // arguments are undefined.
                //
                Promise.call(this);
                if(communicator !== undefined)
                {
                    this._communicator = communicator;
                    this._instance = communicator !== null ? communicator.instance : null;
                    this._operation = op;
                    this._connection = connection;
                    this._proxy = proxy;
                    this._adapter = adapter;
                }
            }
        });
        
        var prototype = AsyncResultBase.prototype;
        var defineProperty = Object.defineProperty;
        
        defineProperty(prototype, "communicator", {
            get: function() { return this._communicator; }
        });
        
        defineProperty(prototype, "connection", {
            get: function() { return this._connection; }
        });
        
        defineProperty(prototype, "proxy", {
            get: function() { return this._proxy; }
        });
        
        defineProperty(prototype, "adapter", {
            get: function() { return this._adapter; }
        });
        
        defineProperty(prototype, "operation", {
            get: function() { return this._operation; }
        });
        
        Ice.AsyncResultBase = AsyncResultBase;
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Current.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
            Slice.defineDictionary(Ice, "Context", "ContextHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);
        
            /**
             * The {@link OperationMode} determines the retry behavior an
             * invocation in case of a (potentially) recoverable error.
             * 
             **/
            Ice.OperationMode = Slice.defineEnum([
                ['Normal', 0], ['Nonmutating', 1], ['Idempotent', 2]]);
        
            /**
             * Information about the current method invocation for servers. Each
             * operation on the server has a <tt>Current</tt> as its implicit final
             * parameter. <tt>Current</tt> is mostly used for Ice services. Most
             * applications ignore this parameter.
             * 
             **/
            Ice.Current = Slice.defineStruct(
                function(adapter, con, id, facet, operation, mode, ctx, requestId, encoding)
                {
                    this.adapter = adapter !== undefined ? adapter : null;
                    this.con = con !== undefined ? con : null;
                    this.id = id !== undefined ? id : new Ice.Identity();
                    this.facet = facet !== undefined ? facet : "";
                    this.operation = operation !== undefined ? operation : "";
                    this.mode = mode !== undefined ? mode : Ice.OperationMode.Normal;
                    this.ctx = ctx !== undefined ? ctx : null;
                    this.requestId = requestId !== undefined ? requestId : 0;
                    this.encoding = encoding !== undefined ? encoding : new Ice.EncodingVersion();
                },
                false);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        Ice.ObjectFactory = Ice.Class({
            create: function(type)
            {
                throw new Error("not implemented");
            },
            destroy: function()
            {
                throw new Error("not implemented");
            }
        });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var RetryException = Ice.Class(Error, {
            __init__: function(ex)
            {
                if(ex instanceof Ice.LocalException)
                {
                    this._ex = ex;
                }
                else
                {
                    Ice.Debug.assert(ex instanceof RetryException);
                    this._ex = ex._ex;
                }
            }
        });
        
        var prototype = RetryException.prototype;
        
        Object.defineProperty(prototype, "inner", {
            get: function() { return this._ex; }
        });
        
        Ice.RetryException = RetryException;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `EndpointTypes.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * Determines the order in which the Ice run time uses the endpoints
             * in a proxy when establishing a connection.
             * 
             **/
            Ice.EndpointSelectionType = Slice.defineEnum([
                ['Random', 0], ['Ordered', 1]]);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Promise = Ice.Promise;
        var ReferenceMode = Ice.ReferenceMode;
        
        var ConnectionRequestHandler = Ice.Class({
            __init__: function(ref, connection, compress)
            {
                this._reference = ref;
                this._response = ref.getMode() == ReferenceMode.ModeTwoway;
                this._connection = connection;
                this._compress = compress;
            },
            update: function(previousHandler, newHandler)
            {
                try
                {
                    if(previousHandler === this)
                    {
                        return newHandler;
                    }
                    else if(previousHandler.getConnection() === this._connection)
                    {
                        //
                        // If both request handlers point to the same connection, we also
                        // update the request handler. See bug ICE-5489 for reasons why
                        // this can be useful.
                        //
                        return newHandler;
                    }
                }
                catch(ex)
                {
                    // Ignore
                }
                return this;
            },
            sendAsyncRequest: function(out)
            {
                return out.__invokeRemote(this._connection, this._compress, this._response);
            },
            asyncRequestCanceled: function(out)
            {
                return this._connection.asyncRequestCanceled(out);
            },
            getReference: function()
            {
                return this._reference;
            },
            getConnection: function()
            {
                return this._connection;
            },
        });
        
        Ice.ConnectionRequestHandler = ConnectionRequestHandler;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        //
        // Local aliases.
        //
        var Debug = Ice.Debug;
        var HashMap = Ice.HashMap;
        var Protocol = Ice.Protocol;
        var StringUtil = Ice.StringUtil;
        var OperationMode = Ice.OperationMode;
        var Identity = Ice.Identity;
        
        var TraceUtil = {};
        
        TraceUtil.traceSend = function(stream, logger, traceLevels)
        {
            if(traceLevels.protocol >= 1)
            {
                var p = stream.pos;
                stream.pos = 0;
        
                var s = [];
                var type = printMessage(s, stream);
        
                logger.trace(traceLevels.protocolCat, "sending " + getMessageTypeAsString(type) + " " + s.join(""));
        
                stream.pos = p;
            }
        };
        
        TraceUtil.traceRecv = function(stream, logger, traceLevels)
        {
            if(traceLevels.protocol >= 1)
            {
                var p = stream.pos;
                stream.pos = 0;
        
                var s = [];
                var type = printMessage(s, stream);
        
                logger.trace(traceLevels.protocolCat, "received " + getMessageTypeAsString(type) + " " + s.join(""));
        
                stream.pos = p;
            }
        };
        
        TraceUtil.trace = function(heading, stream, logger, traceLevels)
        {
            if(traceLevels.protocol >= 1)
            {
                var p = stream.pos;
                stream.pos = 0;
        
                var s = [];
                s.push(heading);
                printMessage(s, stream);
        
                logger.trace(traceLevels.protocolCat, s.join(""));
                stream.pos = p;
            }
        };
        
        var slicingIds = new HashMap();
        
        function traceSlicing(kind, typeId, slicingCat, logger)
        {
            if(!slicingIds.has(typeId))
            {
                var s = "unknown " + kind + " type `" + typeId + "'";
                logger.trace(slicingCat, s);
                slicingIds.set(typeId, 1);
            }
        }
        
        TraceUtil.dumpStream = function(stream)
        {
            var pos = stream.pos;
            stream.pos = 0;
        
            var data = stream.readBlob(stream.size());
            TraceUtil.dumpOctets(data);
        
            stream.pos = pos;
        };
        
        TraceUtil.dumpOctets = function(data)
        {
            var inc = 8;
            var buf = [];
        
            for(var i = 0; i < data.length; i += inc)
            {
                var j;
                for(j = i; j - i < inc; j++)
                {
                    if(j < data.length)
                    {
                        var n = data[j];
                        if(n < 0)
                        {
                            n += 256;
                        }
                        var s;
                        if(n < 10)
                        {
                            s = "  " + n;
                        }
                        else if(n < 100)
                        {
                            s = " " + n;
                        }
                        else
                        {
                            s = "" + n;
                        }
                        buf.push(s + " ");
                    }
                    else
                    {
                        buf.push("    ");
                    }
                }
        
                buf.push('"');
        
                for(j = i; j < data.length && j - i < inc; j++)
                {
                    if(data[j] >= 32 && data[j] < 127)
                    {
                        buf.push(String.fromCharCode(data[j]));
                    }
                    else
                    {
                        buf.push('.');
                    }
                }
        
                buf.push("\"\n");
            }
        
            Cr.Utils.log(buf.join(""));
        };
        
        Ice.TraceUtil = TraceUtil;
        
        function printIdentityFacetOperation(s, stream)
        {
            var identity = new Identity();
            identity.__read(stream);
            s.push("\nidentity = " + stream.instance.identityToString(identity));
        
            var facet = Ice.StringSeqHelper.read(stream);
            s.push("\nfacet = ");
            if(facet.length > 0)
            {
                s.push(StringUtil.escapeString(facet[0], ""));
            }
        
            var operation = stream.readString();
            s.push("\noperation = " + operation);
        }
        
        function printRequest(s, stream)
        {
            var requestId = stream.readInt();
            s.push("\nrequest id = " + requestId);
            if(requestId === 0)
            {
                s.push(" (oneway)");
            }
        
            printRequestHeader(s, stream);
        }
        
        function printBatchRequest(s, stream)
        {
            var batchRequestNum = stream.readInt();
            s.push("\nnumber of requests = " + batchRequestNum);
        
            for(var i = 0; i < batchRequestNum; ++i)
            {
                s.push("\nrequest #" + i + ':');
                printRequestHeader(s, stream);
            }
        }
        
        function printReply(s, stream)
        {
            var requestId = stream.readInt();
            s.push("\nrequest id = " + requestId);
        
            var replyStatus = stream.readByte();
            s.push("\nreply status = " + replyStatus + ' ');
        
            switch(replyStatus)
            {
            case Protocol.replyOK:
            {
                s.push("(ok)");
                break;
            }
        
            case Protocol.replyUserException:
            {
                s.push("(user exception)");
                break;
            }
        
            case Protocol.replyObjectNotExist:
            case Protocol.replyFacetNotExist:
            case Protocol.replyOperationNotExist:
            {
                switch(replyStatus)
                {
                case Protocol.replyObjectNotExist:
                {
                    s.push("(object not exist)");
                    break;
                }
        
                case Protocol.replyFacetNotExist:
                {
                    s.push("(facet not exist)");
                    break;
                }
        
                case Protocol.replyOperationNotExist:
                {
                    s.push("(operation not exist)");
                    break;
                }
        
                default:
                {
                    Debug.assert(false);
                    break;
                }
                }
        
                printIdentityFacetOperation(s, stream);
                break;
            }
        
            case Protocol.replyUnknownException:
            case Protocol.replyUnknownLocalException:
            case Protocol.replyUnknownUserException:
            {
                switch(replyStatus)
                {
                case Protocol.replyUnknownException:
                {
                    s.push("(unknown exception)");
                    break;
                }
        
                case Protocol.replyUnknownLocalException:
                {
                    s.push("(unknown local exception)");
                    break;
                }
        
                case Protocol.replyUnknownUserException:
                {
                    s.push("(unknown user exception)");
                    break;
                }
        
                default:
                {
                    Debug.assert(false);
                    break;
                }
                }
        
                var unknown = stream.readString();
                s.push("\nunknown = " + unknown);
                break;
            }
        
            default:
            {
                s.push("(unknown)");
                break;
            }
            }
        
            if(replyStatus === Protocol.replyOK || replyStatus === Protocol.replyUserException)
            {
                var ver = stream.skipEncaps();
                if(!ver.equals(Ice.Encoding_1_0))
                {
                    s.push("\nencoding = ");
                    s.push(Ice.encodingVersionToString(ver));
                }
            }
        }
        
        function printRequestHeader(s, stream)
        {
            printIdentityFacetOperation(s, stream);
        
            var mode = stream.readByte();
            s.push("\nmode = " + mode + ' ');
            switch(OperationMode.valueOf(mode))
            {
                case OperationMode.Normal:
                {
                    s.push("(normal)");
                    break;
                }
        
                case OperationMode.Nonmutating:
                {
                    s.push("(nonmutating)");
                    break;
                }
        
                case OperationMode.Idempotent:
                {
                    s.push("(idempotent)");
                    break;
                }
        
                default:
                {
                    s.push("(unknown)");
                    break;
                }
            }
        
            var sz = stream.readSize();
            s.push("\ncontext = ");
            while(sz-- > 0)
            {
                var key = stream.readString();
                var value = stream.readString();
                s.push(key + '/'+ value);
                if(sz > 0)
                {
                    s.push(", ");
                }
            }
        
            var ver = stream.skipEncaps();
            if(!ver.equals(Ice.Encoding_1_0))
            {
                s.push("\nencoding = ");
                s.push(Ice.encodingVersionToString(ver));
            }
        }
        
        function printHeader(s, stream)
        {
            stream.readByte();  // Don't bother printing the magic number
            stream.readByte();
            stream.readByte();
            stream.readByte();
        
        //        var pMajor = stream.readByte();
        //        var pMinor = stream.readByte();
        //        s.push("\nprotocol version = " + pMajor + "." + pMinor);
            stream.readByte(); // major
            stream.readByte(); // minor
        
        //        var eMajor = stream.readByte();
        //        var eMinor = stream.readByte();
        //        s.push("\nencoding version = " + eMajor + "." + eMinor);
            stream.readByte(); // major
            stream.readByte(); // minor
        
            var type = stream.readByte();
        
            s.push("\nmessage type = " + type + " (" + getMessageTypeAsString(type) + ')');
            var compress = stream.readByte();
            s.push("\ncompression status = " + compress + ' ');
            switch(compress)
            {
                case 0:
                {
                    s.push("(not compressed; do not compress response, if any)");
                    break;
                }
        
                case 1:
                {
                    s.push("(not compressed; compress response, if any)");
                    break;
                }
        
                case 2:
                {
                    s.push("(compressed; compress response, if any)");
                    break;
                }
        
                default:
                {
                    s.push("(unknown)");
                    break;
                }
            }
        
            var size = stream.readInt();
            s.push("\nmessage size = " + size);
            return type;
        }
        
        function printMessage(s, stream)
        {
            var type = printHeader(s, stream);
        
            switch(type)
            {
            case Protocol.closeConnectionMsg:
            case Protocol.validateConnectionMsg:
            {
                // We're done.
                break;
            }
        
            case Protocol.requestMsg:
            {
                printRequest(s, stream);
                break;
            }
        
            case Protocol.requestBatchMsg:
            {
                printBatchRequest(s, stream);
                break;
            }
        
            case Protocol.replyMsg:
            {
                printReply(s, stream);
                break;
            }
        
            default:
            {
                break;
            }
            }
        
            return type;
        }
        
        function getMessageTypeAsString(type)
        {
            switch(type)
            {
            case Protocol.requestMsg:
                return "request";
            case Protocol.requestBatchMsg:
                return "batch request";
            case Protocol.replyMsg:
                return "reply";
            case Protocol.closeConnectionMsg:
                return "close connection";
            case Protocol.validateConnectionMsg:
                return  "validate connection";
            default:
                return "unknown";
            }
        }
        
    }());

    (function()
    {
        
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        var Logger = Ice.Logger;
        
        var processLogger = null;
        
        Ice.getProcessLogger = function()
        {
            if(processLogger === null)
            {
                //
                // TODO: Would be nice to be able to use process name as prefix by default.
                //
                processLogger = new Logger("", "");
            }
        
            return processLogger;
        };
        
        Ice.setProcessLogger = function(logger)
        {
            processLogger = logger;
        };
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        //
        // Local aliases.
        //
        var UnexpectedObjectException = Ice.UnexpectedObjectException;
        var MemoryLimitException = Ice.MemoryLimitException;
        
        //
        // Exception utilities
        //
        
        Ice.ExUtil =
        {
            throwUOE: function(expectedType, v)
            {
                var type = v.ice_id();
                throw new UnexpectedObjectException("expected element of type `" + expectedType + "' but received '" +
                                                    type, type, expectedType);
            },
            throwMemoryLimitException: function(requested, maximum)
            {
                throw new MemoryLimitException("requested " + requested + " bytes, maximum allowed is " + maximum +
                                               " bytes (see Ice.MessageSizeMax)");
            }
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        
        var StringUtil = Ice.StringUtil;
        var HashMap = Ice.HashMap;
        var Promise = Ice.Promise;
        var PropertyNames = Ice.PropertyNames;
        var Debug = Ice.Debug;
        var ProcessLogger = Ice.ProcessLogger;
        var getProcessLogger = Ice.getProcessLogger;
        var InitializationException = Ice.InitializationException;
        
        var ParseStateKey = 0;
        var ParseStateValue = 1;
        //
        // Ice.Properties
        //
        var Properties = Ice.Class({
            __init__: function(args, defaults)
            {
                this._properties = new HashMap();
        
                if(defaults !== undefined && defaults !== null)
                {
                    //
                    // NOTE: we can't just do a shallow copy of the map as the map values
                    // would otherwise be shared between the two PropertiesI object.
                    //
                    //_properties = new HashMap(pi._properties);
                    for(var e = defaults._properties.entries; e !== null; e = e.next)
                    {
                        this._properties.set(e.key, { 'value': e.value.value, 'used': false });
                    }
                }
        
                if(args !== undefined && args !== null)
                {
                    var v = this.parseIceCommandLineOptions(args);
                    args.length = 0;
                    for(var i = 0; i < v.length; ++i)
                    {
                        args.push(v[i]);
                    }
                }
            },
            getProperty: function(key)
            {
                return this.getPropertyWithDefault(key, "");
            },
            getPropertyWithDefault: function(key, value)
            {
                var pv = this._properties.get(key);
                if(pv !== undefined)
                {
                    pv.used = true;
                    return pv.value;
                }
                else
                {
                    return value;
                }
            },
            getPropertyAsInt: function(key)
            {
                return this.getPropertyAsIntWithDefault(key, 0);
            },
            getPropertyAsIntWithDefault: function(key, value)
            {
                var pv = this._properties.get(key);
                if(pv !== undefined)
                {
                    pv.used = true;
                    return parseInt(pv.value);
                }
                else
                {
                    return value;
                }
            },
            getPropertyAsList: function(key)
            {
                return this.getPropertyAsListWithDefault(key, 0);
            },
            getPropertyAsListWithDefault: function(key, value)
            {
                if(value === undefined || value === null)
                {
                    value = [];
                }
        
                var pv = this._properties.get(key);
                if(pv !== undefined)
                {
                    pv.used = true;
        
                    var result = StringUtil.splitString(pv.value, ", \t\r\n");
                    if(result === null)
                    {
                        getProcessLogger().warning("mismatched quotes in property " + key + "'s value, returning default value");
                        return value;
                    }
                    if(result.length === 0)
                    {
                        result = value;
                    }
                    return result;
                }
                else
                {
                    return value;
                }
            },
            getPropertiesForPrefix: function(prefix)
            {
                var result = new HashMap();
                for(var e = this._properties.entries; e !== null; e = e.next)
                {
                    if(prefix === undefined || prefix === null || e.key.indexOf(prefix) === 0)
                    {
                        e.value.used = true;
                        result.set(e.key, e.value.value);
                    }
                }
                return result;
            },
            setProperty: function(key, value)
            {
                //
                // Trim whitespace
                //
                if(key !== null && key !== undefined)
                {
                    key = key.trim();
                }
        
                //
                // Check if the property is legal.
                //
                var logger = getProcessLogger();
                if(key === null || key === undefined || key.length === 0)
                {
                    throw new InitializationException("Attempt to set property with empty key");
                }
        
                var dotPos = key.indexOf(".");
                if(dotPos !== -1)
                {
                    var prefix = key.substr(0, dotPos);
                    for(var i = 0; i < PropertyNames.validProps.length; ++i)
                    {
                        var pattern = PropertyNames.validProps[i][0].pattern;
                        dotPos = pattern.indexOf(".");
                        //
                        // Each top level prefix describes a non-empty namespace. Having a string without a
                        // prefix followed by a dot is an error.
                        //
                        Debug.assert(dotPos != -1);
                        var propPrefix = pattern.substring(0, dotPos - 1);
                        if(propPrefix != prefix)
                        {
                            continue;
                        }
                        
                        var found = false;
                        var mismatchCase = false;
                        var otherKey;
                        for(var j = 0; j < PropertyNames.validProps[i][j].length && !found; ++j)
                        {
                            pattern = PropertyNames.validProps[i][j].pattern();
                            var pComp = new RegExp(pattern);
                            found = pComp.test(key);
        
                            if(found && PropertyNames.validProps[i][j].deprecated)
                            {
                                logger.warning("deprecated property: " + key);
                                if(PropertyNames.validProps[i][j].deprecatedBy !== null)
                                {
                                    key = PropertyNames.validProps[i][j].deprecatedBy;
                                }
                            }
                            
                            if(found)
                            {
                                break;
                            }
                            else
                            {
                                pComp = new RegExp(pattern.toUpperCase());
                                found = pComp.test(key.toUpperCase());
                                if(found)
                                {
                                    mismatchCase = true;
                                    otherKey = pattern.substr(2);
                                    otherKey = otherKey.substr(0, otherKey.length -1);
                                    otherKey = otherKey.replace(/\\/g, "");
                                    break;
                                }
                            }
                        }
                        
                        if(!found)
                        {
                            logger.warning("unknown property: " + key);
                        }
                        else if(mismatchCase)
                        {
                            logger.warning("unknown property: `" + key + "'; did you mean `" + otherKey + "'");
                        }
                    }
                }
        
                //
                // Set or clear the property.
                //
                if(value !== undefined && value !== null && value.length > 0)
                {
                    var pv = this._properties.get(key);
                    if(pv !== undefined)
                    {
                        pv.value = value;
                    }
                    else
                    {
                        this._properties.set(key, { 'value': value, 'used': false });
                    }
                }
                else
                {
                    this._properties.del(key);
                }
            },
            getCommandLineOptions: function()
            {
                var result = [];
                for(var e = this._properties.entries; e !== null; e = e.next)
                {
                    result.push("--" + e.key + "=" + e.pv.value);
                }
                return result;
            },
            parseCommandLineOptions: function(pfx, options)
            {
                if(pfx.length > 0 && pfx.charAt(pfx.length - 1) != ".")
                {
                    pfx += ".";
                }
                pfx = "--" + pfx;
        
                var result = [];
                
                var self = this;
                options.forEach(
                    function(opt)
                    {
                        if(opt.indexOf(pfx) === 0)
                        {
                            if(opt.indexOf('=') === -1)
                            {
                                opt += "=1";
                            }
        
                            self.parseLine(opt.substring(2));
                        }
                        else
                        {
                            result.push(opt);
                        }
                    });
                return result;
            },
            parseIceCommandLineOptions: function(options)
            {
                var args = options.slice();
                for(var i = 0; i < PropertyNames.clPropNames.length; ++i)
                {
                    args = this.parseCommandLineOptions(PropertyNames.clPropNames[i], args);
                }
                return args;
            },
            parse: function(data)
            {
                var lines = data.match(/[^\r\n]+/g);
                
                var line;
                
                while((line = lines.shift()))
                {
                    this.parseLine(line);
                }
            },
            parseLine: function(line)
            {
                var key = "";
                var value = "";
        
                var state = ParseStateKey;
        
                var whitespace = "";
                var escapedspace = "";
                var finished = false;
                
                for(var i = 0; i < line.length; ++i)
                {
                    var c = line.charAt(i);
                    switch(state)
                    {
                        case ParseStateKey:
                        {
                            switch(c)
                            {
                                case '\\':
                                    if(i < line.length - 1)
                                    {
                                        c = line.charAt(++i);
                                        switch(c)
                                        {
                                            case '\\':
                                            case '#':
                                            case '=':
                                                key += whitespace;
                                                whitespace = "";
                                                key += c;
                                                break;
        
                                            case ' ':
                                                if(key.length !== 0)
                                                {
                                                    whitespace += c;
                                                }
                                                break;
        
                                            default:
                                                key += whitespace;
                                                whitespace = "";
                                                key += '\\';
                                                key += c;
                                                break;
                                        }
                                    }
                                    else
                                    {
                                        key += whitespace;
                                        key += c;
                                    }
                                    break;
        
                                case ' ':
                                case '\t':
                                case '\r':
                                case '\n':
                                    if(key.length !== 0)
                                    {
                                        whitespace += c;
                                    }
                                    break;
        
                                case '=':
                                    whitespace = "";
                                    state = ParseStateValue;
                                    break;
        
                                case '#':
                                    finished = true;
                                    break;
        
                                default:
                                    key += whitespace;
                                    whitespace = "";
                                    key += c;
                                    break;
                            }
                            break;
                        }
        
                        case ParseStateValue:
                        {
                            switch(c)
                            {
                                case '\\':
                                    if(i < line.length - 1)
                                    {
                                        c = line.charAt(++i);
                                        switch(c)
                                        {
                                            case '\\':
                                            case '#':
                                            case '=':
                                                value += value.length === 0 ? escapedspace : whitespace;
                                                whitespace = "";
                                                escapedspace = "";
                                                value += c;
                                                break;
        
                                            case ' ':
                                                whitespace += c;
                                                escapedspace += c;
                                                break;
        
                                            default:
                                                value += value.length === 0 ? escapedspace : whitespace;
                                                whitespace = "";
                                                escapedspace = "";
                                                value += '\\';
                                                value += c;
                                                break;
                                        }
                                    }
                                    else
                                    {
                                        value += value.length === 0 ? escapedspace : whitespace;
                                        value += c;
                                    }
                                    break;
        
                                case ' ':
                                case '\t':
                                case '\r':
                                case '\n':
                                    if(value.length !== 0)
                                    {
                                        whitespace += c;
                                    }
                                    break;
        
                                case '#':
                                    finished = true;
                                    break;
        
                                default:
                                    value += value.length === 0 ? escapedspace : whitespace;
                                    whitespace = "";
                                    escapedspace = "";
                                    value += c;
                                    break;
                            }
                            break;
                        }
                    }
                    if(finished)
                    {
                        break;
                    }
                }
                value += escapedspace;
        
                if((state === ParseStateKey && key.length !== 0) ||
                (state == ParseStateValue && key.length === 0))
                {
                    getProcessLogger().warning("invalid config file entry: \"" + line + "\"");
                    return;
                }
                else if(key.length === 0)
                {
                    return;
                }
                
                this.setProperty(key, value);
            },
            clone: function()
            {
                return new Properties(null, this);
            },
            getUnusedProperties: function()
            {
                var unused = [];
                for(var e = this._properties.entries; e !== null; e = e.next)
                {
                    if(!e.pv.used)
                    {
                        unused.push(e.key);
                    }
                }
                return unused;
            }
        });
        
        Properties.createProperties = function(args, defaults)
        {
            return new Properties(args, defaults);
        };
        
        Ice.Properties = Properties;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Debug = Ice.Debug;
        var HashMap = Ice.HashMap;
        var StringUtil = Ice.StringUtil;
        
        //
        // Only for use by Ice.ObjectAdatperI.
        //
        var ServantManager = Ice.Class({
            __init__: function(instance, adapterName)
            {
                this._instance = instance;
                this._adapterName = adapterName;
                this._servantMapMap = new HashMap(HashMap.compareEquals);        // Map<Ice.Identity, Map<String, Ice.Object> >
                this._defaultServantMap = new HashMap();    // Map<String, Ice.Object>
                this._locatorMap = new HashMap();           // Map<String, Ice.ServantLocator>
            },
            addServant: function(servant, ident, facet)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                if(facet === null)
                {
                    facet = "";
                }
        
                var m = this._servantMapMap.get(ident);
                if(m === undefined)
                {
                    m = new HashMap();
                    this._servantMapMap.set(ident, m);
                }
                else
                {
                    if(m.has(facet))
                    {
                        var ex = new Ice.AlreadyRegisteredException();
                        ex.id = this._instance.identityToString(ident);
                        ex.kindOfObject = "servant";
                        if(facet.length > 0)
                        {
                            ex.id += " -f " + StringUtil.escapeString(facet, "");
                        }
                        throw ex;
                    }
                }
        
                m.set(facet, servant);
            },
            addDefaultServant: function(servant, category)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction
        
                var obj = this._defaultServantMap.get(category);
                if(obj !== undefined)
                {
                    var ex = new Ice.AlreadyRegisteredException();
                    ex.kindOfObject = "default servant";
                    ex.id = category;
                    throw ex;
                }
        
                this._defaultServantMap.set(category, servant);
            },
            removeServant: function(ident, facet)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                if(facet === null)
                {
                    facet = "";
                }
        
                var m = this._servantMapMap.get(ident);
                if(m === undefined || !m.has(facet))
                {
                    var ex = new Ice.NotRegisteredException();
                    ex.id = this._instance.identityToString(ident);
                    ex.kindOfObject = "servant";
                    if(facet.length > 0)
                    {
                        ex.id += " -f " + StringUtil.escapeString(facet, "");
                    }
                    throw ex;
                }
        
                var obj = m.get(facet);
                m.del(facet);
        
                if(m.size === 0)
                {
                    this._servantMapMap.del(ident);
                }
        
                return obj;
            },
            removeDefaultServant: function(category)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                var obj = this._defaultServantMap.get(category);
                if(obj === undefined)
                {
                    var ex = new Ice.NotRegisteredException();
                    ex.kindOfObject = "default servant";
                    ex.id = category;
                    throw ex;
                }
        
                this._defaultServantMap.del(category);
                return obj;
            },
            removeAllFacets: function(ident)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                var m = this._servantMapMap.get(ident);
                if(m === undefined)
                {
                    var ex = new Ice.NotRegisteredException();
                    ex.id = this._instance.identityToString(ident);
                    ex.kindOfObject = "servant";
                    throw ex;
                }
        
                this._servantMapMap.del(ident);
        
                return m;
            },
            findServant: function(ident, facet)
            {
                //
                // This assert is not valid if the adapter dispatch incoming
                // requests from bidir connections. This method might be called if
                // requests are received over the bidir connection after the
                // adapter was deactivated.
                //
                //Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                if(facet === null)
                {
                    facet = "";
                }
        
                var m = this._servantMapMap.get(ident);
                var obj = null;
                if(m === undefined)
                {
                    obj = this._defaultServantMap.get(ident.category);
                    if(obj === undefined)
                    {
                        obj = this._defaultServantMap.get("");
                    }
                }
                else
                {
                    obj = m.get(facet);
                }
        
                return obj === undefined ? null : obj;
            },
            findDefaultServant: function(category)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                var ds = this._defaultServantMap.get(category);
                return ds === undefined ? null : ds;
            },
            findAllFacets: function(ident)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                var m = this._servantMapMap.get(ident);
                if(m !== undefined)
                {
                    return m.clone();
                }
        
                return new HashMap();
            },
            hasServant: function(ident)
            {
                //
                // This assert is not valid if the adapter dispatch incoming
                // requests from bidir connections. This method might be called if
                // requests are received over the bidir connection after the
                // adapter was deactivated.
                //
                //Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                var m = this._servantMapMap.get(ident);
                if(m === undefined)
                {
                    return false;
                }
                else
                {
                    Debug.assert(m.size > 0);
                    return true;
                }
            },
            addServantLocator: function(locator, category)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                var l = this._locatorMap.get(category);
                if(l !== undefined)
                {
                    var ex = new Ice.AlreadyRegisteredException();
                    ex.id = StringUtil.escapeString(category, "");
                    ex.kindOfObject = "servant locator";
                    throw ex;
                }
        
                this._locatorMap.set(category, locator);
            },
            removeServantLocator: function(category)
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                var l = this._locatorMap.get(category);
                if(l === undefined)
                {
                    var ex = new Ice.NotRegisteredException();
                    ex.id = StringUtil.escapeString(category, "");
                    ex.kindOfObject = "servant locator";
                    throw ex;
                }
                this._locatorMap.del(category);
                return l;
            },
            findServantLocator: function(category)
            {
                //
                // This assert is not valid if the adapter dispatch incoming
                // requests from bidir connections. This method might be called if
                // requests are received over the bidir connection after the
                // adapter was deactivated.
                //
                //Debug.assert(this._instance !== null); // Must not be called after destruction.
        
                var l = this._locatorMap.get(category);
                return l === undefined ? null : l;
            },
            //
            // Only for use by Ice.ObjectAdapterI.
            //
            destroy: function()
            {
                Debug.assert(this._instance !== null); // Must not be called after destruction.
                var logger = this._instance.initializationData().logger;
                this._servantMapMap.clear();
        
                this._defaultServantMap.clear();
        
                var locatorMap = this._locatorMap.clone();
                this._locatorMap.clear();
                this._instance = null;
        
                for(var e = locatorMap.entries; e !== null; e = e.next)
                {
                    var locator = e.value;
                    try
                    {
                        locator.deactivate(e.key);
                    }
                    catch(ex)
                    {
                        var s = "exception during locator deactivation:\n" + "object adapter: `" + this._adapterName +
                            "'\n" + "locator category: `" + e.key + "'\n" + ex.toString();
                        logger.error(s);
                    }
                }
            }
        });
        
        Ice.ServantManager = ServantManager;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        var __M = Ice.__M;
        
        var Debug = Ice.Debug;
        var ExUtil = Ice.ExUtil;
        var FormatType = Ice.FormatType;
        var HashMap = Ice.HashMap;
        var IceObject = Ice.Object;
        var OptionalFormat = Ice.OptionalFormat;
        var Protocol = Ice.Protocol;
        var TraceUtil = Ice.TraceUtil;
        var ArrayUtil = Ice.ArrayUtil;
        var SlicedData = Ice.SlicedData;
        
        var SliceType = {};
        SliceType.NoSlice = 0;
        SliceType.ObjectSlice = 1;
        SliceType.ExceptionSlice = 2;
        
        var OPTIONAL_END_MARKER           = 0xFF;
        var FLAG_HAS_TYPE_ID_STRING       = (1<<0);
        var FLAG_HAS_TYPE_ID_INDEX        = (1<<1);
        var FLAG_HAS_TYPE_ID_COMPACT      = (1<<1 | 1<<0);
        var FLAG_HAS_OPTIONAL_MEMBERS     = (1<<2);
        var FLAG_HAS_INDIRECTION_TABLE    = (1<<3);
        var FLAG_HAS_SLICE_SIZE           = (1<<4);
        var FLAG_IS_LAST_SLICE            = (1<<5);
        
        //
        // Number.isNaN polyfill for compatibility with IE
        //
        // see: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
        //
        Number.isNaN = Number.isNaN || function(value)
        {
            return typeof value === "number" && isNaN(value);
        };
        
        var IndirectPatchEntry = function(index, patcher)
        {
            this.index = index;
            this.patcher = patcher;
        };
        
        var Class = Ice.Class;
        
        var EncapsDecoder = Class({
            __init__: function(stream, encaps, sliceObjects, f)
            {
                this._stream = stream;
                this._encaps = encaps;
                this._sliceObjects = sliceObjects;
                this._servantFactoryManager = f;
                this._patchMap = null; // Lazy initialized, HashMap<int, Patcher[] >()
                this._unmarshaledMap = new HashMap(); // HashMap<int, Ice.Object>()
                this._typeIdMap = null; // Lazy initialized, HashMap<int, String>
                this._typeIdIndex = 0;
                this._objectList = null; // Lazy initialized. Ice.Object[]
            },
            readOpt: function()
            {
                return false;
            },
            readPendingObjects: function()
            {
            },
            readTypeId: function(isIndex)
            {
                var typeId, index;
                if(this._typeIdMap === null) // Lazy initialization
                {
                    this._typeIdMap = new HashMap(); // Map<int, String>();
                }
        
                if(isIndex)
                {
                    index = this._stream.readSize();
                    typeId = this._typeIdMap.get(index);
                    if(typeId === undefined)
                    {
                        throw new Ice.UnmarshalOutOfBoundsException();
                    }
                }
                else
                {
                    typeId = this._stream.readString();
                    this._typeIdMap.set(++this._typeIdIndex, typeId);
                }
                return typeId;
            },
            newInstance: function(typeId)
            {
                //
                // Try to find a factory registered for the specific type.
                //
                var userFactory = this._servantFactoryManager.find(typeId);
                var v = null;
        
                if(userFactory !== undefined)
                {
                    v = userFactory.create(typeId);
                }
        
                //
                // If that fails, invoke the default factory if one has been
                // registered.
                //
                if(v === null || v === undefined)
                {
                    userFactory = this._servantFactoryManager.find("");
                    if(userFactory !== undefined)
                    {
                        v = userFactory.create(typeId);
                    }
                }
        
                //
                // Last chance: try to instantiate the class dynamically.
                //
                if(v === null || v === undefined)
                {
                    v = this._stream.createObject(typeId);
                }
        
                return v;
            },
            addPatchEntry: function(index, patcher)
            {
                Debug.assert(index > 0);
                //
                // Check if already un-marshalled the object. If that's the case,
                // just patch the object smart pointer and we're done.
                //
                var obj = this._unmarshaledMap.get(index);
                if(obj !== undefined && obj !== null)
                {
                    patcher.call(null, obj);
                    return;
                }
        
                if(this._patchMap === null) // Lazy initialization
                {
                    this._patchMap = new HashMap(); // HashMap<Integer, Patcher[] >();
                }
        
                //
                // Add patch entry if the object isn't un-marshalled yet,
                // the smart pointer will be patched when the instance is
                // un-marshalled.
                //
                var l = this._patchMap.get(index);
                if(l === undefined)
                {
                    //
                    // We have no outstanding instances to be patched for this
                    // index, so make a new entry in the patch map.
                    //
                    l = []; // Patcher[];
                    this._patchMap.set(index, l);
                }
        
                //
                // Append a patch entry for this instance.
                //
                l.push(patcher);
            },
            unmarshal: function(index, v)
            {
                var i, length, l;
                //
                // Add the object to the map of un-marshalled objects, this must
                // be done before reading the objects (for circular references).
                //
                this._unmarshaledMap.set(index, v);
        
                //
                // Read the object.
                //
                v.__read(this._stream);
                if(this._patchMap !== null)
                {
                    //
                    // Patch all instances now that the object is un-marshalled.
                    //
                    l = this._patchMap.get(index);
                    if(l !== undefined)
                    {
                        Debug.assert(l.length > 0);
                        //
                        // Patch all pointers that refer to the instance.
                        //
                        for(i = 0, length = l.length; i < length; ++i)
                        {
                            l[i](v);
                        }
                        //
                        // Clear out the patch map for that index -- there is nothing left
                        // to patch for that index for the time being.
                        //
                        this._patchMap.del(index);
                    }
                }
        
                if((this._patchMap === null || this._patchMap.size === 0) && this._objectList === null)
                {
                    try
                    {
                        v.ice_postUnmarshal();
                    }
                    catch(ex)
                    {
                        this._stream.instance.initializationData().logger.warning("exception raised by ice_postUnmarshal:\n" +
        									  ex.toString());
                    }
                }
                else
                {
                    if(this._objectList === null) // Lazy initialization
                    {
                        this._objectList = []; // Ice.Object[]
                    }
                    this._objectList.push(v);
        
                    if(this._patchMap === null || this._patchMap.size === 0)
                    {
                        //
                        // Iterate over the object list and invoke ice_postUnmarshal on
                        // each object.  We must do this after all objects have been
                        // unmarshaled in order to ensure that any object data members
                        // have been properly patched.
                        //
                        for(i = 0, length = this._objectList.length; i < length; i++)
                        {
                            try
                            {
                                this._objectList[i].ice_postUnmarshal();
                            }
                            catch(ex)
                            {
                                this._stream.instance.initializationData().logger.warning(
                                                                    "exception raised by ice_postUnmarshal:\n" + ex.toString());
                            }
                        }
                        this._objectList = [];
                    }
                }
            }
        });
        
        var EncapsDecoder10 = Class(EncapsDecoder, {
            __init__: function(stream, encaps, sliceObjects, f)
            {
                EncapsDecoder.call(this, stream, encaps, sliceObjects, f);
                this._sliceType = SliceType.NoSlice;
            },
            readObject: function(patcher)
            {
                Debug.assert(patcher !== null);
        
                //
                // Object references are encoded as a negative integer in 1.0.
                //
                var index = this._stream.readInt();
                if(index > 0)
                {
                    throw new Ice.MarshalException("invalid object id");
                }
                index = -index;
        
                if(index === 0)
                {
                    patcher.call(null, null);
                }
                else
                {
                    this.addPatchEntry(index, patcher);
                }
            },
            throwException: function()
            {
                Debug.assert(this._sliceType === SliceType.NoSlice);
        
                //
                // User exception with the 1.0 encoding start with a boolean flag
                // that indicates whether or not the exception has classes.
                //
                // This allows reading the pending objects even if some part of
                // the exception was sliced.
                //
                var usesClasses = this._stream.readBool();
                this._sliceType = SliceType.ExceptionSlice;
                this._skipFirstSlice = false;
        
                //
                // Read the first slice header.
                //
                this.startSlice();
                var mostDerivedId = this._typeId;
                while(true)
                {
                    var userEx = this._stream.createUserException(this._typeId);
        
                    //
                    // We found the exception.
                    //
                    if(userEx !== null)
                    {
                        userEx.__read(this._stream);
                        if(usesClasses)
                        {
                            this.readPendingObjects();
                        }
                        throw userEx;
        
                        // Never reached.
                    }
        
                    //
                    // Slice off what we don't understand.
                    //
                    this.skipSlice();
                    try
                    {
                        this.startSlice();
                    }
                    catch(ex)
                    {
                        //
                        // An oversight in the 1.0 encoding means there is no marker to indicate
                        // the last slice of an exception. As a result, we just try to read the
                        // next type ID, which raises UnmarshalOutOfBoundsException when the
                        // input buffer underflows.
                        //
                        // Set the reason member to a more helpful message.
                        //
                        if(ex instanceof Ice.UnmarshalOutOfBoundsException)
                        {
                            ex.reason = "unknown exception type `" + mostDerivedId + "'";
                        }
                        throw ex;
                    }
                }
            },
            startInstance: function(sliceType)
            {
                Debug.assert(this._sliceType === sliceType);
                this._skipFirstSlice = true;
            },
            endInstance: function(/*preserve*/)
            {
                var sz;
                //
                // Read the Ice::Object slice.
                //
                if(this._sliceType === SliceType.ObjectSlice)
                {
                    this.startSlice();
                    sz = this._stream.readSize(); // For compatibility with the old AFM.
                    if(sz !== 0)
                    {
                        throw new Ice.MarshalException("invalid Object slice");
                    }
                    this.endSlice();
                }
        
                this._sliceType = SliceType.NoSlice;
                return null;
            },
            startSlice: function()
            {
                var isIndex;
                //
                // If first slice, don't read the header, it was already read in
                // readInstance or throwException to find the factory.
                //
                if(this._skipFirstSlice)
                {
                    this._skipFirstSlice = false;
                    return this._typeId;
                }
        
                //
                // For objects, first read the type ID boolean which indicates
                // whether or not the type ID is encoded as a string or as an
                // index. For exceptions, the type ID is always encoded as a
                // string.
                //
                if(this._sliceType === SliceType.ObjectSlice) // For exceptions, the type ID is always encoded as a string
                {
                    isIndex = this._stream.readBool();
                    this._typeId = this.readTypeId(isIndex);
                }
                else
                {
                    this._typeId = this._stream.readString();
                }
        
                this._sliceSize = this._stream.readInt();
                if(this._sliceSize < 4)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
        
                return this._typeId;
            },
            endSlice: function()
            {
            },
            skipSlice: function()
            {
                if(this._stream.instance.traceLevels().slicing > 0)
                {
                    var logger = this._stream.instance.initializationData().logger;
                    if(this._sliceType === SliceType.ObjectSlice)
                    {
                        TraceUtil.traceSlicing("object", this._typeId, this._stream.instance.traceLevels().slicingCat, logger);
                    }
                    else
                    {
                        TraceUtil.traceSlicing("exception", this._typeId, this._stream.instance.traceLevels().slicingCat, logger);
                    }
                }
                Debug.assert(this._sliceSize >= 4);
                this._stream.skip(this._sliceSize - 4);
            },
            readPendingObjects: function()
            {
                var k, num;
                do
                {
                    num = this._stream.readSize();
                    for(k = num; k > 0; --k)
                    {
                        this.readInstance();
                    }
                }
                while(num > 0);
        
                if(this._patchMap !== null && this._patchMap.size !== 0)
                {
                    //
                    // If any entries remain in the patch map, the sender has sent an index for an object, but failed
                    // to supply the object.
                    //
                    throw new Ice.MarshalException("index for class received, but no instance");
                }
            },
            readInstance: function()
            {
                var index = this._stream.readInt(),
                    mostDerivedId,
                    v = null;
        
                if(index <= 0)
                {
                    throw new Ice.MarshalException("invalid object id");
                }
        
                this._sliceType = SliceType.ObjectSlice;
                this._skipFirstSlice = false;
        
                //
                // Read the first slice header.
                //
                this.startSlice();
                mostDerivedId = this._typeId;
                while(true)
                {
                    //
                    // For the 1.0 encoding, the type ID for the base Object class
                    // marks the last slice.
                    //
                    if(this._typeId == IceObject.ice_staticId())
                    {
                        throw new Ice.NoObjectFactoryException("", mostDerivedId);
                    }
        
                    v = this.newInstance(this._typeId);
        
                    //
                    // We found a factory, we get out of this loop.
                    //
                    if(v)
                    {
                        break;
                    }
        
                    //
                    // If object slicing is disabled, stop un-marshalling.
                    //
                    if(!this._sliceObjects)
                    {
                        throw new Ice.NoObjectFactoryException("no object factory found and object slicing is disabled",
                                                               this._typeId);
                    }
        
                    //
                    // Slice off what we don't understand.
                    //
                    this.skipSlice();
                    this.startSlice(); // Read next Slice header for next iteration.
                }
        
                //
                // Un-marshal the object and add-it to the map of un-marshaled objects.
                //
                this.unmarshal(index, v);
            }
        });
        
        var EncapsDecoder11 = Class(EncapsDecoder, {
            __init__: function(stream, encaps, sliceObjects, f)
            {
                EncapsDecoder.call(this, stream, encaps, sliceObjects, f);
                this._current = null;
                this._objectIdIndex = 1;
            },
            readObject: function(patcher)
            {
                Debug.assert(patcher !== undefined);
                var index = this._stream.readSize();
        
                if(index < 0)
                {
                    throw new Ice.MarshalException("invalid object id");
                }
        
                if(index === 0)
                {
                    if(patcher !== null)
                    {
                        patcher.call(null, null);
                    }
                }
                else if(this._current !== null && (this._current.sliceFlags & FLAG_HAS_INDIRECTION_TABLE) !== 0)
                {
                    //
                    // When reading an object within a slice and there's an
                    // indirect object table, always read an indirect reference
                    // that points to an object from the indirect object table
                    // marshaled at the end of the Slice.
                    //
                    // Maintain a list of indirect references. Note that the
                    // indirect index starts at 1, so we decrement it by one to
                    // derive an index into the indirection table that we'll read
                    // at the end of the slice.
                    //
                    if(patcher !== null)
                    {
                        if(this._current.indirectPatchList === null) // Lazy initialization
                        {
                            this._current.indirectPatchList = []; // IndirectPatchEntry[]
                        }
                        var e = new IndirectPatchEntry();
                        e.index = index - 1;
                        e.patcher = patcher;
                        this._current.indirectPatchList.push(e);
                    }
                }
                else
                {
                    this.readInstance(index, patcher);
                }
            },
            throwException: function()
            {
                Debug.assert(this._current === null);
                this.push(SliceType.ExceptionSlice);
        
                //
                // Read the first slice header.
                //
                this.startSlice();
                var mostDerivedId = this._current.typeId;
                while(true)
                {
        
                    var userEx = this._stream.createUserException(this._current.typeId);
        
                    //
                    // We found the exception.
                    //
                    if(userEx !== null)
                    {
                        userEx.__read(this._stream);
                        throw userEx;
        
                        // Never reached.
                    }
        
                    //
                    // Slice off what we don't understand.
                    //
                    this.skipSlice();
        
                    if((this._current.sliceFlags & FLAG_IS_LAST_SLICE) !== 0)
                    {
                        if(mostDerivedId.indexOf("::") === 0)
                        {
                            throw new Ice.UnknownUserException(mostDerivedId.substr(2));
                        }
                        throw new Ice.UnknownUserException(mostDerivedId);
                    }
        
                    this.startSlice();
                }
            },
            startInstance: function(sliceType)
            {
                Debug.assert(sliceType !== undefined);
                Debug.assert(this._current.sliceType !== null && this._current.sliceType === sliceType);
                this._current.skipFirstSlice = true;
            },
            endInstance: function(preserve)
            {
                var slicedData = null;
                if(preserve)
                {
                    slicedData = this.readSlicedData();
                }
                if(this._current.slices !== null)
                {
                    this._current.slices.length = 0; // Clear the array.
                    this._current.indirectionTables.length = 0; // Clear the array.
                }
                this._current = this._current.previous;
                return slicedData;
            },
            startSlice: function()
            {
                //
                // If first slice, don't read the header, it was already read in
                // readInstance or throwException to find the factory.
                //
                if(this._current.skipFirstSlice)
                {
                    this._current.skipFirstSlice = false;
                    return this._current.typeId;
                }
        
                this._current.sliceFlags = this._stream.readByte();
        
                //
                // Read the type ID, for object slices the type ID is encoded as a
                // string or as an index, for exceptions it's always encoded as a
                // string.
                //
                if(this._current.sliceType === SliceType.ObjectSlice)
                {
                    if((this._current.sliceFlags & FLAG_HAS_TYPE_ID_COMPACT) === FLAG_HAS_TYPE_ID_COMPACT) // Must be checked 1st!
                    {
                        this._current.typeId = "";
                        this._current.compactId = this._stream.readSize();
                    }
                    else if((this._current.sliceFlags & (FLAG_HAS_TYPE_ID_INDEX | FLAG_HAS_TYPE_ID_STRING)) !== 0)
                    {
                        this._current.typeId = this.readTypeId((this._current.sliceFlags & FLAG_HAS_TYPE_ID_INDEX) !== 0);
                        this._current.compactId = -1;
                    }
                    else
                    {
                        // Only the most derived slice encodes the type ID for the compact format.
                        this._current.typeId = "";
                        this._current.compactId = -1;
                    }
                }
                else
                {
                    this._current.typeId = this._stream.readString();
                    this._current.compactId = -1;
                }
        
                //
                // Read the slice size if necessary.
                //
                if((this._current.sliceFlags & FLAG_HAS_SLICE_SIZE) !== 0)
                {
                    this._current.sliceSize = this._stream.readInt();
                    if(this._current.sliceSize < 4)
                    {
                        throw new Ice.UnmarshalOutOfBoundsException();
                    }
                }
                else
                {
                    this._current.sliceSize = 0;
                }
                return this._current.typeId;
            },
            endSlice: function()
            {
                var e,
                    i,
                    indirectionTable = [],
                    length;
        
                if((this._current.sliceFlags & FLAG_HAS_OPTIONAL_MEMBERS) !== 0)
                {
                    this._stream.skipOpts();
                }
        
                //
                // Read the indirection table if one is present and transform the
                // indirect patch list into patch entries with direct references.
                //
                if((this._current.sliceFlags & FLAG_HAS_INDIRECTION_TABLE) !== 0)
                {
                    //
                    // The table is written as a sequence<size> to conserve space.
                    //
                    length = this._stream.readAndCheckSeqSize(1);
                    for(i = 0; i < length; ++i)
                    {
                        indirectionTable[i] = this.readInstance(this._stream.readSize(), null);
                    }
        
                    //
                    // Sanity checks. If there are optional members, it's possible
                    // that not all object references were read if they are from
                    // unknown optional data members.
                    //
                    if(indirectionTable.length === 0)
                    {
                        throw new Ice.MarshalException("empty indirection table");
                    }
                    if((this._current.indirectPatchList === null || this._current.indirectPatchList.length === 0) &&
                    (this._current.sliceFlags & FLAG_HAS_OPTIONAL_MEMBERS) === 0)
                    {
                        throw new Ice.MarshalException("no references to indirection table");
                    }
        
                    //
                    // Convert indirect references into direct references.
                    //
                    if(this._current.indirectPatchList !== null)
                    {
                        for(i = 0, length = this._current.indirectPatchList.length; i < length; ++i)
                        {
                            e = this._current.indirectPatchList[i];
                            Debug.assert(e.index >= 0);
                            if(e.index >= indirectionTable.length)
                            {
                                throw new Ice.MarshalException("indirection out of range");
                            }
                            this.addPatchEntry(indirectionTable[e.index], e.patcher);
                        }
                        this._current.indirectPatchList.length = 0;
                    }
                }
            },
            skipSlice: function()
            {
                if(this._stream.instance.traceLevels().slicing > 0)
                {
                    var logger = this._stream.instance.initializationData().logger;
                    var slicingCat = this._stream.instance.traceLevels().slicingCat;
                    if(this._current.sliceType === SliceType.ExceptionSlice)
                    {
                        TraceUtil.traceSlicing("exception", this._current.typeId, slicingCat, logger);
                    }
                    else
                    {
                        TraceUtil.traceSlicing("object", this._current.typeId, slicingCat, logger);
                    }
                }
        
                var start = this._stream.pos;
        
                if((this._current.sliceFlags & FLAG_HAS_SLICE_SIZE) !== 0)
                {
                    Debug.assert(this._current.sliceSize >= 4);
                    this._stream.skip(this._current.sliceSize - 4);
                }
                else
                {
                    if(this._current.sliceType === SliceType.ObjectSlice)
                    {
                        throw new Ice.NoObjectFactoryException("no object factory found and compact format prevents slicing " +
                                                               "(the sender should use the sliced format instead)",
                                                               this._current.typeId);
                    }
        
                    if(this._current.typeId.indexOf("::") === 0)
                    {
                        throw new Ice.UnknownUserException(this._current.typeId.substring(2));
                    }
        
                    throw new Ice.UnknownUserException(this._current.typeId);
                }
        
                //
                // Preserve this slice.
                //
                var info = new Ice.SliceInfo();
                info.typeId = this._current.typeId;
                info.compactId = this._current.compactId;
                info.hasOptionalMembers = (this._current.sliceFlags & FLAG_HAS_OPTIONAL_MEMBERS) !== 0;
                info.isLastSlice = (this._current.sliceFlags & FLAG_IS_LAST_SLICE) !== 0;
        
                var b = this._stream._buf;
                var end = b.position;
                var dataEnd = end;
                if(info.hasOptionalMembers)
                {
                    //
                    // Don't include the optional member end marker. It will be re-written by
                    // endSlice when the sliced data is re-written.
                    //
                    --dataEnd;
                }
        
                b.position = start;
                info.bytes = b.getArray(dataEnd - start);
                b.position = end;
        
                if(this._current.slices === null) // Lazy initialization
                {
                    this._current.slices = []; // Ice.SliceInfo[]
                    this._current.indirectionTables = []; // int[]
                }
        
                //
                // Read the indirect object table. We read the instances or their
                // IDs if the instance is a reference to an already un-marhsaled
                // object.
                //
                // The SliceInfo object sequence is initialized only if
                // readSlicedData is called.
                //
        
                if((this._current.sliceFlags & FLAG_HAS_INDIRECTION_TABLE) !== 0)
                {
                    var length = this._stream.readAndCheckSeqSize(1);
                    var indirectionTable = [];
                    for(var i = 0; i < length; ++i)
                    {
                        indirectionTable[i] = this.readInstance(this._stream.readSize(), null);
                    }
                    this._current.indirectionTables.push(indirectionTable);
                }
                else
                {
                    this._current.indirectionTables.push(null);
                }
                this._current.slices.push(info);
            },
            readOpt: function(readTag, expectedFormat)
            {
                if(this._current === null)
                {
                    return this._stream.readOptImpl(readTag, expectedFormat);
                }
        
                if((this._current.sliceFlags & FLAG_HAS_OPTIONAL_MEMBERS) !== 0)
                {
                    return this._stream.readOptImpl(readTag, expectedFormat);
                }
                return false;
            },
            readInstance: function(index, patcher)
            {
                Debug.assert(index > 0);
        
                var mostDerivedId,
                    v = null;
        
                if(index > 1)
                {
                    if(patcher !== null)
                    {
                        this.addPatchEntry(index, patcher);
                    }
                    return index;
                }
        
                this.push(SliceType.ObjectSlice);
        
                //
                // Get the object ID before we start reading slices. If some
                // slices are skiped, the indirect object table are still read and
                // might read other objects.
                //
                index = ++this._objectIdIndex;
        
                //
                // Read the first slice header.
                //
                this.startSlice();
                mostDerivedId = this._current.typeId;
                while(true)
                {
                    if(this._current.compactId >= 0)
                    {
                        //
                        // Translate a compact (numeric) type ID into a string type ID.
                        //
                        this._current.typeId = "";
                        if(this._current.typeId.length === 0)
                        {
                            this._current.typeId = this._stream.getTypeId(this._current.compactId);
                        }
                    }
        
                    if(this._current.typeId.length > 0)
                    {
                        v = this.newInstance(this._current.typeId);
                        //
                        // We found a factory, we get out of this loop.
                        //
                        if(v !== null && v !== undefined)
                        {
                            break;
                        }
                    }
        
                    //
                    // If object slicing is disabled, stop un-marshalling.
                    //
                    if(!this._sliceObjects)
                    {
                        throw new Ice.NoObjectFactoryException("no object factory found and object slicing is disabled",
                                                               this._current.typeId);
                    }
        
                    //
                    // Slice off what we don't understand.
                    //
                    this.skipSlice();
                    //
                    // If this is the last slice, keep the object as an opaque
                    // UnknownSlicedData object.
                    //
                    if((this._current.sliceFlags & FLAG_IS_LAST_SLICE) !== 0)
                    {
                        v = new Ice.UnknownSlicedObject(mostDerivedId);
                        break;
                    }
        
                    this.startSlice(); // Read next Slice header for next iteration.
                }
        
                //
                // Un-marshal the object
                //
                this.unmarshal(index, v);
                if(this._current === null && this._patchMap !== null && this._patchMap.size !== 0)
                {
                    //
                    // If any entries remain in the patch map, the sender has sent an index for an object, but failed
                    // to supply the object.
                    //
                    throw new Ice.MarshalException("index for class received, but no instance");
                }
        
                if(patcher !== null)
                {
                    patcher.call(null, v);
                }
                return index;
            },
            readSlicedData: function()
            {
                var i, ii, table, info, j, jj;
        
                if(this._current.slices === null) // No preserved slices.
                {
                    return null;
                }
                //
                // The _indirectionTables member holds the indirection table for each slice
                // in _slices.
                //
                Debug.assert(this._current.slices.length === this._current.indirectionTables.length);
                for(i = 0, ii = this._current.slices.length; i < ii; ++i)
                {
                    //
                    // We use the "objects" list in SliceInfo to hold references
                    // to the target objects. Note that the objects might not have
                    // been read yet in the case of a circular reference to an
                    // enclosing object.
                    //
                    table = this._current.indirectionTables[i];
                    info = this._current.slices[i];
                    info.objects = [];
                    jj = table ? table.length : 0;
                    for(j = 0; j < jj; ++j)
                    {
                        this.addPatchEntry(table[j], sequencePatcher(info.objects, j, IceObject));
                    }
                }
                return new SlicedData(ArrayUtil.clone(this._current.slices));
            },
            push: function(sliceType)
            {
                if(this._current === null)
                {
                    this._current = new EncapsDecoder11.InstanceData(null);
                }
                else
                {
                    this._current = !this._current.next ? new EncapsDecoder11.InstanceData(this._current) : this._current.next;
                }
                this._current.sliceType = sliceType;
                this._current.skipFirstSlice = false;
            }
        });
        
        EncapsDecoder11.InstanceData = function(previous)
        {
            if(previous !== null)
            {
                previous.next = this;
            }
            this.previous = previous;
            this.next = null;
        
            // Instance attributes
            this.sliceType = null;
            this.skipFirstSlice = false;
            this.slices = null;     // Preserved slices. Ice.SliceInfo[]
            this.indirectionTables = null; // int[]
        
            // Slice attributes
            this.sliceFlags = 0;
            this.sliceSize = 0;
            this.typeId = null;
            this.compactId = 0;
            this.indirectPatchList = null; // Lazy initialized, IndirectPatchEntry[]
        };
        
        var sequencePatcher = function(seq, index, T){
            return function(v)
                {
                    if(v !== null && !(v instanceof T))
                    {
                        ExUtil.throwUOE(T.ice_staticId(), v);
                    }
                    seq[index] = v;
                };
        };
        
        var EncapsEncoder = Class({
            __init__: function(stream, encaps)
            {
                this._stream = stream;
                this._encaps = encaps;
                this._marshaledMap = new HashMap(); // HashMap<Ice.Object, int>;
                this._typeIdMap = null; // Lazy initialized. HashMap<String, int>
                this._typeIdIndex = 0;
            },
            writeOpt: function()
            {
                return false;
            },
            writePendingObjects: function()
            {
                return undefined;
            },
            registerTypeId: function(typeId)
            {
                if(this._typeIdMap === null) // Lazy initialization
                {
                    this._typeIdMap = new HashMap(); // HashMap<String, int>
                }
        
                var p = this._typeIdMap.get(typeId);
                if(p !== undefined)
                {
                    return p;
                }
                this._typeIdMap.set(typeId, ++this._typeIdIndex);
                return -1;
            }
        });
        
        var EncapsEncoder10 = Class(EncapsEncoder, {
            __init__: function(stream, encaps)
            {
                EncapsEncoder.call(this, stream, encaps);
                // Instance attributes
                this._sliceType = SliceType.NoSlice;
                this._writeSlice = 0;        // Position of the slice data members
                // Encapsulation attributes for object marshalling.
                this._objectIdIndex = 0;
                this._toBeMarshaledMap = new HashMap(); // HashMap<Ice.Object, Integer>();
            },
            writeObject: function(v)
            {
                Debug.assert(v !== undefined);
                //
                // Object references are encoded as a negative integer in 1.0.
                //
                if(v !== null)
                {
                    this._stream.writeInt(-this.registerObject(v));
                }
                else
                {
                    this._stream.writeInt(0);
                }
            },
            writeUserException: function(v)
            {
                Debug.assert(v !== null && v !== undefined);
                //
                // User exception with the 1.0 encoding start with a boolean
                // flag that indicates whether or not the exception uses
                // classes.
                //
                // This allows reading the pending objects even if some part of
                // the exception was sliced.
                //
                var usesClasses = v.__usesClasses();
                this._stream.writeBool(usesClasses);
                v.__write(this._stream);
                if(usesClasses)
                {
                    this.writePendingObjects();
                }
            },
            startInstance: function(sliceType)
            {
                this._sliceType = sliceType;
            },
            endInstance: function()
            {
                if(this._sliceType === SliceType.ObjectSlice)
                {
                    //
                    // Write the Object slice.
                    //
                    this.startSlice(IceObject.ice_staticId(), -1, true);
                    this._stream.writeSize(0); // For compatibility with the old AFM.
                    this.endSlice();
                }
                this._sliceType = SliceType.NoSlice;
            },
            startSlice: function(typeId)
            {
                //
                // For object slices, encode a boolean to indicate how the type ID
                // is encoded and the type ID either as a string or index. For
                // exception slices, always encode the type ID as a string.
                //
                if(this._sliceType === SliceType.ObjectSlice)
                {
                    var index = this.registerTypeId(typeId);
                    if(index < 0)
                    {
                        this._stream.writeBool(false);
                        this._stream.writeString(typeId);
                    }
                    else
                    {
                        this._stream.writeBool(true);
                        this._stream.writeSize(index);
                    }
                }
                else
                {
                    this._stream.writeString(typeId);
                }
        
                this._stream.writeInt(0); // Placeholder for the slice length.
        
                this._writeSlice = this._stream.pos;
            },
            endSlice: function()
            {
                //
                // Write the slice length.
                //
                var sz = this._stream.pos - this._writeSlice + 4;
                this._stream.rewriteInt(sz, this._writeSlice - 4);
            },
            writePendingObjects: function()
            {
                var self = this,
                    writeCB = function(key, value)
                                {
                                    //
                                    // Ask the instance to marshal itself. Any new class
                                    // instances that are triggered by the classes marshaled
                                    // are added to toBeMarshaledMap.
                                    //
                                    self._stream.writeInt(value);
        
                                    try
                                    {
                                        key.ice_preMarshal();
                                    }
                                    catch(ex)
                                    {
                                        self._stream.instance.initializationData().logger.warning(
                                            "exception raised by ice_preMarshal:\n" + ex.toString());
                                    }
        
                                    key.__write(self._stream);
                                },
                    savedMap;
        
                while(this._toBeMarshaledMap.size > 0)
                {
                    //
                    // Consider the to be marshalled objects as marshalled now,
                    // this is necessary to avoid adding again the "to be
                    // marshalled objects" into _toBeMarshaledMap while writing
                    // objects.
                    //
                    this._marshaledMap.merge(this._toBeMarshaledMap);
        
                    savedMap = this._toBeMarshaledMap;
                    this._toBeMarshaledMap = new HashMap(); // HashMap<Ice.Object, int>();
                    this._stream.writeSize(savedMap.size);
                    savedMap.forEach(writeCB);
                }
                this._stream.writeSize(0); // Zero marker indicates end of sequence of sequences of instances.
            },
            registerObject: function(v)
            {
                Debug.assert(v !== null);
        
                //
                // Look for this instance in the to-be-marshaled map.
                //
                var p = this._toBeMarshaledMap.get(v);
                if(p !== undefined)
                {
                    return p;
                }
        
                //
                // Didn't find it, try the marshaled map next.
                //
                p = this._marshaledMap.get(v);
                if(p !== undefined)
                {
                    return p;
                }
        
                //
                // We haven't seen this instance previously, create a new
                // index, and insert it into the to-be-marshaled map.
                //
                this._toBeMarshaledMap.set(v, ++this._objectIdIndex);
                return this._objectIdIndex;
            }
        });
        
        var EncapsEncoder11 = Class(EncapsEncoder, {
            __init__: function(stream, encaps)
            {
                EncapsEncoder.call(this, stream, encaps);
                this._current = null;
                this._objectIdIndex = 1;
            },
            writeObject: function(v)
            {
                Debug.assert(v !== undefined);
                var index, idx;
                if(v === null)
                {
                    this._stream.writeSize(0);
                }
                else if(this._current !== null && this._encaps.format === FormatType.SlicedFormat)
                {
                    if(this._current.indirectionTable === null) // Lazy initialization
                    {
                        this._current.indirectionTable = []; // Ice.Object[]
                        this._current.indirectionMap = new HashMap(); // HashMap<Ice.Object, int>
                    }
        
                    //
                    // If writting an object within a slice and using the sliced
                    // format, write an index from the object indirection
                    // table. The indirect object table is encoded at the end of
                    // each slice and is always read (even if the Slice is
                    // unknown).
                    //
                    index = this._current.indirectionMap.get(v);
                    if(index === undefined)
                    {
                        this._current.indirectionTable.push(v);
                        idx = this._current.indirectionTable.length; // Position + 1 (0 is reserved for nil)
                        this._current.indirectionMap.set(v, idx);
                        this._stream.writeSize(idx);
                    }
                    else
                    {
                        this._stream.writeSize(index);
                    }
                }
                else
                {
                    this.writeInstance(v); // Write the instance or a reference if already marshaled.
                }
            },
            writePendingObjects: function()
            {
                return undefined;
            },
            writeUserException: function(v)
            {
                Debug.assert(v !== null && v !== undefined);
                v.__write(this._stream);
            },
            startInstance: function(sliceType, data)
            {
                if(this._current === null)
                {
                    this._current = new EncapsEncoder11.InstanceData(null);
                }
                else
                {
                    this._current = (this._current.next === null) ? new EncapsEncoder11.InstanceData(this._current) : this._current.next;
                }
                this._current.sliceType = sliceType;
                this._current.firstSlice = true;
        
                if(data !== null && data !== undefined)
                {
                    this.writeSlicedData(data);
                }
            },
            endInstance: function()
            {
                this._current = this._current.previous;
            },
            startSlice: function(typeId, compactId, last)
            {
                Debug.assert((this._current.indirectionTable === null || this._current.indirectionTable.length === 0) &&
                                (this._current.indirectionMap === null || this._current.indirectionMap.size === 0));
        
                this._current.sliceFlagsPos = this._stream.pos;
        
                this._current.sliceFlags = 0;
                if(this._encaps.format === FormatType.SlicedFormat)
                {
                    this._current.sliceFlags |= FLAG_HAS_SLICE_SIZE; // Encode the slice size if using the sliced format.
                }
                if(last)
                {
                    this._current.sliceFlags |= FLAG_IS_LAST_SLICE; // This is the last slice.
                }
        
                this._stream.writeByte(0); // Placeholder for the slice flags
        
                //
                // For object slices, encode the flag and the type ID either as a
                // string or index. For exception slices, always encode the type
                // ID a string.
                //
                if(this._current.sliceType === SliceType.ObjectSlice)
                {
                    //
                    // Encode the type ID (only in the first slice for the compact
                    // encoding).
                    //
                    if(this._encaps.format === FormatType.SlicedFormat || this._current.firstSlice)
                    {
                        if(compactId >= 0)
                        {
                            this._current.sliceFlags |= FLAG_HAS_TYPE_ID_COMPACT;
                            this._stream.writeSize(compactId);
                        }
                        else
                        {
                            var index = this.registerTypeId(typeId);
                            if(index < 0)
                            {
                                this._current.sliceFlags |= FLAG_HAS_TYPE_ID_STRING;
                                this._stream.writeString(typeId);
                            }
                            else
                            {
                                this._current.sliceFlags |= FLAG_HAS_TYPE_ID_INDEX;
                                this._stream.writeSize(index);
                            }
                        }
                    }
                }
                else
                {
                    this._stream.writeString(typeId);
                }
        
                if((this._current.sliceFlags & FLAG_HAS_SLICE_SIZE) !== 0)
                {
                    this._stream.writeInt(0); // Placeholder for the slice length.
                }
        
                this._current.writeSlice = this._stream.pos;
                this._current.firstSlice = false;
            },
            endSlice: function()
            {
                var sz, i, length;
        
                //
                // Write the optional member end marker if some optional members
                // were encoded. Note that the optional members are encoded before
                // the indirection table and are included in the slice size.
                //
                if((this._current.sliceFlags & FLAG_HAS_OPTIONAL_MEMBERS) !== 0)
                {
                    this._stream.writeByte(OPTIONAL_END_MARKER);
                }
        
                //
                // Write the slice length if necessary.
                //
                if((this._current.sliceFlags & FLAG_HAS_SLICE_SIZE) !== 0)
                {
                    sz = this._stream.pos - this._current.writeSlice + 4;
                    this._stream.rewriteInt(sz, this._current.writeSlice - 4);
                }
        
                //
                // Only write the indirection table if it contains entries.
                //
                if(this._current.indirectionTable !== null && this._current.indirectionTable.length !== 0)
                {
                    Debug.assert(this._encaps.format === FormatType.SlicedFormat);
                    this._current.sliceFlags |= FLAG_HAS_INDIRECTION_TABLE;
        
                    //
                    // Write the indirection object table.
                    //
                    this._stream.writeSize(this._current.indirectionTable.length);
                    for(i = 0, length = this._current.indirectionTable.length; i < length; ++i)
                    {
                        this.writeInstance(this._current.indirectionTable[i]);
                    }
                    this._current.indirectionTable.length = 0; // Faster way to clean array in JavaScript
                    this._current.indirectionMap.clear();
                }
        
                //
                // Finally, update the slice flags.
                //
                this._stream.rewriteByte(this._current.sliceFlags, this._current.sliceFlagsPos);
            },
            writeOpt: function(tag, format)
            {
                if(this._current === null)
                {
                    return this._stream.writeOptImpl(tag, format);
                }
        
                if(this._stream.writeOptImpl(tag, format))
                {
                    this._current.sliceFlags |= FLAG_HAS_OPTIONAL_MEMBERS;
                    return true;
                }
        
                return false;
            },
            writeSlicedData: function(slicedData)
            {
                Debug.assert(slicedData !== null && slicedData !== undefined);
        
                //
                // We only remarshal preserved slices if we are using the sliced
                // format. Otherwise, we ignore the preserved slices, which
                // essentially "slices" the object into the most-derived type
                // known by the sender.
                //
                if(this._encaps.format !== FormatType.SlicedFormat)
                {
                    return;
                }
        
                var i, ii, info,
                    j, jj;
        
                for(i = 0, ii = slicedData.slices.length; i < ii; ++i)
                {
                    info = slicedData.slices[i];
                    this.startSlice(info.typeId, info.compactId, info.isLastSlice);
        
                    //
                    // Write the bytes associated with this slice.
                    //
                    this._stream.writeBlob(info.bytes);
        
                    if(info.hasOptionalMembers)
                    {
                        this._current.sliceFlags |= FLAG_HAS_OPTIONAL_MEMBERS;
                    }
        
                    //
                    // Make sure to also re-write the object indirection table.
                    //
                    if(info.objects !== null && info.objects.length > 0)
                    {
                        if(this._current.indirectionTable === null) // Lazy initialization
                        {
                            this._current.indirectionTable = []; // Ice.Object[]
                            this._current.indirectionMap = new HashMap(); // HashMap<Ice.Object, int>
                        }
        
                        for(j = 0, jj = info.objects.length; j < jj; ++j)
                        {
                            this._current.indirectionTable.push(info.objects[j]);
                        }
                    }
        
                    this.endSlice();
                }
            },
            writeInstance: function(v)
            {
                Debug.assert(v !== null && v !== undefined);
        
                //
                // If the instance was already marshaled, just write it's ID.
                //
                var p = this._marshaledMap.get(v);
                if(p !== undefined)
                {
                    this._stream.writeSize(p);
                    return;
                }
        
                //
                // We haven't seen this instance previously, create a new ID,
                // insert it into the marshaled map, and write the instance.
                //
                this._marshaledMap.set(v, ++this._objectIdIndex);
        
                try
                {
                    v.ice_preMarshal();
                }
                catch(ex)
                {
                    this._stream.instance.initializationData().logger.warning("exception raised by ice_preMarshal:\n" +
                                                                              ex.toString());
                }
        
                this._stream.writeSize(1); // Object instance marker.
                v.__write(this._stream);
            }
        });
        
        EncapsEncoder11.InstanceData = function(previous)
        {
            Debug.assert(previous !== undefined);
            if(previous !== null)
            {
                previous.next = this;
            }
            this.previous = previous;
            this.next = null;
        
            // Instance attributes
            this.sliceType = null;
            this.firstSlice = false;
        
            // Slice attributes
            this.sliceFlags = 0;
            this.writeSlice = 0;    // Position of the slice data members
            this.sliceFlagsPos = 0; // Position of the slice flags
            this.indirectionTable = null; // Ice.Object[]
            this.indirectionMap = null; // HashMap<Ice.Object, int>
        };
        
        var ReadEncaps = Class({
            __init__: function()
            {
                this.start = 0;
                this.sz = 0;
                this.encoding = null;
                this.encoding_1_0 = false;
                this.decoder = null;
                this.next = null;
            },
            reset: function()
            {
                this.decoder = null;
            },
            setEncoding: function(encoding)
            {
                this.encoding = encoding;
                this.encoding_1_0 = encoding.equals(Ice.Encoding_1_0);
            }
        });
        
        var WriteEncaps = Class({
            __init__: function()
            {
                this.start = 0;
                this.format = FormatType.DefaultFormat;
                this.encoding = null;
                this.encoding_1_0 = false;
                this.encoder = null;
                this.next = null;
            },
            reset: function()
            {
                this.encoder = null;
            },
            setEncoding: function(encoding)
            {
                this.encoding = encoding;
                this.encoding_1_0 = encoding.equals(Ice.Encoding_1_0);
            }
        });
        
        var BasicStream = Class({
            __init__: function(instance, encoding, data)
            {
                this._instance = instance;
                this._closure = null;
                this._encoding = encoding;
        
                this._readEncapsStack = null;
                this._writeEncapsStack = null;
                this._readEncapsCache = null;
                this._writeEncapsCache = null;
        
                this._sliceObjects = true;
        
                this._startSeq = -1;
                this._sizePos = -1;
        
                if(data !== undefined)
                {
                    this._buf = new Ice.Buffer(data);
                }
                else
                {
                    this._buf = new Ice.Buffer();
                }
            },
            //
            // This function allows this object to be reused, rather than
            // reallocated.
            //
            reset: function()
            {
                this._buf.reset();
                this.clear();
            },
            clear: function()
            {
                if(this._readEncapsStack !== null)
                {
                    Debug.assert(this._readEncapsStack.next);
                    this._readEncapsStack.next = this._readEncapsCache;
                    this._readEncapsCache = this._readEncapsStack;
                    this._readEncapsCache.reset();
                    this._readEncapsStack = null;
                }
        
                if(this._writeEncapsStack !== null)
                {
                    Debug.assert(this._writeEncapsStack.next);
                    this._writeEncapsStack.next = this._writeEncapsCache;
                    this._writeEncapsCache = this._writeEncapsStack;
                    this._writeEncapsCache.reset();
                    this._writeEncapsStack = null;
                }
                this._startSeq = -1;
                this._sliceObjects = true;
            },
            swap: function(other)
            {
                Debug.assert(this._instance === other._instance);
        
                var tmpBuf, tmpClosure, tmpStartSeq, tmpMinSeqSize, tmpSizePos;
        
                tmpBuf = other._buf;
                other._buf = this._buf;
                this._buf = tmpBuf;
        
                tmpClosure = other._closure;
                other._closure = this._closure;
                this._closure = tmpClosure;
        
                //
                // Swap is never called for BasicStreams that have encapsulations being read/write. However,
                // encapsulations might still be set in case marshalling or un-marshalling failed. We just
                // reset the encapsulations if there are still some set.
                //
                this.resetEncaps();
                other.resetEncaps();
        
                tmpStartSeq = other._startSeq;
                other._startSeq = this._startSeq;
                this._startSeq = tmpStartSeq;
        
                tmpMinSeqSize = other._minSeqSize;
                other._minSeqSize = this._minSeqSize;
                this._minSeqSize = tmpMinSeqSize;
        
                tmpSizePos = other._sizePos;
                other._sizePos = this._sizePos;
                this._sizePos = tmpSizePos;
            },
            resetEncaps: function()
            {
                this._readEncapsStack = null;
                this._writeEncapsStack = null;
            },
            resize: function(sz)
            {
                this._buf.resize(sz);
                this._buf.position = sz;
            },
            prepareWrite: function()
            {
                this._buf.position = 0;
                return this._buf;
            },
            startWriteObject: function(data)
            {
                Debug.assert(this._writeEncapsStack !== null && this._writeEncapsStack.encoder !== null);
                this._writeEncapsStack.encoder.startInstance(SliceType.ObjectSlice, data);
            },
            endWriteObject: function()
            {
                Debug.assert(this._writeEncapsStack !== null && this._writeEncapsStack.encoder !== null);
                this._writeEncapsStack.encoder.endInstance();
            },
            startReadObject: function()
            {
                Debug.assert(this._readEncapsStack !== null && this._readEncapsStack.decoder !== null);
                this._readEncapsStack.decoder.startInstance(SliceType.ObjectSlice);
            },
            endReadObject: function(preserve)
            {
                Debug.assert(this._readEncapsStack !== null && this._readEncapsStack.decoder !== null);
                return this._readEncapsStack.decoder.endInstance(preserve);
            },
            startWriteException: function(data)
            {
                Debug.assert(this._writeEncapsStack !== null && this._writeEncapsStack.encoder !== null);
                this._writeEncapsStack.encoder.startInstance(SliceType.ExceptionSlice, data);
            },
            endWriteException: function()
            {
                Debug.assert(this._writeEncapsStack !== null && this._writeEncapsStack.encoder !== null);
                this._writeEncapsStack.encoder.endInstance();
            },
            startReadException: function()
            {
                Debug.assert(this._readEncapsStack !== null && this._readEncapsStack.decoder !== null);
                this._readEncapsStack.decoder.startInstance(SliceType.ExceptionSlice);
            },
            endReadException: function(preserve)
            {
                Debug.assert(this._readEncapsStack !== null && this._readEncapsStack.decoder !== null);
                return this._readEncapsStack.decoder.endInstance(preserve);
            },
            startWriteEncaps: function(encoding, format)
            {
                //
                // If no encoding version is specified, use the current write
                // encapsulation encoding version if there's a current write
                // encapsulation, otherwise, use the stream encoding version.
                //
        
                if(encoding === undefined)
                {
                    if(this._writeEncapsStack !== null)
                    {
                        encoding = this._writeEncapsStack.encoding;
                        format = this._writeEncapsStack.format;
                    }
                    else
                    {
                        encoding = this._encoding;
                        format = FormatType.DefaultFormat;
                    }
                }
        
                Protocol.checkSupportedEncoding(encoding);
        
                var curr = this._writeEncapsCache;
                if(curr !== null)
                {
                    curr.reset();
                    this._writeEncapsCache = this._writeEncapsCache.next;
                }
                else
                {
                    curr = new WriteEncaps();
                }
                curr.next = this._writeEncapsStack;
                this._writeEncapsStack = curr;
        
                this._writeEncapsStack.format = format;
                this._writeEncapsStack.setEncoding(encoding);
                this._writeEncapsStack.start = this._buf.limit;
        
                this.writeInt(0); // Placeholder for the encapsulation length.
                this._writeEncapsStack.encoding.__write(this);
            },
            endWriteEncaps: function()
            {
                Debug.assert(this._writeEncapsStack);
        
                // Size includes size and version.
                var start = this._writeEncapsStack.start;
        
                var sz = this._buf.limit - start;
                this._buf.putIntAt(start, sz);
        
                var curr = this._writeEncapsStack;
                this._writeEncapsStack = curr.next;
                curr.next = this._writeEncapsCache;
                this._writeEncapsCache = curr;
                this._writeEncapsCache.reset();
            },
            endWriteEncapsChecked: function() // Used by public stream API.
            {
                if(this._writeEncapsStack === null)
                {
                    throw new Ice.EncapsulationException("not in an encapsulation");
                }
                this.endWriteEncaps();
            },
            writeEmptyEncaps: function(encoding)
            {
                Protocol.checkSupportedEncoding(encoding);
                this.writeInt(6); // Size
                encoding.__write(this);
            },
            writeEncaps: function(v)
            {
                if(v.length < 6)
                {
                    throw new Ice.EncapsulationException();
                }
                this.expand(v.length);
                this._buf.putArray(v);
            },
            getWriteEncoding: function()
            {
                return this._writeEncapsStack !== null ? this._writeEncapsStack.encoding : this._encoding;
            },
            startReadEncaps: function()
            {
                var curr = this._readEncapsCache;
                if(curr !== null)
                {
                    curr.reset();
                    this._readEncapsCache = this._readEncapsCache.next;
                }
                else
                {
                    curr = new ReadEncaps();
                }
                curr.next = this._readEncapsStack;
                this._readEncapsStack = curr;
        
                this._readEncapsStack.start = this._buf.position;
        
                //
                // I don't use readSize() and writeSize() for encapsulations,
                // because when creating an encapsulation, I must know in advance
                // how many bytes the size information will require in the data
                // stream. If I use an Int, it is always 4 bytes. For
                // readSize()/writeSize(), it could be 1 or 5 bytes.
                //
                var sz = this.readInt();
                if(sz < 6)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
                if(sz - 4 > this._buf.remaining)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
                this._readEncapsStack.sz = sz;
        
                var encoding = new Ice.EncodingVersion();
                encoding.__read(this);
                Protocol.checkSupportedEncoding(encoding); // Make sure the encoding is supported.
                this._readEncapsStack.setEncoding(encoding);
        
                return encoding;
            },
            endReadEncaps: function()
            {
                Debug.assert(this._readEncapsStack !== null);
        
                if(!this._readEncapsStack.encoding_1_0)
                {
                    this.skipOpts();
                    if(this._buf.position !== this._readEncapsStack.start + this._readEncapsStack.sz)
                    {
                        throw new Ice.EncapsulationException();
                    }
                }
                else if(this._buf.position !== this._readEncapsStack.start + this._readEncapsStack.sz)
                {
                    if(this._buf.position + 1 !== this._readEncapsStack.start + this._readEncapsStack.sz)
                    {
                        throw new Ice.EncapsulationException();
                    }
        
                    //
                    // Ice version < 3.3 had a bug where user exceptions with
                    // class members could be encoded with a trailing byte
                    // when dispatched with AMD. So we tolerate an extra byte
                    // in the encapsulation.
                    //
        
                    try
                    {
                        this._buf.get();
                    }
                    catch(ex)
                    {
                        throw new Ice.UnmarshalOutOfBoundsException();
                    }
                }
        
                var curr = this._readEncapsStack;
                this._readEncapsStack = curr.next;
                curr.next = this._readEncapsCache;
                this._readEncapsCache = curr;
                this._readEncapsCache.reset();
            },
            skipEmptyEncaps: function(encoding)
            {
                Debug.assert(encoding !== undefined);
                var sz = this.readInt();
                if(sz !== 6)
                {
                    throw new Ice.EncapsulationException();
                }
        
                var pos = this._buf.position;
                if(pos + 2 > this._buf.limit)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
        
                if(encoding !== null)
                {
                    encoding.__read(this);
                }
                else
                {
                    this._buf.position = pos + 2;
                }
            },
            endReadEncapsChecked: function() // Used by public stream API.
            {
                if(this._readEncapsStack === null)
                {
                    throw new Ice.EncapsulationException("not in an encapsulation");
                }
                this.endReadEncaps();
            },
            readEncaps: function(encoding)
            {
                Debug.assert(encoding !== undefined);
                var sz = this.readInt();
                if(sz < 6)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
        
                if(sz - 4 > this._buf.remaining)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
        
                if(encoding !== null)
                {
                    encoding.__read(this);
                    this._buf.position = this._buf.position - 6;
                }
                else
                {
                    this._buf.position = this._buf.position - 4;
                }
        
                try
                {
                    return this._buf.getArray(sz);
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            getReadEncoding: function()
            {
                return this._readEncapsStack !== null ? this._readEncapsStack.encoding : this._encoding;
            },
            getReadEncapsSize: function()
            {
                Debug.assert(this._readEncapsStack !== null);
                return this._readEncapsStack.sz - 6;
            },
            skipEncaps: function()
            {
                var sz = this.readInt();
                if(sz < 6)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
                var encoding = new Ice.EncodingVersion();
                encoding.__read(this);
                try
                {
                    this._buf.position = this._buf.position + sz - 6;
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
                return encoding;
            },
            startWriteSlice: function(typeId, compactId, last)
            {
                Debug.assert(this._writeEncapsStack !== null && this._writeEncapsStack.encoder !== null);
                this._writeEncapsStack.encoder.startSlice(typeId, compactId, last);
            },
            endWriteSlice: function()
            {
                Debug.assert(this._writeEncapsStack !== null && this._writeEncapsStack.encoder !== null);
                this._writeEncapsStack.encoder.endSlice();
            },
            startReadSlice: function() // Returns type ID of next slice
            {
                Debug.assert(this._readEncapsStack !== null && this._readEncapsStack.decoder !== null);
                return this._readEncapsStack.decoder.startSlice();
            },
            endReadSlice: function()
            {
                Debug.assert(this._readEncapsStack !== null && this._readEncapsStack.decoder !== null);
                this._readEncapsStack.decoder.endSlice();
            },
            skipSlice: function()
            {
                Debug.assert(this._readEncapsStack !== null && this._readEncapsStack.decoder !== null);
                this._readEncapsStack.decoder.skipSlice();
            },
            readPendingObjects: function()
            {
                if(this._readEncapsStack !== null && this._readEncapsStack.decoder !== null)
                {
                    this._readEncapsStack.decoder.readPendingObjects();
                }
                else if((this._readEncapsStack !== null && this._readEncapsStack.encoding_1_0) ||
                        (this._readEncapsStack === null && this._encoding.equals(Ice.Encoding_1_0)))
                {
                    //
                    // If using the 1.0 encoding and no objects were read, we
                    // still read an empty sequence of pending objects if
                    // requested (i.e.: if this is called).
                    //
                    // This is required by the 1.0 encoding, even if no objects
                    // are written we do marshal an empty sequence if marshaled
                    // data types use classes.
                    //
                    this.skipSize();
                }
            },
            writePendingObjects: function()
            {
                if(this._writeEncapsStack !== null && this._writeEncapsStack.encoder !== null)
                {
                    this._writeEncapsStack.encoder.writePendingObjects();
                }
                else if((this._writeEncapsStack !== null && this._writeEncapsStack.encoding_1_0) ||
                        (this._writeEncapsStack === null && this._encoding.equals(Ice.Encoding_1_0)))
                {
                    //
                    // If using the 1.0 encoding and no objects were written, we
                    // still write an empty sequence for pending objects if
                    // requested (i.e.: if this is called).
                    //
                    // This is required by the 1.0 encoding, even if no objects
                    // are written we do marshal an empty sequence if marshaled
                    // data types use classes.
                    //
                    this.writeSize(0);
                }
            },
            writeSize: function(v)
            {
                if(v > 254)
                {
                    this.expand(5);
                    this._buf.put(255);
                    this._buf.putInt(v);
                }
                else
                {
                    this.expand(1);
                    this._buf.put(v);
                }
            },
            readSize: function()
            {
                try
                {
                    var b = this._buf.get();
                    if(b === 255)
                    {
                        var v = this._buf.getInt();
                        if(v < 0)
                        {
                            throw new Ice.UnmarshalOutOfBoundsException();
                        }
                        return v;
                    }
                    return b;
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            readAndCheckSeqSize: function(minSize)
            {
                var sz = this.readSize();
        
                if(sz === 0)
                {
                    return sz;
                }
        
                //
                // The _startSeq variable points to the start of the sequence for which
                // we expect to read at least _minSeqSize bytes from the stream.
                //
                // If not initialized or if we already read more data than _minSeqSize,
                // we reset _startSeq and _minSeqSize for this sequence (possibly a
                // top-level sequence or enclosed sequence it doesn't really matter).
                //
                // Otherwise, we are reading an enclosed sequence and we have to bump
                // _minSeqSize by the minimum size that this sequence will  require on
                // the stream.
                //
                // The goal of this check is to ensure that when we start un-marshalling
                // a new sequence, we check the minimal size of this new sequence against
                // the estimated remaining buffer size. This estimatation is based on
                // the minimum size of the enclosing sequences, it's _minSeqSize.
                //
                if(this._startSeq === -1 || this._buf.position > (this._startSeq + this._minSeqSize))
                {
                    this._startSeq = this._buf.position;
                    this._minSeqSize = sz * minSize;
                }
                else
                {
                    this._minSeqSize += sz * minSize;
                }
        
                //
                // If there isn't enough data to read on the stream for the sequence (and
                // possibly enclosed sequences), something is wrong with the marshalled
                // data: it's claiming having more data that what is possible to read.
                //
                if(this._startSeq + this._minSeqSize > this._buf.limit)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
        
                return sz;
            },
            startSize: function()
            {
                var pos = this._buf.position;
                this.writeInt(0); // Placeholder for 32-bit size
                return pos;
            },
            endSize: function(pos)
            {
                Debug.assert(pos >= 0);
                this.rewriteInt(this._buf.position - pos - 4, pos);
            },
            writeBlob: function(v)
            {
                if(v === null)
                {
                    return;
                }
                this.expand(v.length);
                this._buf.putArray(v);
            },
            readBlob: function(sz)
            {
                if(this._buf.remaining < sz)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
                try
                {
                    return this._buf.getArray(sz);
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            // Read/write format and tag for optionals
            writeOpt: function(tag, format)
            {
                Debug.assert(this._writeEncapsStack !== null);
                if(this._writeEncapsStack.encoder !== null)
                {
                    return this._writeEncapsStack.encoder.writeOpt(tag, format);
                }
                return this.writeOptImpl(tag, format);
            },
            readOpt: function(tag, expectedFormat)
            {
                Debug.assert(this._readEncapsStack !== null);
                if(this._readEncapsStack.decoder !== null)
                {
                    return this._readEncapsStack.decoder.readOpt(tag, expectedFormat);
                }
                return this.readOptImpl(tag, expectedFormat);
            },
            writeOptValue: function(tag, format, write, v)
            {
                if(v !== undefined)
                {
                    if(this.writeOpt(tag, format))
                    {
                        write.call(this, v);
                    }
                }
            },
            readOptValue: function(tag, format, read)
            {
                if(this.readOpt(tag, format))
                {
                    return read.call(this);
                }
                else
                {
                    return undefined;
                }
            },
            writeByte: function(v)
            {
                this.expand(1);
                this._buf.put(v);
            },
            rewriteByte: function(v, dest)
            {
                this._buf.putAt(dest, v);
            },
            readByte: function()
            {
                try
                {
                    return this._buf.get();
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            writeByteSeq: function(v)
            {
                if(v === null || v.length === 0)
                {
                    this.writeSize(0);
                }
                else
                {
                    this.writeSize(v.length);
                    this.expand(v.length);
                    this._buf.putArray(v);
                }
            },
            readByteSeq: function()
            {
                return this._buf.getArray(this.readAndCheckSeqSize(1));
            },
            writeBool: function(v)
            {
                this.expand(1);
                this._buf.put(v ? 1 : 0);
            },
            rewriteBool: function(v, dest)
            {
                this._buf.putAt(dest, v ? 1 : 0);
            },
            readBool: function()
            {
                try
                {
                    return this._buf.get() === 1;
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            writeShort: function(v)
            {
                this.expand(2);
                this._buf.putShort(v);
            },
            readShort: function()
            {
                try
                {
                    return this._buf.getShort();
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            writeInt: function(v)
            {
                this.expand(4);
                this._buf.putInt(v);
            },
            rewriteInt: function(v, dest)
            {
                this._buf.putIntAt(dest, v);
            },
            readInt: function()
            {
                try
                {
                    return this._buf.getInt();
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            writeLong: function(v)
            {
                this.expand(8);
                this._buf.putLong(v);
            },
            readLong: function()
            {
                try
                {
                    return this._buf.getLong();
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            writeFloat: function(v)
            {
                this.expand(4);
                this._buf.putFloat(v);
            },
            readFloat: function()
            {
                try
                {
                    return this._buf.getFloat();
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            writeDouble: function(v)
            {
                this.expand(8);
                this._buf.putDouble(v);
            },
            readDouble: function()
            {
                try
                {
                    return this._buf.getDouble();
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            writeString: function(v)
            {
                if(v === null || v === undefined || v.length === 0)
                {
                    this.writeSize(0);
                }
                else
                {
                    this._buf.writeString(this, v);
                }
            },
            readString: function()
            {
                var len = this.readSize();
                if(len === 0)
                {
                    return "";
                }
                //
                // Check the buffer has enough bytes to read.
                //
                if(this._buf.remaining < len)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
        
                try
                {
                    return this._buf.getString(len);
                }
                catch(ex)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
            },
            writeProxy: function(v)
            {
                this._instance.proxyFactory().proxyToStream(v, this);
            },
            writeOptProxy: function(tag, v)
            {
                if(v !== undefined)
                {
                    if(this.writeOpt(tag, OptionalFormat.FSize))
                    {
                        var pos = this.startSize();
                        this.writeProxy(v);
                        this.endSize(pos);
                    }
                }
            },
            readProxy: function(type)
            {
                return this._instance.proxyFactory().streamToProxy(this, type);
            },
            readOptProxy: function(tag, type)
            {
                if(this.readOpt(tag, OptionalFormat.FSize))
                {
                    this.skip(4);
                    return this.readProxy(type);
                }
                else
                {
                    return undefined;
                }
            },
            writeEnum: function(v)
            {
                if(this.isWriteEncoding_1_0())
                {
                    if(v.maxValue < 127)
                    {
                        this.writeByte(v.value);
                    }
                    else if(v.maxValue < 32767)
                    {
                        this.writeShort(v.value);
                    }
                    else
                    {
                        this.writeInt(v.value);
                    }
                }
                else
                {
                    this.writeSize(v.value);
                }
            },
            readEnum: function(T)
            {
                var v;
                if(this.getReadEncoding().equals(Ice.Encoding_1_0))
                {
                    if(T.maxValue < 127)
                    {
                        v = this.readByte();
                    }
                    else if(T.maxValue < 32767)
                    {
                        v = this.readShort();
                    }
                    else
                    {
                        v = this.readInt();
                    }
                }
                else
                {
                    v = this.readSize();
                }
        
                var e = T.valueOf(v);
                if(e === undefined)
                {
                    throw new Ice.MarshalException("enumerator value " + v + " is out of range");
                }
                return e;
            },
            readOptEnum: function(tag, T)
            {
                if(this.readOpt(tag, OptionalFormat.Size))
                {
                    return this.readEnum(T);
                }
                else
                {
                    return undefined;
                }
            },
            writeObject: function(v)
            {
                this.initWriteEncaps();
                this._writeEncapsStack.encoder.writeObject(v);
            },
            writeOptObject: function(tag, v)
            {
                if(v !== undefined)
                {
                    if(this.writeOpt(tag, OptionalFormat.Class))
                    {
                        this.writeObject(v);
                    }
                }
            },
            readObject: function(patcher, T)
            {
                this.initReadEncaps();
                //
                // BUGFIX:
                // With Chrome linux the invokation of readObject on the decoder some times
                // calls BasicStream.readObject with the decoder object as this param.
                // Use call instead of directly invoke the method to workaround this bug.
                //
                this._readEncapsStack.decoder.readObject.call(
                    this._readEncapsStack.decoder,
                    function(obj){
                        if(obj !== null && !(obj.ice_instanceof(T)))
                        {
                            ExUtil.throwUOE(T.ice_staticId(), obj);
                        }
                        patcher(obj);
                    });
            },
            readOptObject: function(tag, patcher, T)
            {
                if(this.readOpt(tag, OptionalFormat.Class))
                {
                    this.readObject(patcher, T);
                }
                else
                {
                    patcher(undefined);
                }
            },
            writeUserException: function(e)
            {
                this.initWriteEncaps();
                this._writeEncapsStack.encoder.writeUserException(e);
            },
            throwException: function()
            {
                this.initReadEncaps();
                this._readEncapsStack.decoder.throwException();
            },
            sliceObjects: function(b)
            {
                this._sliceObjects = b;
            },
            readOptImpl: function(readTag, expectedFormat)
            {
                var b, v, format, tag, offset;
        
                if(this.isReadEncoding_1_0())
                {
                    return false; // Optional members aren't supported with the 1.0 encoding.
                }
        
                while(true)
                {
                    if(this._buf.position >= this._readEncapsStack.start + this._readEncapsStack.sz)
                    {
                        return false; // End of encapsulation also indicates end of optionals.
                    }
        
                    v = this.readByte();
        
                    if(v === OPTIONAL_END_MARKER)
                    {
                        this._buf.position -= 1; // Rewind.
                        return false;
                    }
        
                    format = OptionalFormat.valueOf(v & 0x07); // First 3 bits.
                    tag = v >> 3;
                    if(tag === 30)
                    {
                        tag = this.readSize();
                    }
        
                    if(tag > readTag)
                    {
                        offset = tag < 30 ? 1 : (tag < 255 ? 2 : 6); // Rewind
                        this._buf.position -= offset;
                        return false; // No optional data members with the requested tag.
                    }
        
                    if(tag < readTag)
                    {
                        this.skipOpt(format); // Skip optional data members
                    }
                    else
                    {
                        if(format !== expectedFormat)
                        {
                            throw new Ice.MarshalException("invalid optional data member `" + tag + "': unexpected format");
                        }
                        return true;
                    }
                }
            },
            writeOptImpl: function(tag, format)
            {
                if(this.isWriteEncoding_1_0())
                {
                    return false; // Optional members aren't supported with the 1.0 encoding.
                }
        
                var v = format.value;
                if(tag < 30)
                {
                    v |= tag << 3;
                    this.writeByte(v);
                }
                else
                {
                    v |= 0x0F0; // tag = 30
                    this.writeByte(v);
                    this.writeSize(tag);
                }
                return true;
            },
            skipOpt: function(format)
            {
                switch(format)
                {
                    case OptionalFormat.F1:
                        this.skip(1);
                        break;
                    case OptionalFormat.F2:
                        this.skip(2);
                        break;
                    case OptionalFormat.F4:
                        this.skip(4);
                        break;
                    case OptionalFormat.F8:
                        this.skip(8);
                        break;
                    case OptionalFormat.Size:
                        this.skipSize();
                        break;
                    case OptionalFormat.VSize:
                        this.skip(this.readSize());
                        break;
                    case OptionalFormat.FSize:
                        this.skip(this.readInt());
                        break;
                    case OptionalFormat.Class:
                        this.readObject(null, Ice.Object);
                        break;
                }
            },
            skipOpts: function()
            {
                var b, v, format;
                //
                // Skip remaining un-read optional members.
                //
                while(true)
                {
                    if(this._buf.position >= this._readEncapsStack.start + this._readEncapsStack.sz)
                    {
                        return; // End of encapsulation also indicates end of optionals.
                    }
        
                    b = this.readByte();
                    v = b < 0 ? b + 256 : b;
                    if(v === OPTIONAL_END_MARKER)
                    {
                        return;
                    }
        
                    format = OptionalFormat.valueOf(v & 0x07); // Read first 3 bits.
                    if((v >> 3) === 30)
                    {
                        this.skipSize();
                    }
                    this.skipOpt(format);
                }
            },
            skip: function(size)
            {
                if(size > this._buf.remaining)
                {
                    throw new Ice.UnmarshalOutOfBoundsException();
                }
                this._buf.position += size;
            },
            skipSize: function()
            {
                var b = this.readByte();
                if(b === 255)
                {
                    this.skip(4);
                }
            },
            isEmpty: function()
            {
                return this._buf.empty();
            },
            expand: function(n)
            {
                this._buf.expand(n);
            },
            createObject: function(id)
            {
                var obj = null, Class;
                try
                {
                    var typeId = id.length > 2 ? id.substr(2).replace(/::/g, ".") : "";
                    /*jshint -W061 */
                    Class = __M.type(typeId);
                    /*jshint +W061 */
                    if(Class !== undefined)
                    {
                        obj = new Class();
                    }
                }
                catch(ex)
                {
                    throw new Ice.NoObjectFactoryException("no object factory", id, ex);
                }
        
                return obj;
            },
            getTypeId: function(compactId)
            {
                var typeId = Ice.CompactIdRegistry.get(compactId);
                return typeId === undefined ? "" : typeId;
            },
            isReadEncoding_1_0: function()
            {
                return this._readEncapsStack !== null ? this._readEncapsStack.encoding_1_0 : this._encoding.equals(Ice.Encoding_1_0);
            },
            isWriteEncoding_1_0: function()
            {
                return this._writeEncapsStack ? this._writeEncapsStack.encoding_1_0 : this._encoding.equals(Ice.Encoding_1_0);
            },
            initReadEncaps: function()
            {
                if(this._readEncapsStack === null) // Lazy initialization
                {
                    this._readEncapsStack = this._readEncapsCache;
                    if(this._readEncapsStack !== null)
                    {
                        this._readEncapsCache = this._readEncapsCache.next;
                    }
                    else
                    {
                        this._readEncapsStack = new ReadEncaps();
                    }
                    this._readEncapsStack.setEncoding(this._encoding);
                    this._readEncapsStack.sz = this._buf.limit;
                }
        
                if(this._readEncapsStack.decoder === null) // Lazy initialization.
                {
                    var factoryManager = this._instance.servantFactoryManager();
                    if(this._readEncapsStack.encoding_1_0)
                    {
                        this._readEncapsStack.decoder = new EncapsDecoder10(this, this._readEncapsStack, this._sliceObjects, factoryManager);
                    }
                    else
                    {
                        this._readEncapsStack.decoder = new EncapsDecoder11(this, this._readEncapsStack, this._sliceObjects, factoryManager);
                    }
                }
            },
            initWriteEncaps: function()
            {
                if(!this._writeEncapsStack) // Lazy initialization
                {
                    this._writeEncapsStack = this._writeEncapsCache;
                    if(this._writeEncapsStack)
                    {
                        this._writeEncapsCache = this._writeEncapsCache.next;
                    }
                    else
                    {
                        this._writeEncapsStack = new WriteEncaps();
                    }
                    this._writeEncapsStack.setEncoding(this._encoding);
                }
        
                if(this._writeEncapsStack.format === FormatType.DefaultFormat)
                {
                    this._writeEncapsStack.format = this._instance.defaultsAndOverrides().defaultFormat;
                }
        
                if(!this._writeEncapsStack.encoder) // Lazy initialization.
                {
                    if(this._writeEncapsStack.encoding_1_0)
                    {
                        this._writeEncapsStack.encoder = new EncapsEncoder10(this, this._writeEncapsStack);
                    }
                    else
                    {
                        this._writeEncapsStack.encoder = new EncapsEncoder11(this, this._writeEncapsStack);
                    }
                }
            },
            createUserException: function(id)
            {
                var userEx = null, Class;
        
                try
                {
                    var typeId = id.length > 2 ? id.substr(2).replace(/::/g, ".") : "";
                    /*jshint -W061 */
                    Class = __M.type(typeId);
                    /*jshint +W061 */
                    if(Class !== undefined)
                    {
                        userEx = new Class();
                    }
                }
                catch(ex)
                {
                    throw new Ice.MarshalException(ex);
                }
        
                return userEx;
            }
        });
        
        var defineProperty = Object.defineProperty;
        
        defineProperty(BasicStream.prototype, "pos", {
            get: function() { return this._buf.position; },
            set: function(n) { this._buf.position = n; }
        });
        
        defineProperty(BasicStream.prototype, "size", {
            get: function() { return this._buf.limit; }
        });
        
        defineProperty(BasicStream.prototype, "instance", {
            get: function() { return this._instance; }
        });
        
        defineProperty(BasicStream.prototype, "closure", {
            get: function() { return this._type; },
            set: function(type) { this._type = type; }
        });
        
        defineProperty(BasicStream.prototype, "buffer", {
            get: function() { return this._buf; }
        });
        
        var defineBuiltinHelper = function(write, read, sz, format, min, max)
        {
            var helper = {
                write: function(os, v) { return write.call(os, v); },
                read: function(is) { return read.call(is); },
                writeOpt: function(os, tag, v) { os.writeOptValue(tag, format, write, v); },
                readOpt: function(is, tag) { return is.readOptValue(tag, format, read); },
            };
        
            if(min !== undefined && max !== undefined)
            {
                helper.validate = function(v) {
                    return v >= min && v <= max;
                };
            }
            defineProperty(helper, "minWireSize", {
                get: function() { return sz; }
            });
            return helper;
        };
        
        var stream = BasicStream.prototype;
        
        
        //
        // Constants to use in number type range checks.
        //
        var MIN_UINT8_VALUE = 0x0;
        var MAX_UINT8_VALUE = 0xFF;
        
        var MIN_INT16_VALUE = -0x8000;
        var MAX_INT16_VALUE = 0x7FFF;
        
        var MIN_UINT32_VALUE = 0x0;
        var MAX_UINT32_VALUE = 0xFFFFFFFF;
        
        var MIN_INT32_VALUE = -0x80000000;
        var MAX_INT32_VALUE = 0x7FFFFFFF;
        
        var MIN_FLOAT32_VALUE = -3.4028234664e+38;
        var MAX_FLOAT32_VALUE = 3.4028234664e+38;
        
        Ice.ByteHelper = defineBuiltinHelper(stream.writeByte, stream.readByte, 1, Ice.OptionalFormat.F1,
                                             MIN_UINT8_VALUE, MAX_UINT8_VALUE);
        
        Ice.ShortHelper = defineBuiltinHelper(stream.writeShort, stream.readShort, 2, Ice.OptionalFormat.F2,
                                              MIN_INT16_VALUE, MAX_INT16_VALUE);
        
        Ice.IntHelper = defineBuiltinHelper(stream.writeInt, stream.readInt, 4, Ice.OptionalFormat.F4,
                                            MIN_INT32_VALUE, MAX_INT32_VALUE);
        
        Ice.FloatHelper = defineBuiltinHelper(stream.writeFloat, stream.readFloat, 4, Ice.OptionalFormat.F4,
                                              MIN_FLOAT32_VALUE, MAX_FLOAT32_VALUE);
        Ice.FloatHelper.validate = function(v)
        {
            return Number.isNaN(v) || v == Number.POSITIVE_INFINITY || v == Number.NEGATIVE_INFINITY ||
                (v >= MIN_FLOAT32_VALUE && v <= MAX_FLOAT32_VALUE);
        };
        
        Ice.DoubleHelper = defineBuiltinHelper(stream.writeDouble, stream.readDouble, 8, Ice.OptionalFormat.F8,
                                               -Number.MAX_VALUE, Number.MAX_VALUE);
        Ice.DoubleHelper.validate = function(v)
        {
            return Number.isNaN(v) || v == Number.POSITIVE_INFINITY || v == Number.NEGATIVE_INFINITY ||
                (v >= -Number.MAX_VALUE && v <= Number.MAX_VALUE);
        };
        
        Ice.BoolHelper = defineBuiltinHelper(stream.writeBool, stream.readBool, 1, Ice.OptionalFormat.F1);
        Ice.LongHelper = defineBuiltinHelper(stream.writeLong, stream.readLong, 8, Ice.OptionalFormat.F8);
        Ice.LongHelper.validate = function(v)
        {
            //
            // For a long to be valid both words must be within the range of UINT32
            //
            return v.low >= MIN_UINT32_VALUE && v.low <= MAX_UINT32_VALUE &&
                   v.high >= MIN_UINT32_VALUE && v.high <= MAX_UINT32_VALUE;
        };
        
        Ice.StringHelper = defineBuiltinHelper(stream.writeString, stream.readString, 1, Ice.OptionalFormat.VSize);
        
        Ice.ObjectHelper = {
            write: function(os, v)
            {
                os.writeObject(v);
            },
            read: function(is)
            {
                var o;
                is.readObject(function(v) { o = v; }, Ice.Object);
                return o;
            },
            writeOpt: function(os, tag, v)
            {
                os.writeOptValue(tag, Ice.OptionalFormat.Class, stream.writeObject, v);
            },
            readOpt: function(is, tag)
            {
                var o;
                is.readOptObject(tag, function(v) { o = v; }, Ice.Object);
                return o;
            },
        };
        
        defineProperty(Ice.ObjectHelper, "minWireSize", {
            get: function() { return 1; }
        });
        
        Ice.BasicStream = BasicStream;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        Ice.SocketOperation = 
        {
            None: 0,
            Read: 1,
            Write: 2,
            Connect: 2 // Same as Write
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        //
        // NOTE: the protocol instance class is a bit different from other
        // language mappinps since it also provides the secure property for
        // the tranport. Since we don't support SSL but still want to be able
        // to parse SSL endpoints, we simply re-use the TCP endpoint with a
        // different protocol instance to support SSL endpoints.
        //
        // If SSL endpoints attributes were to diverge from TCP endpoints or
        // if we want to support SSL, we'd have to change this and instead, do
        // like in other mappings: have a separate implementation for the SSL
        // endpoint and suppress the secure member of the protocol instance
        // class bellow.
        //
        var ProtocolInstance = Ice.Class({
            __init__: function(instance, type, protocol, secure)
            {
                this._instance = instance;
                this._traceLevel = instance.traceLevels().network;
                this._traceCategory = instance.traceLevels().networkCat;
                this._logger = instance.initializationData().logger;
                this._properties = instance.initializationData().properties;
                this._type = type;
                this._protocol = protocol;
                this._secure = secure;
            },
            traceLevel: function()
            {
                return this._traceLevel;
            },
            traceCategory: function()
            {
                return this._traceCategory;
            },
            logger: function()
            {
                return this._logger;
            },
            protocol: function()
            {
                return this._protocol;
            },
            type: function()
            {
                return this._type;
            },
            secure: function()
            {
                return this._secure;
            },
            properties: function()
            {
                return this._properties;
            },
            defaultHost: function()
            {
                return this._instance.defaultsAndOverrides().defaultHost;
            },
            defaultSourceAddress: function()
            {
                return this._instance.defaultsAndOverrides().defaultSourceAddress;
            },
            defaultEncoding: function()
            {
                return this._instance.defaultsAndOverrides().defaultEncoding;
            },
            defaultTimeout: function()
            {
                return this._instance.defaultsAndOverrides().defaultTimeout;
            },
            messageSizeMax: function()
            {
                return this._instance.messageSizeMax();
            }
        });
        
        Ice.ProtocolInstance = ProtocolInstance;
        
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `EndpointF.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
            Slice.defineSequence(Ice, "EndpointSeqHelper", "Ice.ObjectHelper", false, "Ice.Endpoint");
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var AsyncResultBase = Ice.AsyncResultBase;
        var Debug = Ice.Debug;
        var Promise = Ice.Promise;
        var Protocol = Ice.Protocol;
        var UserException = Ice.UserException;
        var BasicStream = Ice.BasicStream;
        
        var AsyncResult = Ice.Class(AsyncResultBase, {
            __init__: function(com, op, connection, proxy, adapter, completedFn)
            {
                //
                // AsyncResult can be constructed by a sub-type's prototype, in which case the
                // arguments are undefined.
                //
                AsyncResultBase.call(this, com, op, connection, proxy, adapter);
                if(com === undefined)
                {
                    return;
                }
                
                this._completed = completedFn;
                this._is = null;
                this._os = com !== null ? new BasicStream(this._instance, Protocol.currentProtocolEncoding) : null;
                this._state = 0;
                this._exception = null;
                this._sentSynchronously = false;
            },
            cancel: function()
            {
                this.__cancel(new Ice.InvocationCanceledException());
            },
            isCompleted: function()
            {
                return (this._state & AsyncResult.Done) > 0;
            },
            isSent: function()
            {
                return (this._state & AsyncResult.Sent) > 0;
            },
            throwLocalException: function()
            {
                if(this._exception !== null)
                {
                    throw this._exception;
                }
            },
            sentSynchronously: function()
            {
                return this._sentSynchronously;
            },
            __markSent: function(done)
            {
                Debug.assert((this._state & AsyncResult.Done) === 0);
                this._state |= AsyncResult.Sent;
                if(done)
                {
                    this._state |= AsyncResult.Done | AsyncResult.OK;
                    this._cancellationHandler = null;
                    this.succeed(this);
                }
            },
            __markFinished: function(ok, completed)
            {
                Debug.assert((this._state & AsyncResult.Done) === 0);
                this._state |= AsyncResult.Done;
                if(ok)
                {
                    this._state |= AsyncResult.OK;
                }
                this._cancellationHandler = null;
                if(completed)
                {
                    completed(this);
                }
                else
                {
                    this.succeed(this);
                }
            },
            __markFinishedEx: function(ex)
            {
                Debug.assert((this._state & AsyncResult.Done) === 0);
                this._exception = ex;
                this._state |= AsyncResult.Done;
                this._cancellationHandler = null;
                this.fail(ex, this);
            },
            __cancel: function(ex)
            {
                this._cancellationException = ex;
                if(this._cancellationHandler)
                {
                    this._cancellationHandler.asyncRequestCanceled(this, ex);
                }
            },
            __cancelable: function(handler)
            {
                if(this._cancellationException)
                {
                    try
                    {
                        throw this._cancellationException;
                    }
                    finally
                    {
                        this._cancellationException = null;
                    }
                }
                this._cancellationHandler = handler;
            },
            __os: function()
            {
                return this._os;
            },
            __is: function()
            {
                return this._is;
            },
            __startReadParams: function()
            {
                this._is.startReadEncaps();
                return this._is;
            },
            __endReadParams: function()
            {
                this._is.endReadEncaps();
            },
            __readEmptyParams: function()
            {
                this._is.skipEmptyEncaps(null);
            },
            __readParamEncaps: function()
            {
                return this._is.readEncaps(null);
            },
            __throwUserException: function()
            {
                Debug.assert((this._state & AsyncResult.Done) !== 0);
                if((this._state & AsyncResult.OK) === 0)
                {
                    try
                    {
                        this._is.startReadEncaps();
                        this._is.throwException();
                    }
                    catch(ex)
                    {
                        if(ex instanceof UserException)
                        {
                            this._is.endReadEncaps();
                        }
                        throw ex;
                    }
                }
            },
        });
        
        AsyncResult.OK = 0x1;
        AsyncResult.Done = 0x2;
        AsyncResult.Sent = 0x4;
        
        Ice.AsyncResult = AsyncResult;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
            
        
        Ice.Address = function(host, port)
        {
            this.host = host;
            this.port = port;
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var BasicStream = Ice.BasicStream;
        var Debug = Ice.Debug;
        var ExUtil = Ice.ExUtil;
        var Class = Ice.Class;
        var Protocol = Ice.Protocol;
        
        var udpOverhead = 20 + 8;
        
        var BatchRequestQueue = Class({
            __init__: function(instance, datagram)
            {
                this._batchStreamInUse = false;
                this._batchRequestNum = 0;
                this._batchStream = new BasicStream(instance, Protocol.currentProtocolEncoding);
                this._batchStream.writeBlob(Protocol.requestBatchHdr);
                this._batchMarker = this._batchStream.size;
                this._exception = null;
        
                this._maxSize = instance.batchAutoFlushSize();
                if(this._maxSize > 0 && datagram)
                {
                    var props = instance.initializationData().properties;
                    var udpSndSize = props.getPropertyAsIntWithDefault("Ice.UDP.SndSize", 65535 - udpOverhead);
                    if(udpSndSize < this._maxSize)
                    {
                        this._maxSize = udpSndSize;
                    }
                }
            },
            prepareBatchRequest: function(os)
            {
                if(this._exception)
                {
                    throw this._exception;
                }
                this._batchStream.swap(os);
            },
            finishBatchRequest: function(os, proxy, operation)
            {
                //
                // No need for synchronization, no other threads are supposed
                // to modify the queue since we set this._batchStreamInUse to true.
                //
                this._batchStream.swap(os);
        
                try
                {
                    if(this._maxSize > 0 && this._batchStream.size >= this._maxSize)
                    {
                        proxy.ice_flushBatchRequests(); // Auto flush
                    }
        
                    Debug.assert(this._batchMarker < this._batchStream.size);
                    this._batchMarker = this._batchStream.size;
                    ++this._batchRequestNum;
                }
                finally
                {
                    this._batchStream.resize(this._batchMarker);
                }
            },
            abortBatchRequest: function(os)
            {
                this._batchStream.swap(os);
                this._batchStream.resize(this._batchMarker);
            },
            swap: function(os)
            {
                if(this._batchRequestNum === 0)
                {
                    return 0;
                }
        
                var lastRequest = null;
                if(this._batchMarker < this._batchStream.size)
                {
                    var length = this._batchStream.size - this._batchMarker;
                    this._batchStream.pos = this._batchMarker;
                    lastRequest = this._batchStream.buffer.getArray(length);
                    this._batchStream.resize(this._batchMarker);
                }
        
                var requestNum = this._batchRequestNum;
                this._batchStream.swap(os);
        
                //
                // Reset the batch.
                //
                this._batchRequestNum = 0;
                this._batchStream.writeBlob(Protocol.requestBatchHdr);
                this._batchMarker = this._batchStream.size;
                if(lastRequest !== null)
                {
                    this._batchStream.writeBlob(lastRequest);
                }
                return requestNum;
            },
            destroy: function(ex)
            {
                this._exception = ex;
            },
            isEmpty: function()
            {
                return this._batchStream.size === Protocol.requestBatchHdr.length;
            }
        });
        
        Ice.BatchRequestQueue = BatchRequestQueue;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var HashMap = Ice.HashMap;
        var CommunicatorDestroyedException = Ice.CommunicatorDestroyedException;
        
        var Timer = Ice.Class({
            __init__: function(logger)
            {
                this._logger = logger;
                this._destroyed = false;
                this._tokenId = 0;
                this._tokens = new HashMap();
            },
            destroy: function()
            {
                var self = this;
                this._tokens.forEach(function(key, value){
                    self.cancel(key);
                });
                this._destroyed = true;
                this._tokens.clear();
            },
            schedule: function(callback, delay)
            {
                if(this._destroyed)
                {
                    throw new CommunicatorDestroyedException();
                }
        
                var token = this._tokenId++;
                var self = this;
                var id = Timer.setTimeout(function() { self.handleTimeout(token); }, delay);
                this._tokens.set(token, { callback: callback, id: id, isInterval: false });
        
                return token;
            },
            scheduleRepeated: function(callback, period)
            {
                if(this._destroyed)
                {
                    throw new CommunicatorDestroyedException();
                }
        
                var token = this._tokenId++;
                var self = this;
        
                var id = Timer.setInterval(function() { self.handleInterval(token); }, period);
                this._tokens.set(token, { callback: callback, id: id, isInterval: true });
        
                return token;
            },
            cancel: function(id)
            {
                if(this._destroyed)
                {
                    return false;
                }
        
                var token = this._tokens.get(id);
                if(token === undefined)
                {
                    return false;
                }
        
                this._tokens.del(id);
                if(token.isInterval)
                {
                    Timer.clearInterval(token.id);
                }
                else
                {
                    Timer.clearTimeout(token.id);
                }
        
                return true;
            },
            handleTimeout: function(id)
            {
                if(this._destroyed)
                {
                    return;
                }
        
                var token = this._tokens.get(id);
                if(token !== undefined)
                {
                    this._tokens.del(id);
                    try
                    {
                        token.callback();
                    }
                    catch(ex)
                    {
                        this._logger.warning("uncaught exception while executing timer:\n" + ex);
                    }
                }
            },
            handleInterval: function(id)
            {
                if(this._destroyed)
                {
                    return;
                }
        
                var token = this._tokens.get(id);
                if(token !== undefined)
                {
                    try
                    {
                        token.callback();
                    }
                    catch(ex)
                    {
                        this._logger.warning("uncaught exception while executing timer:\n" + ex);
                    }
                }
            }
        });
        
        Timer.setTimeout = Ice.Timer.setTimeout;
        Timer.clearTimeout = Ice.Timer.clearTimeout;
        Timer.setInterval = Ice.Timer.setInterval;
        Timer.clearInterval = Ice.Timer.clearInterval;
        Timer.setImmediate = Ice.Timer.setImmediate;
        
        Ice.Timer = Timer;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Class = Ice.Class;
        
        var RetryQueue = Class({
            __init__: function(instance)
            {
                this._instance = instance;
                this._requests = [];
            },
            add: function(outAsync, interval)
            {
                if(this._instance === null)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
                var task = new RetryTask(this._instance, this, outAsync);
                outAsync.__cancelable(task); // This will throw if the request is canceled
                task.token = this._instance.timer().schedule(function()
                                                             {
                                                                 task.run();
                                                             }, interval);
                this._requests.push(task);
            },
            destroy: function()
            {
                for(var i = 0; i < this._requests.length; ++i)
                {
                    this._instance.timer().cancel(this._requests[i].token);
                    this._requests[i].destroy();
                }
                this._requests = [];
                this._instance = null;
            },
            remove: function(task)
            {
                var idx = this._requests.indexOf(task);
                if(idx >= 0)
                {
                    this._requests.splice(idx, 1);
                }
            },
            cancel: function(task)
            {
                var idx = this._requests.indexOf(task);
                if(idx >= 0)
                {
                    this._requests.splice(idx, 1);
                    return this._instance.timer().cancel(task.token);
                }
                return false;
            }
        });
        Ice.RetryQueue = RetryQueue;
        
        var RetryTask = Class({
            __init__: function(instance, queue, outAsync, interval)
            {
                this._instance = instance;
                this._queue = queue;
                this._outAsync = outAsync;
            },
            run: function()
            {
                this._outAsync.__retry();
                this._queue.remove(this);
            },
            destroy: function()
            {
                try
                {
                    this._outAsync.__abort(new Ice.CommunicatorDestroyedException());
                }
                catch(ex)
                {
                    // Abort shouldn't throw if there's no callback, ignore.
                }
            },
            asyncRequestCanceled: function(outAsync, ex)
            {
                if(this._queue.cancel(this))
                {
                    if(this._instance.traceLevels().retry >= 1)
                    {
                        this._instance.initializationData().logger.trace(this._instance.traceLevels().retryCat,
                                                                         "operation retry canceled\n" + ex.toString());
                    }
                    this._outAsync.__completedEx(ex);
                }
            }
        });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var ArrayUtil = Ice.ArrayUtil;
        var Debug = Ice.Debug;
        var HashMap = Ice.HashMap;
        var Promise = Ice.Promise;
        
        var RouterInfo = Ice.Class({
            __init__: function(router)
            {
                this._router = router;
        
                Debug.assert(this._router !== null);
        
                this._clientEndpoints = null;
                this._serverEndpoints = null;
                this._adapter = null;
                this._identities = new HashMap(HashMap.compareEquals); // Set<Identity> = Map<Identity, 1>
                this._evictedIdentities = [];
            },
            destroy: function()
            {
                this._clientEndpoints = [];
                this._serverEndpoints = [];
                this._adapter = null;
                this._identities.clear();
            },
            equals: function(rhs)
            {
                if(this === rhs)
                {
                    return true;
                }
        
                if(rhs instanceof RouterInfo)
                {
                    return this._router.equals(rhs._router);
                }
        
                return false;
            },
            hashCode: function()
            {
                return this._router.hashCode();
            },
            getRouter: function()
            {
                //
                // No mutex lock necessary, _router is immutable.
                //
                return this._router;
            },
            getClientEndpoints: function()
            {
                var promise = new Promise();
        
                if(this._clientEndpoints !== null)
                {
                    promise.succeed(this._clientEndpoints);
                }
                else
                {
                    var self = this;
                    this._router.getClientProxy().then(
                        function(clientProxy)
                        {
                            self.setClientEndpoints(clientProxy, promise);
                        }).exception(
                            function(ex)
                            {
                                promise.fail(ex);
                            });
                }
        
                return promise;
            },
            getServerEndpoints: function()
            {
                if(this._serverEndpoints !== null) // Lazy initialization.
                {
                    return new Promise().succeed(this._serverEndpoints);
                }
                else
                {
                    var self = this;
                    return this._router.getServerProxy().then(
                        function(proxy)
                        {
                            return self.setServerEndpoints(proxy);
                        });
                }
            },
            addProxy: function(proxy)
            {
                Debug.assert(proxy !== null);
        
                if(this._identities.has(proxy.ice_getIdentity()))
                {
                    //
                    // Only add the proxy to the router if it's not already in our local map.
                    //
                    return new Promise().succeed();
                }
                else
                {
                    var self = this;
                    return this._router.addProxies([ proxy ]).then(
                        function(evictedProxies)
                        {
                            self.addAndEvictProxies(proxy, evictedProxies);
                        });
                }
            },
            setAdapter: function(adapter)
            {
                this._adapter = adapter;
            },
            getAdapter: function()
            {
                return this._adapter;
            },
            clearCache: function(ref)
            {
                this._identities.del(ref.getIdentity());
            },
            setClientEndpoints: function(clientProxy, promise)
            {
                if(this._clientEndpoints === null)
                {
                    if(clientProxy === null)
                    {
                        //
                        // If getClientProxy() return nil, use router endpoints.
                        //
                        this._clientEndpoints = this._router.__reference().getEndpoints();
                        promise.succeed(this._clientEndpoints);
                    }
                    else
                    {
                        clientProxy = clientProxy.ice_router(null); // The client proxy cannot be routed.
        
                        //
                        // In order to avoid creating a new connection to the
                        // router, we must use the same timeout as the already
                        // existing connection.
                        //
                        var self = this;
                        this._router.ice_getConnection().then(
                            function(con)
                            {
                                var proxy = clientProxy.ice_timeout(con.timeout());
                                self._clientEndpoints = proxy.__reference().getEndpoints();
                                promise.succeed(self._clientEndpoints);
                            }).exception(
                                function(ex)
                                {
                                    promise.fail(ex);
                                });
                    }
                }
                else
                {
                    promise.succeed(this._clientEndpoints);
                }
            },
            setServerEndpoints: function(serverProxy)
            {
                if(serverProxy === null)
                {
                    throw new Ice.NoEndpointException();
                }
        
                serverProxy = serverProxy.ice_router(null); // The server proxy cannot be routed.
                this._serverEndpoints = serverProxy.__reference().getEndpoints();
                return this._serverEndpoints;
            },
            addAndEvictProxies: function(proxy, evictedProxies)
            {
                //
                // Check if the proxy hasn't already been evicted by a
                // concurrent addProxies call. If it's the case, don't
                // add it to our local map.
                //
                var index = ArrayUtil.indexOf(this._evictedIdentities, proxy.ice_getIdentity(),
                                            function(i1, i2) { return i1.equals(i2); });
                if(index >= 0)
                {
                    this._evictedIdentities.splice(index, 1);
                }
                else
                {
                    //
                    // If we successfully added the proxy to the router,
                    // we add it to our local map.
                    //
                    this._identities.set(proxy.ice_getIdentity(), 1);
                }
        
                //
                // We also must remove whatever proxies the router evicted.
                //
                for(var i = 0; i < evictedProxies.length; ++i)
                {
                    this._identities.del(evictedProxies[i].ice_getIdentity());
                }
            }
        });
        
        Ice.RouterInfo = RouterInfo;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_FOR_ACTIONSCRIPT_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var AsyncStatus = Ice.AsyncStatus;
        var AsyncResult = Ice.AsyncResult;
        var BasicStream = Ice.BasicStream;
        var Debug = Ice.Debug;
        var HashMap = Ice.HashMap;
        var RetryException = Ice.RetryException;
        var OperationMode = Ice.OperationMode;
        var Protocol = Ice.Protocol;
        var Identity = Ice.Identity;
        
        var OutgoingAsyncBase = Ice.Class(AsyncResult, {
            __init__ : function(communicator, operation, connection, proxy, adapter)
            {
                if(communicator !== undefined)
                {
                    AsyncResult.call(this, communicator, operation, connection, proxy, adapter);
                    this._os = new BasicStream(this._instance, Protocol.currentProtocolEncoding);
                }
                else
                {
                    AsyncResult.call(this);
                }
            },
            __os: function()
            {
                return this._os;
            },
            __sent: function()
            {
                this.__markSent(true);
            },
            __completedEx: function(ex)
            {
                this.__markFinishedEx(ex);
            }
        });
        
        
        var ProxyOutgoingAsyncBase = Ice.Class(OutgoingAsyncBase, {
            __init__ : function(prx, operation)
            {
                if(prx !== undefined)
                {
                    OutgoingAsyncBase.call(this, prx.ice_getCommunicator(), operation, null, prx, null);
                    this._mode = null;
                    this._cnt = 0;
                    this._sent = false;
                    this._handler = null;
                }
                else
                {
                    AsyncResult.call(this);
                }
            },
            __completedEx: function(ex)
            {
                try
                {
                    this._instance.retryQueue().add(this, this.__handleException(ex));
                }
                catch(ex)
                {
                    this.__markFinishedEx(ex);
                }
            },
            __retryException: function(ex)
            {
                try
                {
                    this._proxy.__updateRequestHandler(this._handler, null); // Clear request handler and always retry.
                    this._instance.retryQueue().add(this, 0);
                }
                catch(ex)
                {
                    this.__completedEx(ex);
                }
            },
            __retry: function()
            {
                this.__invokeImpl(false);
            },
            __abort: function(ex)
            {
                this.__markFinishedEx(ex);
            },
            __invokeImpl: function(userThread)
            {
                try
                {
                    if(userThread)
                    {
                        var invocationTimeout = this._proxy.__reference().getInvocationTimeout();
                        if(invocationTimeout > 0)
                        {
                            var self = this;
                            this._timeoutToken = this._instance.timer().schedule(
                                function()
                                {
                                    self.__cancel(new Ice.InvocationTimeoutException());
                                },
                                invocationTimeout);
                        }
                    }
        
                    while(true)
                    {
                        try
                        {
                            this._sent  = false;
                            this._handler = this._proxy.__getRequestHandler();
                            var status = this._handler.sendAsyncRequest(this);
                            if((status & AsyncStatus.Sent) > 0)
                            {
                                if(userThread)
                                {
                                    this._sentSynchronously = true;
                                }
                            }
                            return; // We're done!
                        }
                        catch(ex)
                        {
                            if(ex instanceof RetryException)
                            {
                                // Clear request handler and always retry
                                this._proxy.__updateRequestHandler(this._handler, null);
                            }
                            else
                            {
                                var interval = this.__handleException(ex);
                                if(interval > 0)
                                {
                                    this._instance.retryQueue().add(this, interval);
                                    return;
                                }
                            }
                        }
                    }
                }
                catch(ex)
                {
                    this.__markFinishedEx(ex);
                }
            },
            __markSent: function(done)
            {
                this._sent = true;
                if(done)
                {
                    if(this._timeoutToken)
                    {
                        this._instance.timer().cancel(this._timeoutToken);
                    }
                }
                OutgoingAsyncBase.prototype.__markSent.call(this, done);
            },
            __markFinishedEx: function(ex)
            {
                if(this._timeoutToken)
                {
                    this._instance.timer().cancel(this._timeoutToken);
                }
                OutgoingAsyncBase.prototype.__markFinishedEx.call(this, ex);
            },
            __handleException: function(ex)
            {
                var interval = { value: 0 };
                this._cnt = this._proxy.__handleException(ex, this._handler, this._mode, this._sent, interval, this._cnt);
                return interval.value;
            }
        });
        
        var OutgoingAsync = Ice.Class(ProxyOutgoingAsyncBase, {
            __init__: function(prx, operation, completed)
            {
                //
                // OutgoingAsync can be constructed by a sub-type's prototype, in which case the
                // arguments are undefined.
                //
                if(prx !== undefined)
                {
                    ProxyOutgoingAsyncBase.call(this, prx, operation);
                    this._encoding = Protocol.getCompatibleEncoding(this._proxy.__reference().getEncoding());
                    this._completed = completed;
                }
                else
                {
                    ProxyOutgoingAsyncBase.call(this);
                }
            },
            __prepare: function(op, mode, ctx)
            {
                Protocol.checkSupportedProtocol(Protocol.getCompatibleProtocol(this._proxy.__reference().getProtocol()));
        
                this._mode = mode;
                if(ctx === null)
                {
                    ctx = OutgoingAsync._emptyContext;
                }
        
                if(this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram())
                {
                    this._proxy.__getBatchRequestQueue().prepareBatchRequest(this._os);
                }
                else
                {
                    this._os.writeBlob(Protocol.requestHdr);
                }
        
                var ref = this._proxy.__reference();
        
                ref.getIdentity().__write(this._os);
        
                //
                // For compatibility with the old FacetPath.
                //
                var facet = ref.getFacet();
                if(facet === null || facet.length === 0)
                {
                    Ice.StringSeqHelper.write(this._os, null);
                }
                else
                {
                    Ice.StringSeqHelper.write(this._os, [ facet ]);
                }
        
                this._os.writeString(this._operation);
        
                this._os.writeByte(mode.value);
        
                if(ctx !== undefined)
                {
                    if(ctx !== null && !(ctx instanceof HashMap))
                    {
                        throw new Error("illegal context value, expecting null or HashMap");
                    }
        
                    //
                    // Explicit context
                    //
                    Ice.ContextHelper.write(this._os, ctx);
                }
                else
                {
                    //
                    // Implicit context
                    //
                    var implicitContext = ref.getInstance().getImplicitContext();
                    var prxContext = ref.getContext();
        
                    if(implicitContext === null)
                    {
                        Ice.ContextHelper.write(this._os, prxContext);
                    }
                    else
                    {
                        implicitContext.write(prxContext, this._os);
                    }
                }
            },
            __sent: function()
            {
                this.__markSent(!this._proxy.ice_isTwoway());
            },
            __invokeRemote: function(connection, compress, response)
            {
                return connection.sendAsyncRequest(this, compress, response, 0);
            },
            __abort: function(ex)
            {
                if(this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram())
                {
                    this._proxy.__getBatchRequestQueue().abortBatchRequest(this._os);
                }
                ProxyOutgoingAsyncBase.prototype.__abort.call(this, ex);
            },
            __invoke: function()
            {
                if(this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram())
                {
                    this._sentSynchronously = true;
                    this._proxy.__getBatchRequestQueue().finishBatchRequest(this._os, this._proxy, this._operation);
                    this.__markFinished(true);
                    return;
                }
        
                //
                // NOTE: invokeImpl doesn't throw so this can be called from the
                // try block with the catch block calling abort() in case of an
                // exception.
                //
                this.__invokeImpl(true); // userThread = true
            },
            __completed: function(istr)
            {
                Debug.assert(this._proxy.ice_isTwoway()); // Can only be called for twoways.
        
                var replyStatus;
                try
                {
                    if(this._is === null) // _is can already be initialized if the invocation is retried
                    {
                        this._is = new BasicStream(this._instance, Protocol.currentProtocolEncoding);
                    }
                    this._is.swap(istr);
                    replyStatus = this._is.readByte();
        
                    switch(replyStatus)
                    {
                        case Protocol.replyOK:
                        case Protocol.replyUserException:
                        {
                            break;
                        }
        
                        case Protocol.replyObjectNotExist:
                        case Protocol.replyFacetNotExist:
                        case Protocol.replyOperationNotExist:
                        {
                            var id = new Identity();
                            id.__read(this._is);
        
                            //
                            // For compatibility with the old FacetPath.
                            //
                            var facetPath = Ice.StringSeqHelper.read(this._is);
                            var facet;
                            if(facetPath.length > 0)
                            {
                                if(facetPath.length > 1)
                                {
                                    throw new Ice.MarshalException();
                                }
                                facet = facetPath[0];
                            }
                            else
                            {
                                facet = "";
                            }
        
                            var operation = this._is.readString();
        
                            var rfe = null;
                            switch(replyStatus)
                            {
                            case Protocol.replyObjectNotExist:
                            {
                                rfe = new Ice.ObjectNotExistException();
                                break;
                            }
        
                            case Protocol.replyFacetNotExist:
                            {
                                rfe = new Ice.FacetNotExistException();
                                break;
                            }
        
                            case Protocol.replyOperationNotExist:
                            {
                                rfe = new Ice.OperationNotExistException();
                                break;
                            }
        
                            default:
                            {
                                Debug.assert(false);
                                break;
                            }
                            }
        
                            rfe.id = id;
                            rfe.facet = facet;
                            rfe.operation = operation;
                            throw rfe;
                        }
        
                        case Protocol.replyUnknownException:
                        case Protocol.replyUnknownLocalException:
                        case Protocol.replyUnknownUserException:
                        {
                            var unknown = this._is.readString();
        
                            var ue = null;
                            switch(replyStatus)
                            {
                            case Protocol.replyUnknownException:
                            {
                                ue = new Ice.UnknownException();
                                break;
                            }
        
                            case Protocol.replyUnknownLocalException:
                            {
                                ue = new Ice.UnknownLocalException();
                                break;
                            }
        
                            case Protocol.replyUnknownUserException:
                            {
                                ue = new Ice.UnknownUserException();
                                break;
                            }
        
                            default:
                            {
                                Debug.assert(false);
                                break;
                            }
                            }
        
                            ue.unknown = unknown;
                            throw ue;
                        }
        
                        default:
                        {
                            throw new Ice.UnknownReplyStatusException();
                        }
                    }
        
                    this.__markFinished(replyStatus == Protocol.replyOK, this._completed);
                }
                catch(ex)
                {
                    this.__completedEx(ex);
                }
            },
            __startWriteParams: function(format)
            {
                this._os.startWriteEncaps(this._encoding, format);
                return this._os;
            },
            __endWriteParams: function()
            {
                this._os.endWriteEncaps();
            },
            __writeEmptyParams: function()
            {
                this._os.writeEmptyEncaps(this._encoding);
            },
            __writeParamEncaps: function(encaps)
            {
                if(encaps === null || encaps.length === 0)
                {
                    this._os.writeEmptyEncaps(this._encoding);
                }
                else
                {
                    this._os.writeEncaps(encaps);
                }
            },
            __is: function()
            {
                return this._is;
            },
            __startReadParams: function()
            {
                this._is.startReadEncaps();
                return this._is;
            },
            __endReadParams: function()
            {
                this._is.endReadEncaps();
            },
            __readEmptyParams: function()
            {
                this._is.skipEmptyEncaps(null);
            },
            __readParamEncaps: function()
            {
                return this._is.readEncaps(null);
            },
            __throwUserException: function()
            {
                Debug.assert((this._state & AsyncResult.Done) !== 0);
                if((this._state & AsyncResult.OK) === 0)
                {
                    try
                    {
                        this._is.startReadEncaps();
                        this._is.throwException();
                    }
                    catch(ex)
                    {
                        if(ex instanceof Ice.UserException)
                        {
                            this._is.endReadEncaps();
                        }
                        throw ex;
                    }
                }
            },
        });
        OutgoingAsync._emptyContext = new HashMap();
        
        var ProxyFlushBatch = Ice.Class(ProxyOutgoingAsyncBase, {
            __init__ : function(prx, operation)
            {
                ProxyOutgoingAsyncBase.call(this, prx, operation);
                this._batchRequestNum = prx.__getBatchRequestQueue().swap(this._os);
            },
            __invokeRemote: function(connection, compress, response)
            {
                if(this._batchRequestNum === 0)
                {
                    this.__sent();
                    return AsyncStatus.Sent;
                }
                return connection.sendAsyncRequest(this, compress, response, this._batchRequestNum);
            },
            __invoke: function()
            {
                Protocol.checkSupportedProtocol(Protocol.getCompatibleProtocol(this._proxy.__reference().getProtocol()));
                this.__invokeImpl(true); // userThread = true
            },
        });
        
        var ProxyGetConnection = Ice.Class(ProxyOutgoingAsyncBase, {
            __init__ : function(prx, operation)
            {
                ProxyOutgoingAsyncBase.call(this, prx, operation);
            },
            __invokeRemote: function(connection, compress, response)
            {
                this.__markFinished(true,
                                    function(r)
                                    {
                                        r.succeed(connection);
                                    });
                return AsyncStatus.Sent;
            },
            __invoke: function()
            {
                this.__invokeImpl(true); // userThread = true
            }
        });
        
        var ConnectionFlushBatch = Ice.Class(OutgoingAsyncBase, {
            __init__: function(con, communicator, operation)
            {
                OutgoingAsyncBase.call(this, communicator, operation, con, null, null);
            },
            __invoke: function()
            {
                try
                {
                    var batchRequestNum = this._connection.getBatchRequestQueue().swap(this._os);
                    var status;
                    if(batchRequestNum === 0)
                    {
                        this.__sent();
                        status = AsyncStatus.Sent;
                    }
                    else
                    {
                        status = this._connection.sendAsyncRequest(this, false, false, batchRequestNum);
                    }
        
                    if((status & AsyncStatus.Sent) > 0)
                    {
                        this._sentSynchronously = true;
                    }
                }
                catch(ex)
                {
                    this.__completedEx(ex);
                }
            }
        });
        
        Ice.OutgoingAsync = OutgoingAsync;
        Ice.ProxyFlushBatch = ProxyFlushBatch;
        Ice.ProxyGetConnection = ProxyGetConnection;
        Ice.ConnectionFlushBatch = ConnectionFlushBatch;
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var ArrayUtil = Ice.ArrayUtil;
        var AsyncResultBase = Ice.AsyncResultBase;
        var AsyncResult = Ice.AsyncResult;
        var Debug = Ice.Debug;
        var FormatType = Ice.FormatType;
        var HashMap = Ice.HashMap;
        var OutgoingAsync = Ice.OutgoingAsync;
        var ProxyFlushBatch = Ice.ProxyFlushBatch;
        var ProxyGetConnection = Ice.ProxyGetConnection;
        var RefMode = Ice.ReferenceMode;
        var OperationMode = Ice.OperationMode;
        
        //
        // Ice.ObjectPrx
        //
        var ObjectPrx = Ice.Class({
            __init__: function()
            {
                this._reference = null;
                this._requestHandler = null;
            },
            hashCode: function(r)
            {
                return this._reference.hashCode();
            },
            ice_getCommunicator: function()
            {
                return this._reference.getCommunicator();
            },
            toString: function()
            {
                return this._reference.toString();
            },
            ice_getIdentity: function()
            {
                return this._reference.getIdentity().clone();
            },
            ice_identity: function(newIdentity)
            {
                if(newIdentity === undefined || newIdentity === null || newIdentity.name.length === 0)
                {
                    throw new Ice.IllegalIdentityException();
                }
                if(newIdentity.equals(this._reference.getIdentity()))
                {
                    return this;
                }
                else
                {
                    var proxy = new ObjectPrx();
                    proxy.__setup(this._reference.changeIdentity(newIdentity));
                    return proxy;
                }
            },
            ice_getContext: function()
            {
                return new HashMap(this._reference.getContext());
            },
            ice_context: function(newContext)
            {
                return this.__newInstance(this._reference.changeContext(newContext));
            },
            ice_getFacet: function()
            {
                return this._reference.getFacet();
            },
            ice_facet: function(newFacet)
            {
                if(newFacet === undefined || newFacet === null)
                {
                    newFacet = "";
                }
        
                if(newFacet === this._reference.getFacet())
                {
                    return this;
                }
                else
                {
                    var proxy = new ObjectPrx();
                    proxy.__setup(this._reference.changeFacet(newFacet));
                    return proxy;
                }
            },
            ice_getAdapterId: function()
            {
                return this._reference.getAdapterId();
            },
            ice_adapterId: function(newAdapterId)
            {
                if(newAdapterId === undefined || newAdapterId === null)
                {
                    newAdapterId = "";
                }
        
                if(newAdapterId === this._reference.getAdapterId())
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeAdapterId(newAdapterId));
                }
            },
            ice_getEndpoints: function()
            {
                return ArrayUtil.clone(this._reference.getEndpoints());
            },
            ice_endpoints: function(newEndpoints)
            {
                if(newEndpoints === undefined || newEndpoints === null)
                {
                    newEndpoints = [];
                }
        
                if(ArrayUtil.equals(newEndpoints, this._reference.getEndpoints()))
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeEndpoints(newEndpoints));
                }
            },
            ice_getLocatorCacheTimeout: function()
            {
                return this._reference.getLocatorCacheTimeout();
            },
            ice_locatorCacheTimeout: function(newTimeout)
            {
                if(newTimeout < -1)
                {
                    throw new Error("invalid value passed to ice_locatorCacheTimeout: " + newTimeout);
                }
                if(newTimeout === this._reference.getLocatorCacheTimeout())
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeLocatorCacheTimeout(newTimeout));
                }
            },
            ice_getInvocationTimeout: function()
            {
                return this._reference.getInvocationTimeout();
            },
            ice_invocationTimeout: function(newTimeout)
            {
                if(newTimeout < 1 && newTimeout !== -1)
                {
                    throw new Error("invalid value passed to ice_invocationTimeout: " + newTimeout);
                }
                if(newTimeout === this._reference.getInvocationTimeout())
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeInvocationTimeout(newTimeout));
                }
            },
            ice_isConnectionCached: function()
            {
                return this._reference.getCacheConnection();
            },
            ice_connectionCached: function(newCache)
            {
                if(newCache === this._reference.getCacheConnection())
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeCacheConnection(newCache));
                }
            },
            ice_getEndpointSelection: function()
            {
                return this._reference.getEndpointSelection();
            },
            ice_endpointSelection: function(newType)
            {
                if(newType === this._reference.getEndpointSelection())
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeEndpointSelection(newType));
                }
            },
            ice_isSecure: function()
            {
                return this._reference.getSecure();
            },
            ice_secure: function(b)
            {
                if(b === this._reference.getSecure())
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeSecure(b));
                }
            },
            ice_getEncodingVersion: function()
            {
                return this._reference.getEncoding().clone();
            },
            ice_encodingVersion: function(e)
            {
                if(e.equals(this._reference.getEncoding()))
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeEncoding(e));
                }
            },
            ice_isPreferSecure: function()
            {
                return this._reference.getPreferSecure();
            },
            ice_preferSecure: function(b)
            {
                if(b === this._reference.getPreferSecure())
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changePreferSecure(b));
                }
            },
            ice_getRouter: function()
            {
                var ri = this._reference.getRouterInfo();
                return ri !== null ? ri.getRouter() : null;
            },
            ice_router: function(router)
            {
                var ref = this._reference.changeRouter(router);
                if(ref.equals(this._reference))
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(ref);
                }
            },
            ice_getLocator: function()
            {
                var ri = this._reference.getLocatorInfo();
                return ri !== null ? ri.getLocator() : null;
            },
            ice_locator: function(locator)
            {
                var ref = this._reference.changeLocator(locator);
                if(ref.equals(this._reference))
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(ref);
                }
            },
            ice_isTwoway: function()
            {
                return this._reference.getMode() === RefMode.ModeTwoway;
            },
            ice_twoway: function()
            {
                if(this._reference.getMode() === RefMode.ModeTwoway)
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeMode(RefMode.ModeTwoway));
                }
            },
            ice_isOneway: function()
            {
                return this._reference.getMode() === RefMode.ModeOneway;
            },
            ice_oneway: function()
            {
                if(this._reference.getMode() === RefMode.ModeOneway)
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeMode(RefMode.ModeOneway));
                }
            },
            ice_isBatchOneway: function()
            {
                return this._reference.getMode() === RefMode.ModeBatchOneway;
            },
            ice_batchOneway: function()
            {
                if(this._reference.getMode() === RefMode.ModeBatchOneway)
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeMode(RefMode.ModeBatchOneway));
                }
            },
            ice_isDatagram: function()
            {
                return this._reference.getMode() === RefMode.ModeDatagram;
            },
            ice_datagram: function()
            {
                if(this._reference.getMode() === RefMode.ModeDatagram)
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeMode(RefMode.ModeDatagram));
                }
            },
            ice_isBatchDatagram: function()
            {
                return this._reference.getMode() === RefMode.ModeBatchDatagram;
            },
            ice_batchDatagram: function()
            {
                if(this._reference.getMode() === RefMode.ModeBatchDatagram)
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(this._reference.changeMode(RefMode.ModeBatchDatagram));
                }
            },
            ice_compress: function(co)
            {
                var ref = this._reference.changeCompress(co);
                if(ref.equals(this._reference))
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(ref);
                }
            },
            ice_timeout: function(t)
            {
                if(t < 1 && t !== -1)
                {
                    throw new Error("invalid value passed to ice_timeout: " + t);
                }
                var ref = this._reference.changeTimeout(t);
                if(ref.equals(this._reference))
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(ref);
                }
            },
            ice_getConnectionId: function()
            {
                return this._reference.getConnectionId();
            },
            ice_connectionId: function(id)
            {
                var ref = this._reference.changeConnectionId(id);
                if(ref.equals(this._reference))
                {
                    return this;
                }
                else
                {
                    return this.__newInstance(ref);
                }
            },
            ice_getConnection: function()
            {
                var r = new ProxyGetConnection(this, "ice_getConnection");
                try
                {
                    r.__invoke();
                }
                catch(ex)
                {
                    r.__abort(ex);
                }
                return r;
            },
            ice_getCachedConnection: function()
            {
                return this._requestHandler ? this._requestHandler.getConnection() : null;
            },
            ice_flushBatchRequests: function()
            {
                var r = new ProxyFlushBatch(this, "ice_flushBatchRequests");
                try
                {
                    r.__invoke();
                }
                catch(ex)
                {
                    r.__abort(ex);
                }
                return r;
            },
            equals: function(r)
            {
                if(this === r)
                {
                    return true;
                }
        
                if(r instanceof ObjectPrx)
                {
                    return this._reference.equals(r._reference);
                }
        
                return false;
            },
            __reference: function()
            {
                return this._reference;
            },
            __copyFrom: function(from)
            {
                Debug.assert(this._reference === null);
                Debug.assert(this._requestHandler === null);
        
                this._reference = from._reference;
                this._requestHandler = from._requestHandler;
            },
            __handleException: function(ex, handler, mode, sent, sleep, cnt)
            {
                this.__updateRequestHandler(handler, null); // Clear the request handler
        
                //
                // We only retry local exception, system exceptions aren't retried.
                //
                // A CloseConnectionException indicates graceful server shutdown, and is therefore
                // always repeatable without violating "at-most-once". That's because by sending a
                // close connection message, the server guarantees that all outstanding requests
                // can safely be repeated.
                //
                // An ObjectNotExistException can always be retried as well without violating
                // "at-most-once" (see the implementation of the checkRetryAfterException method
                //  of the ProxyFactory class for the reasons why it can be useful).
                //
                // If the request didn't get sent or if it's non-mutating or idempotent it can
                // also always be retried if the retry count isn't reached.
                //
                if(ex instanceof Ice.LocalException &&
                   (!sent ||
                    mode == OperationMode.Nonmutating || mode == OperationMode.Idempotent ||
                    ex instanceof Ice.CloseConnectionException || ex instanceof Ice.ObjectNotExistException))
                {
                    try
                    {
                        return this._reference.getInstance().proxyFactory().checkRetryAfterException(ex,
                                                                                                     this._reference,
                                                                                                     sleep,
                                                                                                     cnt);
                    }
                    catch(exc)
                    {
                        if(exc instanceof Ice.CommunicatorDestroyedException)
                        {
                            //
                            // The communicator is already destroyed, so we cannot retry.
                            //
                            throw ex;
                        }
                        else
                        {
                            throw exc;
                        }
                    }
                }
                else
                {
                    throw ex;
                }
            },
            __checkAsyncTwowayOnly: function(name)
            {
                if(!this.ice_isTwoway())
                {
                    throw new Error("`" + name + "' can only be called with a twoway proxy");
                }
            },
            __getRequestHandler: function()
            {
                if(this._reference.getCacheConnection())
                {
                    if(this._requestHandler)
                    {
                        return this._requestHandler;
                    }
                }
                return this._reference.getRequestHandler(this);
            },
            __getBatchRequestQueue: function()
            {
                if(!this._batchRequestQueue)
                {
                    this._batchRequestQueue = this._reference.getBatchRequestQueue();
                }
                return this._batchRequestQueue;
            },
            __setRequestHandler: function(handler)
            {
                if(this._reference.getCacheConnection())
                {
                    if(!this._requestHandler)
                    {
                        this._requestHandler = handler;
                    }
                    return this._requestHandler;
                }
                return handler;
            },
            __updateRequestHandler: function(previous, handler)
            {
                if(this._reference.getCacheConnection() && previous !== null)
                {
                    if(this._requestHandler && this._requestHandler !== handler)
                    {
                        this._requestHandler = this._requestHandler.update(previous, handler);
                    }
                }
            },
            //
            // Only for use by IceInternal.ProxyFactory
            //
            __setup: function(ref)
            {
                Debug.assert(this._reference === null);
        
                this._reference = ref;
            },
            __newInstance: function(ref)
            {
                var proxy = new this.constructor();
                proxy.__setup(ref);
                return proxy;
            },
            ice_instanceof: function(T)
            {
                if(T)
                {
                    if(this instanceof T)
                    {
                        return true;
                    }
                    return this.constructor.__instanceof(T);
                }
                return false;
            }
        });
        
        //
        // Generic invocation for operations that have input parameters.
        //
        ObjectPrx.__invoke = function(p, name, mode, fmt, ctx, marshalFn, unmarshalFn, userEx, args)
        {
            if(unmarshalFn !== null || userEx.length > 0)
            {
                p.__checkAsyncTwowayOnly(name);
            }
        
            var __r = new OutgoingAsync(p, name,
                function(__res)
                {
                    ObjectPrx.__completed(__res, unmarshalFn, userEx);
                });
        
            try
            {
                __r.__prepare(name, mode, ctx);
                if(marshalFn === null)
                {
                    __r.__writeEmptyParams();
                }
                else
                {
                    var __os = __r.__startWriteParams(fmt);
                    marshalFn.call(null, __os, args);
                    __r.__endWriteParams();
                }
                __r.__invoke();
            }
            catch(ex)
            {
                __r.__abort(ex);
            }
            return __r;
        };
        
        //
        // Handles the completion of an invocation.
        //
        ObjectPrx.__completed = function(__r, unmarshalFn, userEx)
        {
            if(!ObjectPrx.__check(__r, userEx))
            {
                return;
            }
        
            try
            {
                if(unmarshalFn === null)
                {
                    __r.__readEmptyParams();
                    __r.succeed(__r);
                }
                else
                {
                    var results = unmarshalFn(__r);
                    __r.succeed.apply(__r, results);
                }
            }
            catch(ex)
            {
                ObjectPrx.__dispatchLocalException(__r, ex);
                return;
            }
        };
        
        //
        // Unmarshal callback for operations that return a bool as the only result.
        //
        ObjectPrx.__returns_bool = function(__is, __results)
        {
            __results.push(__is.readBool());
        };
        
        //
        // Unmarshal callback for operations that return a byte as the only result.
        //
        ObjectPrx.__returns_byte = function(__is, __results)
        {
            __results.push(__is.readByte());
        };
        
        //
        // Unmarshal callback for operations that return a short as the only result.
        //
        ObjectPrx.__returns_short = function(__is, __results)
        {
            __results.push(__is.readShort());
        };
        
        //
        // Unmarshal callback for operations that return an int as the only result.
        //
        ObjectPrx.__returns_int = function(__is, __results)
        {
            __results.push(__is.readInt());
        };
        
        //
        // Unmarshal callback for operations that return a long as the only result.
        //
        ObjectPrx.__returns_long = function(__is, __results)
        {
            __results.push(__is.readLong());
        };
        
        //
        // Unmarshal callback for operations that return a float as the only result.
        //
        ObjectPrx.__returns_float = function(__is, __results)
        {
            __results.push(__is.readFloat());
        };
        
        //
        // Unmarshal callback for operations that return a double as the only result.
        //
        ObjectPrx.__returns_double = function(__is, __results)
        {
            __results.push(__is.readDouble());
        };
        
        //
        // Unmarshal callback for operations that return a string as the only result.
        //
        ObjectPrx.__returns_string = function(__is, __results)
        {
            __results.push(__is.readString());
        };
        
        //
        // Unmarshal callback for operations that return a proxy as the only result.
        //
        ObjectPrx.__returns_ObjectPrx = function(__is, __results)
        {
            __results.push(__is.readProxy());
        };
        
        //
        // Unmarshal callback for operations that return an object as the only result.
        //
        ObjectPrx.__returns_Object = function(__is, __results)
        {
            __is.readObject(function(obj){ __results.push(obj); }, Ice.Object);
            __is.readPendingObjects();
        };
        
        //
        // Handles user exceptions.
        //
        ObjectPrx.__check = function(__r, __uex)
        {
            //
            // If __uex is non-null, it must be an array of exception types.
            //
            try
            {
                __r.__throwUserException();
            }
            catch(ex)
            {
                if(ex instanceof Ice.UserException)
                {
                    if(__uex !== null)
                    {
                        for(var i = 0; i < __uex.length; ++i)
                        {
                            if(ex instanceof __uex[i])
                            {
                                __r.fail(ex, __r);
                                return false;
                            }
                        }
                    }
                    __r.fail(new Ice.UnknownUserException(ex.ice_name()), __r);
                    return false;
                }
                else
                {
                    __r.fail(ex, __r);
                    return false;
                }
            }
        
            return true;
        };
        
        ObjectPrx.__dispatchLocalException = function(__r, __ex)
        {
            __r.fail(__ex, __r);
        };
        
        ObjectPrx.ice_staticId = Ice.Object.ice_staticId;
        
        ObjectPrx.checkedCast = function(prx, facet, ctx)
        {
            var __r = null;
        
            if(prx === undefined || prx === null)
            {
                __r = new AsyncResultBase(null, "checkedCast", null, null, null);
                __r.succeed(null, __r);
            }
            else
            {
                if(facet !== undefined)
                {
                    prx = prx.ice_facet(facet);
                }
        
                var self = this;
                __r = new AsyncResultBase(prx.ice_getCommunicator(), "checkedCast", null, prx, null);
                prx.ice_isA(this.ice_staticId(), ctx).then(
                    function(__res, __ret)
                    {
                        if(__ret)
                        {
                            var __h = new self();
                            __h.__copyFrom(prx);
                            __r.succeed(__h, __r);
                        }
                        else
                        {
                            __r.succeed(null, __r);
                        }
                    }).exception(
                        function(__ex)
                        {
                            if(__ex instanceof Ice.FacetNotExistException)
                            {
                                __r.succeed(null, __r);
                            }
                            else
                            {
                                __r.fail(__ex, __r);
                            }
                        });
            }
        
            return __r;
        };
        
        ObjectPrx.uncheckedCast = function(prx, facet)
        {
            var r = null;
            if(prx !== undefined && prx !== null)
            {
                r = new this();
                if(facet !== undefined)
                {
                    prx = prx.ice_facet(facet);
                }
                r.__copyFrom(prx);
            }
            return r;
        };
        
        Object.defineProperty(ObjectPrx, "minWireSize", {
            get: function(){ return 2; }
        });
        
        ObjectPrx.write = function(os, v)
        {
            os.writeProxy(v);
        };
        
        ObjectPrx.read = function(is)
        {
            return is.readProxy(this);
        };
        
        ObjectPrx.writeOpt = function(os, tag, v)
        {
            os.writeOptProxy(tag, v);
        };
        
        ObjectPrx.readOpt = function(is, tag)
        {
            return is.readOptProxy(tag, this);
        };
        
        ObjectPrx.__instanceof = function(T)
        {
            if(T === this)
            {
                return true;
            }
        
            for(var i in this.__implements)
            {
                if(this.__implements[i].__instanceof(T))
                {
                    return true;
                }
            }
        
            if(this.__parent)
            {
                return this.__parent.__instanceof(T);
            }
            return false;
        };
        
        var Slice = Ice.Slice;
        Slice.defineProxy = function(base, staticId, prxInterfaces)
        {
            var prx = function()
            {
                base.call(this);
            };
            prx.__parent = base;
            prx.__implements = prxInterfaces;
        
            // All generated proxies inherit from ObjectPrx
            prx.prototype = new base();
            prx.prototype.constructor = prx;
        
            // Static methods
            prx.ice_staticId = staticId;
        
            // Copy static methods inherited from ObjectPrx
            prx.checkedCast = ObjectPrx.checkedCast;
            prx.uncheckedCast = ObjectPrx.uncheckedCast;
            prx.write = ObjectPrx.write;
            prx.writeOpt = ObjectPrx.writeOpt;
            prx.read = ObjectPrx.read;
            prx.readOpt = ObjectPrx.readOpt;
        
            prx.__instanceof = ObjectPrx.__instanceof;
        
            // Static properties
            Object.defineProperty(prx, "minWireSize", {
                get: function(){ return 2; }
            });
        
            return prx;
        };
        
        Ice.ObjectPrx = ObjectPrx;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Endpoint.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            Object.defineProperty(Ice, 'TCPEndpointType', {
                value: 1
            });
        
            Object.defineProperty(Ice, 'SSLEndpointType', {
                value: 2
            });
        
            Object.defineProperty(Ice, 'UDPEndpointType', {
                value: 3
            });
        
            Object.defineProperty(Ice, 'WSEndpointType', {
                value: 4
            });
        
            Object.defineProperty(Ice, 'WSSEndpointType', {
                value: 5
            });
        
            /**
             * Base class providing access to the endpoint details.
             * 
             **/
            Ice.EndpointInfo = Slice.defineLocalObject(
                function(timeout, compress)
                {
                    this.timeout = timeout !== undefined ? timeout : 0;
                    this.compress = compress !== undefined ? compress : false;
                });
        
            /**
             * The user-level interface to an endpoint.
             * 
             **/
            Ice.Endpoint = Slice.defineLocalObject();
        
            /**
             * Provides access to the address details of a IP endpoint.
             * 
             * @see Endpoint
             * 
             **/
            Ice.IPEndpointInfo = Slice.defineLocalObject(
                function(timeout, compress, host, port, sourceAddress)
                {
                    Ice.EndpointInfo.call(this, timeout, compress);
                    this.host = host !== undefined ? host : "";
                    this.port = port !== undefined ? port : 0;
                    this.sourceAddress = sourceAddress !== undefined ? sourceAddress : "";
                },
                Ice.EndpointInfo);
        
            /**
             * Provides access to a TCP endpoint information.
             * 
             * @see Endpoint
             * 
             **/
            Ice.TCPEndpointInfo = Slice.defineLocalObject(
                function(timeout, compress, host, port, sourceAddress)
                {
                    Ice.IPEndpointInfo.call(this, timeout, compress, host, port, sourceAddress);
                },
                Ice.IPEndpointInfo);
        
            /**
             * Provides access to an UDP endpoint information.
             * 
             * @see Endpoint
             * 
             **/
            Ice.UDPEndpointInfo = Slice.defineLocalObject(
                function(timeout, compress, host, port, sourceAddress, mcastInterface, mcastTtl)
                {
                    Ice.IPEndpointInfo.call(this, timeout, compress, host, port, sourceAddress);
                    this.mcastInterface = mcastInterface !== undefined ? mcastInterface : "";
                    this.mcastTtl = mcastTtl !== undefined ? mcastTtl : 0;
                },
                Ice.IPEndpointInfo);
        
            /**
             * Provides access to a WebSocket endpoint information.
             * 
             **/
            Ice.WSEndpointInfo = Slice.defineLocalObject(
                function(timeout, compress, host, port, sourceAddress, resource)
                {
                    Ice.TCPEndpointInfo.call(this, timeout, compress, host, port, sourceAddress);
                    this.resource = resource !== undefined ? resource : "";
                },
                Ice.TCPEndpointInfo);
        
            /**
             * Provides access to the details of an opaque endpoint.
             * 
             * @see Endpoint
             * 
             **/
            Ice.OpaqueEndpointInfo = Slice.defineLocalObject(
                function(timeout, compress, rawEncoding, rawBytes)
                {
                    Ice.EndpointInfo.call(this, timeout, compress);
                    this.rawEncoding = rawEncoding !== undefined ? rawEncoding : new Ice.EncodingVersion();
                    this.rawBytes = rawBytes !== undefined ? rawBytes : null;
                },
                Ice.EndpointInfo);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Class = Ice.Class;
        
        var EndpointI = Class(Ice.Endpoint, {
            toString: function()
            {
                //
                // WARNING: Certain features, such as proxy validation in Glacier2,
                // depend on the format of proxy strings. Changes to toString() and
                // methods called to generate parts of the reference string could break
                // these features. Please review for all features that depend on the
                // format of proxyToString() before changing this and related code.
                //
                return this.protocol() + this.options();
            },
            initWithOptions: function(args)
            {
                var unknown = [];
        
                var i;
                var str = "`" + this.protocol();
                for(i = 0; i < args.length; ++i)
                {
                    if(args[i].search(/[ \t\n\r]+/) !== -1)
                    {
                        str += " \"" + args[i] + "\"";
                    }
                    else
                    {
                        str += " " + args[i];
                    }
                }
                str += "'";
        
                i = 0;
                while(i < args.length)
                {
                    var option = args[i++];
                    if(option.length < 2 || option.charAt(0) != '-')
                    {
                        unknown.push(option);
                        continue;
                    }
        
                    var argument = null;
                    if(i < args.length && args[i].charAt(0) != '-')
                    {
                        argument = args[i++];
                    }
        
                    if(!this.checkOption(option, argument, str))
                    {
                        unknown.push(option);
                        if(argument !== null)
                        {
                            unknown.push(argument);
                        }
                    }
                }
        
                args.length = 0;
                for(i = 0; i < unknown.length; i++)
                {
                    args.push(unknown[i]);
                }
            },
            //
            // Compare endpoints for sorting purposes
            //
            equals: function(p)
            {
                if(!(p instanceof EndpointI))
                {
                    return false;
                }
                return this.compareTo(p) === 0;
            },
            checkOption: function()
            {
                return false;
            }
        });
        
        Ice.EndpointI = EndpointI;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `ProcessF.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var __M = Ice.__M;
        
        var Class = Ice.Class;
        
        var builtinHelpers =
        [
            Ice.ByteHelper,
            Ice.BoolHelper,
            Ice.ShortHelper,
            Ice.IntHelper,
            Ice.LongHelper,
            Ice.FloatHelper,
            Ice.DoubleHelper,
            Ice.StringHelper,
            Ice.Object,
            Ice.ObjectPrx
        ];
        
        function parseParam(p)
        {
            var type = p[0];
            var t = typeof(type);
            if(t === 'number')
            {
                type = builtinHelpers[p[0]];
            }
            else if(t === 'string')
            {
                /*jshint -W061 */
                type = __M.type(type);
                /*jshint +W061 */
            }
        
            return {
                "type": type,
                "isObject": (p[1] === true),
                "tag": p[2] // Optional tag, which may not be present - an undefined tag means "not optional".
            };
        }
        
        //
        // Each operation descriptor is a property. The key is the "on-the-wire"
        // name, and the value is an array consisting of the following elements:
        //
        //  0: native method name in case of a keyword conflict (e.g., "_while"),
        //     otherwise an empty string
        //  1: mode (undefined == Normal or int)
        //  2: sendMode (undefined == Normal or int)
        //  3: amd (undefined or 1)
        //  4: format (undefined == Default or int)
        //  5: return type (undefined if void, or [type, tag])
        //  6: in params (undefined if none, or array of [type, tag])
        //  7: out params (undefined if none, or array of [type, tag])
        //  8: exceptions (undefined if none, or array of types)
        //  9: sends classes (true or undefined)
        // 10: returns classes (true or undefined)
        //
        function parseOperation(name, arr)
        {
            var r = {};
            var i;
            var p;
        
            r.name = name;
            r.mode = arr[1] ? Ice.OperationMode.valueOf(arr[1]) : Ice.OperationMode.Normal;
            r.sendMode = arr[2] ? Ice.OperationMode.valueOf(arr[2]) : Ice.OperationMode.Normal;
            r.amd = arr[3] ? true : false;
            r.format = arr[4] ? Ice.FormatType.valueOf(arr[4]) : Ice.FormatType.DefaultFormat;
        
            if(r.amd)
            {
                r.servantMethod = name + "_async";
            }
            else
            {
                r.servantMethod = arr[0] ? arr[0] : name;
            }
        
            var ret;
            if(arr[5])
            {
                ret = parseParam(arr[5]);
                ret.pos = 0;
            }
            r.returns = ret;
        
            var inParams = [];
            var inParamsOpt = [];
            if(arr[6])
            {
                for(i = 0; i < arr[6].length; ++i)
                {
                    p = parseParam(arr[6][i]);
                    p.pos = i;
                    inParams.push(p);
                    if(p.tag)
                    {
                        inParamsOpt.push(p);
                    }
                }
            }
            inParamsOpt.sort(function(p1, p2) { return p1.tag - p2.tag; }); // Sort by tag.
            r.inParams = inParams;
            r.inParamsOpt = inParamsOpt;
        
            var outParams = [];
            var outParamsOpt = [];
            if(arr[7])
            {
                var offs = ret ? 1 : 0;
                for(i = 0; i < arr[7].length; ++i)
                {
                    p = parseParam(arr[7][i]);
                    p.pos = i + offs;
                    outParams.push(p);
                    if(p.tag)
                    {
                        outParamsOpt.push(p);
                    }
                }
            }
            if(ret && ret.tag)
            {
                outParamsOpt.push(ret);
            }
            outParamsOpt.sort(function(p1, p2) { return p1.tag - p2.tag; }); // Sort by tag.
            r.outParams = outParams;
            r.outParamsOpt = outParamsOpt;
        
            var exceptions = [];
            if(arr[8])
            {
                for(i = 0; i < arr[8].length; ++i)
                {
                    exceptions.push(arr[8][i]);
                }
            }
            r.exceptions = exceptions;
        
            r.sendsClasses = arr[9] === true;
            r.returnsClasses = arr[10] === true;
        
            return r;
        }
        
        var OpTable = Class({
            __init__: function(ops)
            {
                this.raw = ops;
                this.parsed = {};
            },
            find: function(name)
            {
                //
                // Check if we've already parsed the operation.
                //
                var op = this.parsed[name];
                if(op === undefined && this.raw[name] !== undefined)
                {
                    //
                    // We haven't parsed it yet, but we found a match for the name, so parse it now.
                    //
                    op = parseOperation(name, this.raw[name]);
                    this.parsed[name] = op;
                }
                return op;
            }
        });
        
        function unmarshalParams(is, retvalInfo, allParamInfo, optParamInfo, usesClasses, params, offset)
        {
            var i, p, v;
            //
            // First read all required params.
            //
            for(i = 0; i < allParamInfo.length; ++i)
            {
                p = allParamInfo[i];
                if(!p.tag)
                {
                    v = p.type.read(is);
                    params[p.pos + offset] = v;
                }
            }
        
            //
            // Then read a required return value (if any).
            //
            if(retvalInfo)
            {
                v = retvalInfo.type.read(is);
                params[retvalInfo.pos + offset] = v;
            }
        
            //
            // Then read all optional params.
            //
            for(i = 0; i < optParamInfo.length; ++i)
            {
                p = optParamInfo[i];
                v = p.type.readOpt(is, p.tag);
                params[p.pos + offset] = v;
            }
        
            if(usesClasses)
            {
                is.readPendingObjects();
            }
        }
        
        function marshalParams(os, params, retvalInfo, paramInfo, optParamInfo, usesClasses)
        {
            var i, p;
        
            //
            // Write the required params.
            //
            for(i = 0; i < paramInfo.length; ++i)
            {
                p = paramInfo[i];
                if(!p.tag)
                {
                    p.type.write(os, params[p.pos]);
                }
            }
        
            //
            // retvalInfo should only be provided if there is a non-void required return value.
            //
            if(retvalInfo)
            {
                retvalInfo.type.write(os, params[retvalInfo.pos]);
            }
        
            //
            // Write the optional params.
            //
            for(i = 0; i < optParamInfo.length; ++i)
            {
                p = optParamInfo[i];
                p.type.writeOpt(os, p.tag, params[p.pos]);
            }
        
            if(usesClasses)
            {
                os.writePendingObjects();
            }
        }
        
        var Upcall = Class({
            __init__: function(incomingAsync, op)
            {
                this.incomingAsync = incomingAsync;
                this.op = op;
            },
            ice_response: function()
            {
                var args = arguments;
        
                if(this.incomingAsync.__validateResponse(true))
                {
                    try
                    {
                        this.__sendResponse(args);
                        this.incomingAsync.__response();
                    }
                    catch(ex)
                    {
                        this.incomingAsync.__exception(ex);
                    }
                }
            },
            ice_exception: function(ex)
            {
                if(this.__checkException(ex))
                {
                    if(this.incomingAsync.__validateResponse(false))
                    {
                        this.__sendException(ex);
                        this.incomingAsync.__response();
                    }
                }
                else
                {
                    this.incomingAsync.ice_exception(ex);
                }
            },
            __sendResponse: function(results)
            {
                if(this.op.returns === undefined && this.op.outParams.length === 0)
                {
                    if(results && results.length > 0)
                    {
                        //
                        // No results expected.
                        //
                        throw new Error("ice_response called with invalid arguments");
                    }
                    else
                    {
                        this.incomingAsync.__writeEmptyParams();
                    }
                }
                else
                {
                    var __os = this.incomingAsync.__startWriteParams(this.op.format);
                    var retvalInfo;
                    if(this.op.returns && !this.op.returns.tag)
                    {
                        retvalInfo = this.op.returns;
                    }
                    marshalParams(__os, results, retvalInfo, this.op.outParams, this.op.outParamsOpt,
                                    this.op.returnsClasses);
                    this.incomingAsync.__endWriteParams(true);
                }
            },
            __checkException: function(ex)
            {
                //
                // Make sure the given exception is an instance of one of the declared user exceptions
                // for this operation.
                //
                for(var i = 0; i < this.op.exceptions.length; ++i)
                {
                    if(ex instanceof this.op.exceptions[i])
                    {
                        //
                        // User exception is valid.
                        //
                        return true;
                    }
                }
        
                return false;
            },
            __sendException: function(ex)
            {
                //
                // User exception is valid, now marshal it.
                //
                this.incomingAsync.__writeUserException(ex, this.op.format);
            }
        });
        
        var __dispatchImpl = function(servant, op, incomingAsync, current)
        {
            //
            // Check to make sure the servant implements the operation.
            //
            var method = servant[op.servantMethod];
            if(method === undefined || typeof(method) !== "function")
            {
                var comm = current.adapter.getCommunicator();
                var msg = "servant for identity " + comm.identityToString(current.id) +
                    " does not define operation `" + op.servantMethod + "'";
                throw new Ice.UnknownException(msg);
            }
        
            var up = new Upcall(incomingAsync, op);
        
            try
            {
                //
                // Unmarshal the in params (if any).
                //
                var params = op.amd ? [null] : [];
                if(op.inParams.length === 0)
                {
                    incomingAsync.readEmptyParams();
                }
                else
                {
                    var __is = incomingAsync.startReadParams();
                    var offset = op.amd ? 1 : 0;
                    unmarshalParams(__is, undefined, op.inParams, op.inParamsOpt, op.sendsClasses, params, offset);
                    incomingAsync.endReadParams();
        
                    //
                    // When unmarshaling objects, the ObjectHelper returns a wrapper object
                    // and eventually stores the unmarshaled object into its "value" member.
                    // Here we scan the parameter array and replace the wrappers with the
                    // actual object references.
                    //
                    if(op.inParams.length > 0 && (op.sendsClasses || op.inParamsOpt.length > 0))
                    {
                        for(var i = 0; i < op.inParams.length; ++i)
                        {
                            var p = op.inParams[i];
                            //
                            // Optional parameters may be undefined.
                            //
                            if(p.isObject && params[p.pos + offset] !== undefined)
                            {
                                params[p.pos + offset] = params[p.pos + offset].value;
                            }
                        }
                    }
                }
        
                params.push(current);
        
                if(op.amd)
                {
                    params[0] = up; // The AMD callback object.
                    try
                    {
                        method.apply(servant, params);
                    }
                    catch(ex)
                    {
                        up.ice_exception(ex);
                    }
                    return Ice.DispatchStatus.DispatchAsync;
                }
                else
                {
                    //
                    // Determine how many out parameters to expect.
                    //
                    var numExpectedResults = op.outParams.length;
                    if(op.returns)
                    {
                        ++numExpectedResults;
                    }
        
                    var results = method.apply(servant, params);
        
                    //
                    // Complain if we expect more than out parameter and the servant doesn't return an array.
                    //
                    if(numExpectedResults > 1 && !(results instanceof Array))
                    {
                        throw new Ice.MarshalException("operation `" + op.servantMethod +
                                                       "' should return an array of length " + numExpectedResults);
                    }
                    else if(numExpectedResults === 1)
                    {
                        //
                        // Wrap a single out parameter in an array.
                        //
                        results = [results];
                    }
        
                    up.__sendResponse(results);
                    return Ice.DispatchStatus.DispatchOK;
                }
            }
            catch(ex)
            {
                if(up.__checkException(ex))
                {
                    up.__sendException(ex);
                    return Ice.DispatchStatus.DispatchUserException;
                }
                else
                {
                    throw ex;
                }
            }
        };
        
        function getServantMethodFromInterfaces(interfaces, methodName, all)
        {
            var method;
            for(var i = 0; method === undefined && i < interfaces.length; ++i)
            {
                var intf = interfaces[i];
                method = intf[methodName];
                if(method === undefined)
                {
                    if(all.indexOf(intf) === -1)
                    {
                        all.push(intf);
                    }
                    if(intf.__implements)
                    {
                        method = getServantMethodFromInterfaces(intf.__implements, methodName, all);
                    }
                }
            }
            return method;
        }
        
        var dispatchPrefix = "__op_";
        
        function getServantMethod(servantType, name)
        {
            //
            // The dispatch method is named __op_<Slice name> and is stored in the type (not the prototype).
            //
            var methodName = dispatchPrefix + name;
        
            //
            // First check the servant type.
            //
            var method = servantType[methodName];
        
            var allInterfaces;
        
            if(method === undefined)
            {
                allInterfaces = [];
        
                //
                // Now check the prototypes of the implemented interfaces.
                //
                var curr = servantType;
                while(curr && method === undefined)
                {
                    if(curr.__implements)
                    {
                        method = getServantMethodFromInterfaces(curr.__implements, methodName, allInterfaces);
                    }
                    curr = curr.__parent;
                }
        
                if(method !== undefined)
                {
                    //
                    // Add the method to the servant's type.
                    //
                    servantType[methodName] = method;
                }
            }
        
            if(method === undefined)
            {
                //
                // Next check the op table for the servant's type.
                //
                var op;
                if(servantType.__ops)
                {
                    op = servantType.__ops.find(name);
                }
        
                var source;
                if(op === undefined)
                {
                    //
                    // Now check the op tables of the base types.
                    //
                    var parent = servantType.__parent;
                    while(op === undefined && parent)
                    {
                        if(parent.__ops)
                        {
                            if((op = parent.__ops.find(name)) !== undefined)
                            {
                                source = parent;
                            }
                        }
                        parent = parent.__parent;
                    }
        
                    //
                    // Now check the op tables of all base interfaces.
                    //
                    for(var i = 0; op === undefined && i < allInterfaces.length; ++i)
                    {
                        var intf = allInterfaces[i];
                        if(intf.__ops)
                        {
                            if((op = intf.__ops.find(name)) !== undefined)
                            {
                                source = intf;
                            }
                        }
                    }
                }
        
                if(op !== undefined)
                {
                    method = function(servant, incomingAsync, current)
                    {
                        return __dispatchImpl(servant, op, incomingAsync, current);
                    };
        
                    //
                    // Add the method to the servant type.
                    //
                    servantType[methodName] = method;
        
                    //
                    // Also add the method to the type in which the operation was found.
                    //
                    if(source)
                    {
                        source[methodName] = method;
                    }
                }
            }
        
            return method;
        }
        
        function addProxyOperation(proxyType, name, data)
        {
            var method = data[0] ? data[0] : name;
        
            var op = null;
        
            proxyType.prototype[method] = function()
            {
                var args = arguments;
        
                //
                // Parse the operation data on the first invocation of a proxy method.
                //
                if(op === null)
                {
                    op = parseOperation(name, data);
                }
        
                var ctx = args[op.inParams.length]; // The request context is the last argument (if present).
        
                var marshalFn = null;
                if(op.inParams.length > 0)
                {
                    marshalFn = function(os, params)
                    {
                        var i, p, v;
        
                        //
                        // Validate the parameters.
                        //
                        for(i = 0; i < op.inParams.length; ++i)
                        {
                            p = op.inParams[i];
                            v = params[p.pos];
                            if(!p.tag || v !== undefined)
                            {
                                if(typeof p.type.validate === "function")
                                {
                                    if(!p.type.validate(v))
                                    {
                                        throw new Ice.MarshalException("invalid value for argument " + (i + 1)  +
                                                                       " in operation `" + op.servantMethod + "'");
                                    }
                                }
                            }
                        }
        
                        marshalParams(os, params, undefined, op.inParams, op.inParamsOpt, op.sendsClasses);
                    };
                }
        
                var unmarshalFn = null;
                if(op.returns || op.outParams.length > 0)
                {
                    unmarshalFn = function(asyncResult)
                    {
                        //
                        // The results array holds the out parameters in the following format:
                        //
                        // [retval, out1, out2, ..., asyncResult]
                        //
                        var results = [];
        
                        var is = asyncResult.__startReadParams();
        
                        var retvalInfo;
                        if(op.returns && !op.returns.tag)
                        {
                            retvalInfo = op.returns;
                        }
                        unmarshalParams(is, retvalInfo, op.outParams, op.outParamsOpt, op.returnsClasses, results, 0);
        
                        asyncResult.__endReadParams();
        
                        //
                        // When unmarshaling objects, the ObjectHelper returns a wrapper object
                        // and eventually stores the unmarshaled object into its "value" member.
                        // Here we scan the results array and replace the wrappers with the
                        // actual object references.
                        //
                        if(op.returnsClasses || op.outParamsOpt.length > 0)
                        {
                            var offset = 0; // Skip asyncResult in results.
                            if(op.returns && op.returns.isObject && results[op.returns.pos + offset] !== undefined)
                            {
                                results[op.returns.pos + offset] = results[op.returns.pos + offset].value;
                            }
                            for(var i = 0; i < op.outParams.length; ++i)
                            {
                                var p = op.outParams[i];
                                //
                                // Optional parameters may be undefined.
                                //
                                if(p.isObject && results[p.pos + offset] !== undefined)
                                {
                                    results[p.pos + offset] = results[p.pos + offset].value;
                                }
                            }
                        }
                        results.push(asyncResult);
                        return results;
                    };
                }
        
                return Ice.ObjectPrx.__invoke(this, op.name, op.sendMode, op.format, ctx, marshalFn, unmarshalFn,
                                                op.exceptions, Array.prototype.slice.call(args));
            };
        }
        
        var Slice = Ice.Slice;
        Slice.defineOperations = function(classType, proxyType, ops)
        {
            if(ops)
            {
                classType.__ops = new OpTable(ops);
            }
        
            classType.prototype.__dispatch = function(incomingAsync, current)
            {
                //
                // Retrieve the dispatch method for this operation.
                //
                var method = getServantMethod(classType, current.operation);
        
                if(method === undefined || typeof(method) !== 'function')
                {
                    throw new Ice.OperationNotExistException(current.id, current.facet, current.operation);
                }
        
                return method.call(method, this, incomingAsync, current);
            };
        
            if(ops)
            {
                for(var name in ops)
                {
                    addProxyOperation(proxyType, name, ops[name]);
                }
            }
        
            //
            // Copy proxy methods from super-interfaces.
            //
            if(proxyType.__implements)
            {
                for(var intf in proxyType.__implements)
                {
                    var proto = proxyType.__implements[intf].prototype;
                    for(var f in proto)
                    {
                        if(typeof proto[f] == "function" && proxyType.prototype[f] === undefined)
                        {
                            proxyType.prototype[f] = proto[f];
                        }
                    }
                }
            }
        };
        
        //
        // Define the "built-in" operations for all Ice objects.
        //
        Slice.defineOperations(Ice.Object, Ice.ObjectPrx,
        {
            "ice_ping": [, 1, 1, , , , , , ],
            "ice_isA": [, 1, 1, , , [1], [[7]], , ],
            "ice_id": [, 1, 1, , , [7], , , ],
            "ice_ids": [, 1, 1, , , ["Ice.StringSeqHelper"], , , ]
        });
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Address = Ice.Address;
        var HashUtil = Ice.HashUtil;
        var StringUtil = Ice.StringUtil;
        var Class = Ice.Class;
        var EndpointParseException = Ice.EndpointParseException;
        
        var IPEndpointI = Class(Ice.EndpointI, {
            __init__: function(instance, ho, po, sa, conId)
            {
                this._instance = instance;
                this._host = ho === undefined ? null : ho;
                this._port = po === undefined ? null : po;
                this._sourceAddr = sa === undefined ? null : sa;
                this._connectionId = conId === undefined ? "" : conId;
            },
            //
            // Marshal the endpoint
            //
            streamWrite: function(s)
            {
                s.startWriteEncaps();
                this.streamWriteImpl(s);
                s.endWriteEncaps();
            },
            getInfo: function()
            {
                var info = new Ice.IPEndpointInfo();
                this.fillEndpointInfo(info);
                return info;
            },
            //
            // Return the endpoint type
            //
            type: function()
            {
                return this._instance.type();
            },
            //
            // Return the protocol string
            //
            protocol: function()
            {
                return this._instance.protocol();
            },
            //
            // Return true if the endpoint is secure.
            //
            secure: function()
            {
                return this._instance.secure();
            },
            connectionId: function()
            {
                return this._connectionId;
            },
            //
            // Return a new endpoint with a different connection id.
            //
            changeConnectionId: function(connectionId)
            {
                if(connectionId === this._connectionId)
                {
                    return this;
                }
                else
                {
                    return this.createEndpoint(this._host, this._port, connectionId);
                }
            },
            //
            // Return the endpoint information.
            //
            hashCode: function()
            {
                if(this._hashCode === undefined)
                {
                    this._hashCode = this.hashInit(5381);
                }
                return this._hashCode;
            },
            options: function()
            {
                //
                // WARNING: Certain features, such as proxy validation in Glacier2,
                // depend on the format of proxy strings. Changes to toString() and
                // methods called to generate parts of the reference string could break
                // these features. Please review for all features that depend on the
                // format of proxyToString() before changing this and related code.
                //
                var s = "";
        
                if(this._host !== null && this._host.length > 0)
                {
                    s += " -h ";
                    var addQuote = this._host.indexOf(':') != -1;
                    if(addQuote)
                    {
                        s += "\"";
                    }
                    s += this._host;
                    if(addQuote)
                    {
                        s += "\"";
                    }
                }
        
                s += " -p " + this._port;
        
                if(this._sourceAddr !== null && this._sourceAddr.length > 0)
                {
                    s += " --sourceAddr " + this._sourceAddr;
                }
                return s;
            },
            compareTo: function(p)
            {
                if(this === p)
                {
                    return 0;
                }
        
                if(p === null)
                {
                    return 1;
                }
        
                if(!(p instanceof IPEndpointI))
                {
                    return this.type() < p.type() ? -1 : 1;
                }
        
                if(this._port < p._port)
                {
                    return -1;
                }
                else if(p._port < this._port)
                {
                    return 1;
                }
        
                if(this._host != p._host)
                {
                    return this._host < p._host ? -1 : 1;
                }
        
                if(this._sourceAddr != p._sourceAddr)
                {
                    return this._sourceAddr < p._sourceAddr ? -1 : 1;
                }
        
                if(this._connectionId != p._connectionId)
                {
                    return this._connectionId < p._connectionId ? -1 : 1;
                }
        
                return 0;
            },
            getAddress: function()
            {
                return new Address(this._host, this._port);
            },
            //
            // Convert the endpoint to its Connector string form
            //
            toConnectorString: function()
            {
                return this._host + ":" + this._port;
            },
            streamWriteImpl: function(s)
            {
                s.writeString(this._host);
                s.writeInt(this._port);
            },
            hashInit: function(h)
            {
                h = HashUtil.addNumber(h, this.type());
                h = HashUtil.addString(h, this._host);
                h = HashUtil.addNumber(h, this._port);
                h = HashUtil.addString(h, this._sourceAddr);
                h = HashUtil.addString(h, this._connectionId);
                return h;
            },
            fillEndpointInfo: function(info)
            {
                var self = this;
                info.type = function() { return self.type(); };
                info.datagram = function() { return self.datagram(); };
                info.secure = function() { return self.secure(); };
                info.host = this._host;
                info.port = this._port;
                info.sourceAddress = this._sourceAddr;
            },
            initWithOptions: function(args, oaEndpoint)
            {
                Ice.EndpointI.prototype.initWithOptions.call(this, args);
        
                if(this._host === null || this._host.length === 0)
                {
                    this._host = this._instance.defaultHost();
                }
                else if(this._host == "*")
                {
                    if(oaEndpoint)
                    {
                        this._host = "";
                    }
                    else
                    {
                        throw new EndpointParseException("`-h *' not valid for proxy endpoint `" + this + "'");
                    }
                }
        
                if(this._host === null)
                {
                    this._host = "";
                }
        
                if(this._sourceAddr === null)
                {
                    if(!oaEndpoint)
                    {
                        this._sourceAddr = this._instance.defaultSourceAddress();
                    }
                }
                else if(oaEndpoint)
                {
                    throw new EndpointParseException("`--sourceAddress not valid for object adapter endpoint `" + this + "'");
                }
            },
            initWithStream: function(s)
            {
                this._host = s.readString();
                this._port = s.readInt();
            },
            checkOption: function(option, argument, str)
            {
                if(option === "-h")
                {
                    if(argument === null)
                    {
                        throw new EndpointParseException("no argument provided for -h option in endpoint " + str);
                    }
        
                    this._host = argument;
                }
                else if(option === "-p")
                {
                    if(argument === null)
                    {
                        throw new EndpointParseException("no argument provided for -p option in endpoint " + str);
                    }
        
                    try
                    {
                        this._port = StringUtil.toInt(argument);
                    }
                    catch(ex)
                    {
                        throw new EndpointParseException("invalid port value `" + argument + "' in endpoint " + str);
                    }
        
                    if(this._port < 0 || this._port > 65535)
                    {
                        throw new EndpointParseException("port value `" + argument + "' out of range in endpoint " + str);
                    }
                }
                else if(option === "--sourceAddress")
                {
                    if(argument === null)
                    {
                        throw new EndpointParseException("no argument provided for --sourceAddress option in endpoint " + str);
                    }
        
                    this._sourceAddr = argument;
                }
                else
                {
                    return false;
                }
                return true;
            }
        });
        
        Ice.IPEndpointI = IPEndpointI;
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `EndpointInfo.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            Object.defineProperty(IceSSL, 'EndpointType', {
                value: Ice.SSLEndpointType
            });
        
            /**
             * Provides access to an SSL endpoint information.
             * 
             **/
            IceSSL.EndpointInfo = Slice.defineLocalObject(
                function(timeout, compress, host, port, sourceAddress)
                {
                    Ice.IPEndpointInfo.call(this, timeout, compress, host, port, sourceAddress);
                },
                Ice.IPEndpointInfo);
        
            /**
             * Provides access to a secure WebSocket endpoint information.
             * 
             **/
            IceSSL.WSSEndpointInfo = Slice.defineLocalObject(
                function(timeout, compress, host, port, sourceAddress, resource)
                {
                    IceSSL.EndpointInfo.call(this, timeout, compress, host, port, sourceAddress);
                    this.resource = resource !== undefined ? resource : "";
                },
                IceSSL.EndpointInfo);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Connection.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * Base class providing access to the connection details. *
             **/
            Ice.ConnectionInfo = Slice.defineLocalObject(
                function(incoming, adapterName, connectionId, rcvSize, sndSize)
                {
                    this.incoming = incoming !== undefined ? incoming : false;
                    this.adapterName = adapterName !== undefined ? adapterName : "";
                    this.connectionId = connectionId !== undefined ? connectionId : "";
                    this.rcvSize = rcvSize !== undefined ? rcvSize : 0;
                    this.sndSize = sndSize !== undefined ? sndSize : 0;
                });
        
            /**
             * An application can implement this interface to receive notifications when
             * a connection closes or receives a heartbeat message.
             * 
             * @see Connection#setCallback
             * 
             **/
            Ice.ConnectionCallback = Slice.defineLocalObject();
        
            Ice.ACMClose = Slice.defineEnum([
                ['CloseOff', 0], ['CloseOnIdle', 1], ['CloseOnInvocation', 2], ['CloseOnInvocationAndIdle', 3], ['CloseOnIdleForceful', 4]]);
        
            Ice.ACMHeartbeat = Slice.defineEnum([
                ['HeartbeatOff', 0], ['HeartbeatOnInvocation', 1], ['HeartbeatOnIdle', 2], ['HeartbeatAlways', 3]]);
        
            Ice.ACM = Slice.defineStruct(
                function(timeout, close, heartbeat)
                {
                    this.timeout = timeout !== undefined ? timeout : 0;
                    this.close = close !== undefined ? close : Ice.ACMClose.CloseOff;
                    this.heartbeat = heartbeat !== undefined ? heartbeat : Ice.ACMHeartbeat.HeartbeatOff;
                },
                true);
        
            /**
             * The user-level interface to a connection.
             * 
             **/
            Ice.Connection = Slice.defineLocalObject();
        
            /**
             * Provides access to the connection details of an IP connection
             * 
             **/
            Ice.IPConnectionInfo = Slice.defineLocalObject(
                function(incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort)
                {
                    Ice.ConnectionInfo.call(this, incoming, adapterName, connectionId, rcvSize, sndSize);
                    this.localAddress = localAddress !== undefined ? localAddress : "";
                    this.localPort = localPort !== undefined ? localPort : -1;
                    this.remoteAddress = remoteAddress !== undefined ? remoteAddress : "";
                    this.remotePort = remotePort !== undefined ? remotePort : -1;
                },
                Ice.ConnectionInfo);
        
            /**
             * Provides access to the connection details of a TCP connection
             * 
             **/
            Ice.TCPConnectionInfo = Slice.defineLocalObject(
                function(incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort)
                {
                    Ice.IPConnectionInfo.call(this, incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort);
                },
                Ice.IPConnectionInfo);
        
            /**
             * Provides access to the connection details of a UDP connection
             * 
             **/
            Ice.UDPConnectionInfo = Slice.defineLocalObject(
                function(incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort, mcastAddress, mcastPort)
                {
                    Ice.IPConnectionInfo.call(this, incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort);
                    this.mcastAddress = mcastAddress !== undefined ? mcastAddress : "";
                    this.mcastPort = mcastPort !== undefined ? mcastPort : -1;
                },
                Ice.IPConnectionInfo);
            Slice.defineDictionary(Ice, "HeaderDict", "HeaderDictHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);
        
            /**
             * Provides access to the connection details of a WebSocket connection
             * 
             **/
            Ice.WSConnectionInfo = Slice.defineLocalObject(
                function(incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort, headers)
                {
                    Ice.TCPConnectionInfo.call(this, incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort);
                    this.headers = headers !== undefined ? headers : null;
                },
                Ice.TCPConnectionInfo);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        Ice.TraceLevels = function(properties)
        {
            var networkCat = "Network";
            var protocolCat = "Protocol";
            var retryCat = "Retry";
            var locationCat = "Locator";
            var slicingCat = "Slicing";
        
            var keyBase = "Ice.Trace.";
        
            var network = properties.getPropertyAsInt(keyBase + networkCat);
            var protocol = properties.getPropertyAsInt(keyBase + protocolCat);
            var retry = properties.getPropertyAsInt(keyBase + retryCat);
            var location = properties.getPropertyAsInt(keyBase + locationCat);
            var slicing = properties.getPropertyAsInt(keyBase + slicingCat);
            properties.getPropertyAsInt(keyBase + "ThreadPool"); // Avoid an "unused property" warning.
        
            return Object.create(null, {
                'network': {
                    get: function() { return network; }
                },
                'networkCat': {
                    get: function() { return networkCat; }
                },
                'protocol': {
                    get: function() { return protocol; }
                },
                'protocolCat': {
                    get: function() { return protocolCat; }
                },
                'retry': {
                    get: function() { return retry; }
                },
                'retryCat': {
                    get: function() { return retryCat; }
                },
                'location': {
                    get: function() { return location; }
                },
                'locationCat': {
                    get: function() { return locationCat; }
                },
                'slicing': {
                    get: function() { return slicing; }
                },
                'slicingCat': {
                    get: function() { return slicingCat; }
                }
            });
        };
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Base64 = Ice.Base64;
        var Debug = Ice.Debug;
        var HashUtil = Ice.HashUtil;
        var Protocol = Ice.Protocol;
        var StringUtil = Ice.StringUtil;
        var EndpointParseException = Ice.EndpointParseException;
        
        var Class = Ice.Class;
        
        var OpaqueEndpointI = Class(Ice.EndpointI, {
            __init__: function(type)
            {
                this._rawEncoding = Ice.Encoding_1_0;
                this._type = type === undefined ? -1 : type;
                this._rawBytes = null;
            },
            //
            // Marshal the endpoint
            //
            streamWrite: function(s)
            {
                s.startWriteEncaps(this._rawEncoding, Ice.FormatType.DefaultFormat);
                s.writeBlob(this._rawBytes);
                s.endWriteEncaps();
            },
            //
            // Return the endpoint information.
            //
            getInfo: function()
            {
                return new OpaqueEndpointInfoI(-1, false, this._rawEncoding, this._rawBytes, this._type);
            },
            //
            // Return the endpoint type
            //
            type: function()
            {
                return this._type;
            },
            protocol: function()
            {
                return "opaque";
            },
            //
            // Return the timeout for the endpoint in milliseconds. 0 means
            // non-blocking, -1 means no timeout.
            //
            timeout: function()
            {
                return -1;
            },
            //
            // Return a new endpoint with a different timeout value, provided
            // that timeouts are supported by the endpoint. Otherwise the same
            // endpoint is returned.
            //
            changeTimeout: function(t)
            {
                return this;
            },
            //
            // Return a new endpoint with a different connection id.
            //
            changeConnectionId: function(connectionId)
            {
                return this;
            },
            //
            // Return true if the endpoints support bzip2 compress, or false
            // otherwise.
            //
            compress: function()
            {
                return false;
            },
            //
            // Return a new endpoint with a different compression value,
            // provided that compression is supported by the
            // endpoint. Otherwise the same endpoint is returned.
            //
            changeCompress: function(compress)
            {
                return this;
            },
            //
            // Return true if the endpoint is datagram-based.
            //
            datagram: function()
            {
                return false;
            },
            //
            // Return true if the endpoint is secure.
            //
            secure: function()
            {
                return false;
            },
            //
            // Get the encoded endpoint.
            //
            rawBytes: function()
            {
                return this._rawBytes; // Returns a Uint8Array
            },
            //
            // Return a server side transceiver for this endpoint, or null if a
            // transceiver can only be created by an acceptor. In case a
            // transceiver is created, this operation also returns a new
            // "effective" endpoint, which might differ from this endpoint,
            // for example, if a dynamic port number is assigned.
            //
            transceiver: function(endpoint)
            {
                endpoint.value = null;
                return null;
            },
            //
            // Return an acceptor for this endpoint, or null if no acceptors
            // is available. In case an acceptor is created, this operation
            // also returns a new "effective" endpoint, which might differ
            // from this endpoint, for example, if a dynamic port number is
            // assigned.
            //
            acceptor: function(endpoint, adapterName)
            {
                endpoint.value = this;
                return null;
            },
            connect: function()
            {
                return null;
            },
            hashCode: function()
            {
                if(this._hashCode === undefined)
                {
                    var h = 5381;
                    h = HashUtil.addNumber(h, this._type);
                    h = HashUtil.addHashable(h, this._rawEncoding);
                    h = HashUtil.addArray(h, this._rawBytes, HashUtil.addNumber);
                    this._hashCode = h;
                }
                return this._hashCode;
            },
            options: function()
            {
                var s = "";
                s+= " -t " + this._type;
                s += " -e " + Ice.encodingVersionToString(this._rawEncoding);
                s += " -v " + Base64.encode(this._rawBytes);
                return s;
            },
            //
            // Compare endpoints for sorting purposes
            //
            equals: function(p)
            {
                if(!(p instanceof OpaqueEndpointI))
                {
                    return false;
                }
        
                if(this === p)
                {
                    return true;
                }
        
                if(this._type !== p._type)
                {
                    return false;
                }
        
                if(!this._rawEncoding.equals(p._rawEncoding))
                {
                    return false;
                }
        
                if(this._rawBytes.length !== p._rawBytes.length)
                {
                    return false;
                }
                for(var i = 0; i < this._rawBytes.length; i++)
                {
                    if(this._rawBytes[i] !== p._rawBytes[i])
                    {
                        return false;
                    }
                }
        
                return true;
            },
            compareTo: function(p)
            {
                if(this === p)
                {
                    return 0;
                }
        
                if(p === null)
                {
                    return 1;
                }
        
                if(!(p instanceof OpaqueEndpointI))
                {
                    return this.type() < p.type() ? -1 : 1;
                }
        
                if(this._type < p._type)
                {
                    return -1;
                }
                else if(p._type < this._type)
                {
                    return 1;
                }
        
                if(this._rawEncoding.major < p._rawEncoding.major)
                {
                    return -1;
                }
                else if(p._rawEncoding.major < this._rawEncoding.major)
                {
                    return 1;
                }
        
                if(this._rawEncoding.minor < p._rawEncoding.minor)
                {
                    return -1;
                }
                else if(p._rawEncoding.minor < this._rawEncoding.minor)
                {
                    return 1;
                }
        
                if(this._rawBytes.length < p._rawBytes.length)
                {
                    return -1;
                }
                else if(p._rawBytes.length < this._rawBytes.length)
                {
                    return 1;
                }
                for(var i = 0; i < this._rawBytes.length; i++)
                {
                    if(this._rawBytes[i] < p._rawBytes[i])
                    {
                        return -1;
                    }
                    else if(p._rawBytes[i] < this._rawBytes[i])
                    {
                        return 1;
                    }
                }
        
                return 0;
            },
            checkOption: function(option, argument, endpoint)
            {
                switch(option.charAt(1))
                {
                    case 't':
                    {
                        if(this._type > -1)
                        {
                            throw new EndpointParseException("multiple -t options in endpoint " + endpoint);
                        }
                        if(argument === null)
                        {
                            throw new EndpointParseException("no argument provided for -t option in endpoint " + endpoint);
                        }
        
                        var type;
        
                        try
                        {
                            type = StringUtil.toInt(argument);
                        }
                        catch(ex)
                        {
                            throw new EndpointParseException("invalid type value `" + argument + "' in endpoint " + endpoint);
                        }
        
                        if(type < 0 || type > 65535)
                        {
                            throw new EndpointParseException("type value `" + argument + "' out of range in endpoint " +
                                                             endpoint);
                        }
        
                        this._type = type;
                        return true;
                    }
        
                    case 'v':
                    {
                        if(this._rawBytes)
                        {
                            throw new EndpointParseException("multiple -v options in endpoint " + endpoint);
                        }
                        if(argument === null || argument.length === 0)
                        {
                            throw new EndpointParseException("no argument provided for -v option in endpoint " + endpoint);
                        }
                        for(var j = 0; j < argument.length; ++j)
                        {
                            if(!Base64.isBase64(argument.charAt(j)))
                            {
                                throw new EndpointParseException("invalid base64 character `" + argument.charAt(j) +
                                                                    "' (ordinal " + argument.charCodeAt(j) +
                                                                    ") in endpoint " + endpoint);
                            }
                        }
                        this._rawBytes = Base64.decode(argument);
                        return true;
                    }
        
                    case 'e':
                    {
                        if(argument === null)
                        {
                            throw new EndpointParseException("no argument provided for -e option in endpoint " + endpoint);
                        }
                        try
                        {
                            this._rawEncoding = Ice.stringToEncodingVersion(argument);
                        }
                        catch(e)
                        {
                            throw new EndpointParseException("invalid encoding version `" + argument +
                                                             "' in endpoint " + endpoint + ":\n" + e.str);
                        }
                        return true;
                    }
        
                    default:
                    {
                        return false;
                    }
                }
            },
            initWithOptions: function(args)
            {
                Ice.EndpointI.prototype.initWithOptions.call(this, args);
                Debug.assert(this._rawEncoding);
        
                if(this._type < 0)
                {
                    throw new EndpointParseException("no -t option in endpoint `" + this + "'");
                }
                if(this._rawBytes === null || this._rawBytes.length === 0)
                {
                    throw new EndpointParseException("no -v option in endpoint `" + this + "'");
                }
            },
            initWithStream: function(s)
            {
                this._rawEncoding = s.getReadEncoding();
                var sz = s.getReadEncapsSize();
                this._rawBytes = s.readBlob(sz);
            }
        });
        
        var OpaqueEndpointInfoI = Class(Ice.OpaqueEndpointInfo, {
            __init__: function(timeout, compress, rawEncoding, rawBytes, type)
            {
                Ice.OpaqueEndpointInfo.call(this, -1, false, rawEncoding, rawBytes);
                this._type = type;
            },
            type: function()
            {
                return this._type;
            },
            datagram: function()
            {
                return false;
            },
            secure: function()
            {
                return false;
            }
        });
        
        Ice.OpaqueEndpointI = OpaqueEndpointI;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var BasicStream = Ice.BasicStream;
        var Current = Ice.Current;
        var Debug = Ice.Debug;
        var FormatType = Ice.FormatType;
        var Context = Ice.Context;
        var Identity = Ice.Identity;
        var Protocol = Ice.Protocol;
        var StringUtil = Ice.StringUtil;
        
        var IncomingAsync = Ice.Class({
            __init__: function(instance, connection, adapter, response, compress, requestId)
            {
                this._instance = instance;
                this._response = response;
                this._compress = compress;
                if(this._response)
                {
                    this._os = new BasicStream(instance, Protocol.currentProtocolEncoding);
                }
                this._connection = connection;
        
                this._current = new Current();
                this._current.id = new Identity();
                this._current.adapter = adapter;
                this._current.con = this._connection;
                this._current.requestId = requestId;
        
                this._servant = null;
                this._locator = null;
                this._cookie = { value: null };
        
                //
                // Prepare the response if necessary.
                //
                if(response)
                {
                    this._os.writeBlob(Protocol.replyHdr);
        
                    //
                    // Add the request ID.
                    //
                    this._os.writeInt(requestId);
                }
        
                this._is = null;
        
                this._cb = null;
                this._active = true;
            },
            __startWriteParams: function(format)
            {
                if(!this._response)
                {
                    throw new Ice.MarshalException("can't marshal out parameters for oneway dispatch");
                }
        
                Debug.assert(this._os.size == Protocol.headerSize + 4); // Reply status position.
                Debug.assert(this._current.encoding !== null); // Encoding for reply is known.
                this._os.writeByte(0);
                this._os.startWriteEncaps(this._current.encoding, format);
                return this._os;
            },
            __endWriteParams: function(ok)
            {
                if(this._response)
                {
                    var save = this._os.pos;
                    this._os.pos = Protocol.headerSize + 4; // Reply status position.
                    this._os.writeByte(ok ? Protocol.replyOK : Protocol.replyUserException);
                    this._os.pos = save;
                    this._os.endWriteEncaps();
                }
            },
            __writeEmptyParams: function()
            {
                if(this._response)
                {
                    Debug.assert(this._os.size === Protocol.headerSize + 4); // Reply status position.
                    Debug.assert(this._current.encoding !== null); // Encoding for reply is known.
                    this._os.writeByte(Protocol.replyOK);
                    this._os.writeEmptyEncaps(this._current.encoding);
                }
            },
            __writeParamEncaps: function(v, ok)
            {
                if(this._response)
                {
                    Debug.assert(this._os.size === Protocol.headerSize + 4); // Reply status position.
                    Debug.assert(this._current.encoding !== null); // Encoding for reply is known.
                    this._os.writeByte(ok ? Protocol.replyOK : Protocol.replyUserException);
                    if(v === null || v.length === 0)
                    {
                        this._os.writeEmptyEncaps(this._current.encoding);
                    }
                    else
                    {
                        this._os.writeEncaps(v);
                    }
                }
            },
            __writeUserException: function(ex, format)
            {
                var os = this.__startWriteParams(format);
                os.writeUserException(ex);
                this.__endWriteParams(false);
            },
            __warning: function(ex)
            {
                Debug.assert(this._instance !== null);
        
                var s = [];
                s.push("dispatch exception:");
                s.push("\nidentity: " + this._instance.identityToString(this._current.id));
                s.push("\nfacet: " + StringUtil.escapeString(this._current.facet, ""));
                s.push("\noperation: " + this._current.operation);
                if(this._connection !== null)
                {
                    var connInfo = this._connection.getInfo();
                    if(connInfo instanceof Ice.IPConnectionInfo)
                    {
                        var ipConnInfo = connInfo;
                        s.push("\nremote host: " + ipConnInfo.remoteAddress + " remote port: " + ipConnInfo.remotePort);
                    }
                }
                if(ex.stack)
                {
                    s.push("\n");
                    s.push(ex.stack);
                }
                this._instance.initializationData().logger.warning(s.join(""));
            },
            __servantLocatorFinished: function()
            {
                Debug.assert(this._locator !== null && this._servant !== null);
                try
                {
                    this._locator.finished(this._current, this._servant, this._cookie.value);
                    return true;
                }
                catch(ex)
                {
                    if(ex instanceof Ice.UserException)
                    {
                        Debug.assert(this._connection !== null);
        
                        //
                        // The operation may have already marshaled a reply; we must overwrite that reply.
                        //
                        if(this._response)
                        {
                            this._os.resize(Protocol.headerSize + 4); // Reply status position.
                            this._os.writeByte(Protocol.replyUserException);
                            this._os.startWriteEncaps();
                            this._os.writeUserException(ex);
                            this._os.endWriteEncaps();
                            this._connection.sendResponse(this._os, this._compress);
                        }
                        else
                        {
                            this._connection.sendNoResponse();
                        }
        
                        this._connection = null;
                    }
                    else
                    {
                        this.__handleException(ex);
                    }
                    return false;
                }
            },
            __handleException: function(ex)
            {
                Debug.assert(this._connection !== null);
        
                var props = this._instance.initializationData().properties;
                var s;
                if(ex instanceof Ice.RequestFailedException)
                {
                    if(ex.id === null)
                    {
                        ex.id = this._current.id;
                    }
        
                    if(ex.facet === null)
                    {
                        ex.facet = this._current.facet;
                    }
        
                    if(ex.operation === null || ex.operation.length === 0)
                    {
                        ex.operation = this._current.operation;
                    }
        
                    if(props.getPropertyAsIntWithDefault("Ice.Warn.Dispatch", 1) > 1)
                    {
                        this.__warning(ex);
                    }
        
                    if(this._response)
                    {
                        this._os.resize(Protocol.headerSize + 4); // Reply status position.
                        if(ex instanceof Ice.ObjectNotExistException)
                        {
                            this._os.writeByte(Protocol.replyObjectNotExist);
                        }
                        else if(ex instanceof Ice.FacetNotExistException)
                        {
                            this._os.writeByte(Protocol.replyFacetNotExist);
                        }
                        else if(ex instanceof Ice.OperationNotExistException)
                        {
                            this._os.writeByte(Protocol.replyOperationNotExist);
                        }
                        else
                        {
                            Debug.assert(false);
                        }
                        ex.id.__write(this._os);
        
                        //
                        // For compatibility with the old FacetPath.
                        //
                        if(ex.facet === null || ex.facet.length === 0)
                        {
                            Ice.StringSeqHelper.write(this._os, null);
                        }
                        else
                        {
                            Ice.StringSeqHelper.write(this._os, [ ex.facet ]);
                        }
        
                        this._os.writeString(ex.operation);
        
                        this._connection.sendResponse(this._os, this._compress);
                    }
                    else
                    {
                        this._connection.sendNoResponse();
                    }
                }
                else if(ex instanceof Ice.UnknownLocalException)
                {
                    if(props.getPropertyAsIntWithDefault("Ice.Warn.Dispatch", 1) > 0)
                    {
                        this.__warning(ex);
                    }
        
                    if(this._response)
                    {
                        this._os.resize(Protocol.headerSize + 4); // Reply status position.
                        this._os.writeByte(Protocol.replyUnknownLocalException);
                        this._os.writeString(ex.unknown);
                        this._connection.sendResponse(this._os, this._compress);
                    }
                    else
                    {
                        this._connection.sendNoResponse();
                    }
                }
                else if(ex instanceof Ice.UnknownUserException)
                {
                    if(props.getPropertyAsIntWithDefault("Ice.Warn.Dispatch", 1) > 0)
                    {
                        this.__warning(ex);
                    }
        
                    if(this._response)
                    {
                        this._os.resize(Protocol.headerSize + 4); // Reply status position.
                        this._os.writeByte(Protocol.replyUnknownUserException);
                        this._os.writeString(ex.unknown);
                        this._connection.sendResponse(this._os, this._compress);
                    }
                    else
                    {
                        this._connection.sendNoResponse();
                    }
                }
                else if(ex instanceof Ice.UnknownException)
                {
                    if(props.getPropertyAsIntWithDefault("Ice.Warn.Dispatch", 1) > 0)
                    {
                        this.__warning(ex);
                    }
        
                    if(this._response)
                    {
                        this._os.resize(Protocol.headerSize + 4); // Reply status position.
                        this._os.writeByte(Protocol.replyUnknownException);
                        this._os.writeString(ex.unknown);
                        this._connection.sendResponse(this._os, this._compress);
                    }
                    else
                    {
                        this._connection.sendNoResponse();
                    }
                }
                else if(ex instanceof Ice.LocalException)
                {
                    if(props.getPropertyAsIntWithDefault("Ice.Warn.Dispatch", 1) > 0)
                    {
                        this.__warning(ex);
                    }
        
                    if(this._response)
                    {
                        this._os.resize(Protocol.headerSize + 4); // Reply status position.
                        this._os.writeByte(Protocol.replyUnknownLocalException);
                        //this._os.writeString(ex.toString());
                        s = [ ex.ice_name() ];
                        if(ex.stack)
                        {
                            s.push("\n");
                            s.push(ex.stack);
                        }
                        this._os.writeString(s.join(""));
                        this._connection.sendResponse(this._os, this._compress);
                    }
                    else
                    {
                        this._connection.sendNoResponse();
                    }
                }
                else if(ex instanceof Ice.UserException)
                {
                    if(props.getPropertyAsIntWithDefault("Ice.Warn.Dispatch", 1) > 0)
                    {
                        this.__warning(ex);
                    }
        
                    if(this._response)
                    {
                        this._os.resize(Protocol.headerSize + 4); // Reply status position.
                        this._os.writeByte(Protocol.replyUnknownUserException);
                        //this._os.writeString(ex.toString());
                        s = [ ex.ice_name() ];
                        if(ex.stack)
                        {
                            s.push("\n");
                            s.push(ex.stack);
                        }
                        this._os.writeString(s.join(""));
                        this._connection.sendResponse(this._os, this._compress);
                    }
                    else
                    {
                        this._connection.sendNoResponse();
                    }
                }
                else
                {
                    if(props.getPropertyAsIntWithDefault("Ice.Warn.Dispatch", 1) > 0)
                    {
                        this.__warning(ex);
                    }
        
                    if(this._response)
                    {
                        this._os.resize(Protocol.headerSize + 4); // Reply status position.
                        this._os.writeByte(Protocol.replyUnknownException);
                        //this._os.writeString(ex.toString());
                        this._os.writeString(ex.stack ? ex.stack : "");
                        this._connection.sendResponse(this._os, this._compress);
                    }
                    else
                    {
                        this._connection.sendNoResponse();
                    }
                }
        
                this._connection = null;
            },
            invoke: function(servantManager, stream)
            {
                this._is = stream;
        
                var start = this._is.pos;
        
                //
                // Read the current.
                //
                this._current.id.__read(this._is);
        
                //
                // For compatibility with the old FacetPath.
                //
                var facetPath = Ice.StringSeqHelper.read(this._is);
                if(facetPath.length > 0)
                {
                    if(facetPath.length > 1)
                    {
                        throw new Ice.MarshalException();
                    }
                    this._current.facet = facetPath[0];
                }
                else
                {
                    this._current.facet = "";
                }
        
                this._current.operation = this._is.readString();
                this._current.mode = Ice.OperationMode.valueOf(this._is.readByte());
                this._current.ctx = new Context();
                var sz = this._is.readSize();
                while(sz-- > 0)
                {
                    var first = this._is.readString();
                    var second = this._is.readString();
                    this._current.ctx.set(first, second);
                }
        
                //
                // Don't put the code above into the try block below. Exceptions
                // in the code above are considered fatal, and must propagate to
                // the caller of this operation.
                //
        
                if(servantManager !== null)
                {
                    this._servant = servantManager.findServant(this._current.id, this._current.facet);
                    if(this._servant === null)
                    {
                        this._locator = servantManager.findServantLocator(this._current.id.category);
                        if(this._locator === null && this._current.id.category.length > 0)
                        {
                            this._locator = servantManager.findServantLocator("");
                        }
        
                        if(this._locator !== null)
                        {
                            try
                            {
                                this._servant = this._locator.locate(this._current, this._cookie);
                            }
                            catch(ex)
                            {
                                if(ex instanceof Ice.UserException)
                                {
                                    var encoding = this._is.skipEncaps(); // Required for batch requests.
        
                                    if(this._response)
                                    {
                                        this._os.writeByte(Protocol.replyUserException);
                                        this._os.startWriteEncaps(encoding, FormatType.DefaultFormat);
                                        this._os.writeUserException(ex);
                                        this._os.endWriteEncaps();
                                        this._connection.sendResponse(this._os, this._compress);
                                    }
                                    else
                                    {
                                        this._connection.sendNoResponse();
                                    }
        
                                    this._connection = null;
                                    return;
                                }
                                else
                                {
                                    this._is.skipEncaps(); // Required for batch requests.
                                    this.__handleException(ex);
                                    return;
                                }
                            }
                        }
                    }
                }
        
                try
                {
                    if(this._servant !== null)
                    {
                        //
                        // DispatchAsync is a "pseudo dispatch status", used internally only
                        // to indicate async dispatch.
                        //
                        if(this._servant.__dispatch(this, this._current) === Ice.DispatchStatus.DispatchAsync)
                        {
                            //
                            // If this was an asynchronous dispatch, we're done here.
                            //
                            return;
                        }
        
                        if(this._locator !== null && !this.__servantLocatorFinished())
                        {
                            return;
                        }
                    }
                    else
                    {
                        //
                        // Skip the input parameters, this is required for reading
                        // the next batch request if dispatching batch requests.
                        //
                        this._is.skipEncaps();
        
                        if(servantManager !== null && servantManager.hasServant(this._current.id))
                        {
                            throw new Ice.FacetNotExistException(this._current.id, this._current.facet,
                                                                    this._current.operation);
                        }
                        else
                        {
                            throw new Ice.ObjectNotExistException(this._current.id, this._current.facet,
                                                                    this._current.operation);
                        }
                    }
                }
                catch(ex)
                {
                    if(this._servant !== null && this._locator !== null && !this.__servantLocatorFinished())
                    {
                        return;
                    }
                    this.__handleException(ex);
                    return;
                }
        
                //
                // Don't put the code below into the try block above. Exceptions
                // in the code below are considered fatal, and must propagate to
                // the caller of this operation.
                //
        
                Debug.assert(this._connection !== null);
        
                if(this._response)
                {
                    this._connection.sendResponse(this._os, this._compress);
                }
                else
                {
                    this._connection.sendNoResponse();
                }
        
                this._connection = null;
            },
            startReadParams: function()
            {
                //
                // Remember the encoding used by the input parameters, we'll
                // encode the response parameters with the same encoding.
                //
                this._current.encoding = this._is.startReadEncaps();
                return this._is;
            },
            endReadParams: function()
            {
                this._is.endReadEncaps();
            },
            readEmptyParams: function()
            {
                this._current.encoding = new Ice.EncodingVersion();
                this._is.skipEmptyEncaps(this._current.encoding);
            },
            readParamEncaps: function()
            {
                this._current.encoding = new Ice.EncodingVersion();
                return this._is.readEncaps(this._current.encoding);
            },
            __response: function()
            {
                try
                {
                    if(this._locator !== null && !this.__servantLocatorFinished())
                    {
                        return;
                    }
        
                    Debug.assert(this._connection !== null);
        
                    if(this._response)
                    {
                        this._connection.sendResponse(this._os, this._compress);
                    }
                    else
                    {
                        this._connection.sendNoResponse();
                    }
        
                    this._connection = null;
                }
                catch(ex)
                {
                    this._connection.invokeException(ex, 1);
                }
            },
            __exception: function(exc)
            {
                try
                {
                    if(this._locator !== null && !this.__servantLocatorFinished())
                    {
                        return;
                    }
        
                    this.__handleException(exc);
                }
                catch(ex)
                {
                    this._connection.invokeException(ex, 1);
                }
            },
            __validateResponse: function(ok)
            {
                if(!this._active)
                {
                    return false;
                }
                this._active = false;
                return true;
            },
            ice_exception: function(ex)
            {
                if(!this._active)
                {
                    return;
                }
                this._active = false;
        
                if(this._connection !== null)
                {
                    this.__exception(ex);
                }
                else
                {
                    //
                    // Response has already been sent.
                    //
                    if(this._instance.initializationData().properties.getPropertyAsIntWithDefault("Ice.Warn.Dispatch", 1) > 0)
                    {
                        this.__warning(ex);
                    }
                }
            }
        });
        
        Ice.IncomingAsync = IncomingAsync;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var AsyncResult = Ice.AsyncResult;
        var AsyncStatus = Ice.AsyncStatus;
        var BasicStream = Ice.BasicStream;
        var ConnectionRequestHandler = Ice.ConnectionRequestHandler;
        var Debug = Ice.Debug;
        var ExUtil = Ice.ExUtil;
        var RetryException = Ice.RetryException;
        var OutgoingAsync = Ice.OutgoingAsync;
        var Protocol = Ice.Protocol;
        var ReferenceMode = Ice.ReferenceMode;
        var LocalException = Ice.LocalException;
        var Promise = Ice.Promise;
        
        var ConnectRequestHandler = Ice.Class({
            __init__: function(ref, proxy)
            {
                this._reference = ref;
                this._response = ref.getMode() === ReferenceMode.ModeTwoway;
                this._proxy = proxy;
                this._proxies = [];
                this._initialized = false;
        
                this._connection = null;
                this._compress = false;
                this._exception = null;
                this._requests = [];
            },
            connect: function(proxy)
            {
                if(!this.initialized())
                {
                    this._proxies.push(proxy);
                }
                return this._requestHandler ? this._requestHandler : this;
            },
            update: function(previousHandler, newHandler)
            {
                return previousHandler === this ? newHandler : this;
            },
            sendAsyncRequest: function(out)
            {
                if(!this._initialized)
                {
                    out.__cancelable(this); // This will throw if the request is canceled
                }
        
                if(!this.initialized())
                {
                    this._requests.push(out);
                    return AsyncStatus.Queued;
                }
                return out.__invokeRemote(this._connection, this._compress, this._response);
            },
            asyncRequestCanceled: function(out, ex)
            {
                if(this._exception !== null)
                {
                    return; // The request has been notified of a failure already.
                }
        
                if(!this.initialized())
                {
                    for(var i = 0; i < this._requests.length; i++)
                    {
                        if(this._requests[i] === out)
                        {
                            out.__completedEx(ex);
                            this._requests.splice(i, 1);
                            return;
                        }
                    }
                    Debug.assert(false); // The request has to be queued if it timed out and we're not initialized yet.
                }
                this._connection.asyncRequestCanceled(out, ex);
            },
            getReference: function()
            {
                return this._reference;
            },
            getConnection: function()
            {
                if(this._exception !== null)
                {
                    throw this._exception;
                }
                else
                {
                    return this._connection;
                }
            },
            //
            // Implementation of Reference_GetConnectionCallback
            //
            setConnection: function(connection, compress)
            {
                Debug.assert(this._exception === null && this._connection === null);
        
                this._connection = connection;
                this._compress = compress;
        
                //
                // If this proxy is for a non-local object, and we are using a router, then
                // add this proxy to the router info object.
                //
                var ri = this._reference.getRouterInfo();
                if(ri !== null)
                {
                    var self = this;
                    ri.addProxy(this._proxy).then(function()
                                                  {
                                                      //
                                                      // The proxy was added to the router info, we're now ready to send the
                                                      // queued requests.
                                                      //
                                                      self.flushRequests();
                                                  },
                                                  function(ex)
                                                  {
                                                      self.setException(ex);
                                                  });
                    return; // The request handler will be initialized once addProxy completes.
                }
        
                //
                // We can now send the queued requests.
                //
                this.flushRequests();
            },
            setException: function(ex)
            {
                Debug.assert(!this._initialized && this._exception === null);
        
                this._exception = ex;
                this._proxies.length = 0;
                this._proxy = null; // Break cyclic reference count.
        
                //
                // NOTE: remove the request handler *before* notifying the
                // requests that the connection failed. It's important to ensure
                // that future invocations will obtain a new connect request
                // handler once invocations are notified.
                //
                try
                {
                    this._reference.getInstance().requestHandlerFactory().removeRequestHandler(this._reference, this);
                }
                catch(exc)
                {
                    // Ignore
                }
        
                for(var i = 0; i < this._requests.length; ++i)
                {
                    var request = this._requests[i];
                    if(request !== null)
                    {
                        request.__completedEx(this._exception);
                    }
                }
                this._requests.length = 0;
            },
            initialized: function()
            {
                if(this._initialized)
                {
                    Debug.assert(this._connection !== null);
                    return true;
                }
                else
                {
                    if(this._exception !== null)
                    {
                        if(this._connection !== null)
                        {
                            //
                            // Only throw if the connection didn't get established. If
                            // it died after being established, we allow the caller to
                            // retry the connection establishment by not throwing here
                            // (the connection will throw RetryException).
                            //
                            return true;
                        }
                        throw this._exception;
                    }
                    else
                    {
                        return this._initialized;
                    }
                }
            },
            flushRequests: function()
            {
                Debug.assert(this._connection !== null && !this._initialized);
        
                var exception = null;
                for(var i = 0; i < this._requests.length; ++i)
                {
                    var request = this._requests[i];
                    try
                    {
                        request.__invokeRemote(this._connection, this._compress, this._response);
                    }
                    catch(ex)
                    {
                        if(ex instanceof RetryException)
                        {
                            exception = ex.inner;
        
                            // Remove the request handler before retrying.
                            this._reference.getInstance().requestHandlerFactory().removeRequestHandler(this._reference, this);
        
                            request.__retryException(ex.inner);
                        }
                        else
                        {
                            Debug.assert(ex instanceof LocalException);
                            exception = ex;
                            request.out.__completedEx(ex);
                        }
                    }
                }
                this._requests.length = 0;
        
                if(this._reference.getCacheConnection() && exception === null)
                {
                    this._requestHandler = new ConnectionRequestHandler(this._reference, this._connection, this._compress);
                    for(var k = 0; k < this._proxies.length; ++k)
                    {
                        this._proxies[k].__updateRequestHandler(this, this._requestHandler);
                    }
                }
        
                Debug.assert(!this._initialized);
                this._exception = exception;
                this._initialized = this._exception === null;
        
                //
                // Only remove once all the requests are flushed to
                // guarantee serialization.
                //
                this._reference.getInstance().requestHandlerFactory().removeRequestHandler(this._reference, this);
        
                this._proxies.length = 0;
                this._proxy = null; // Break cyclic reference count.
            }
        });
        
        Ice.ConnectRequestHandler = ConnectRequestHandler;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `ConnectionInfo.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * Provides access to the connection details of an SSL connection
             * 
             **/
            IceSSL.ConnectionInfo = Slice.defineLocalObject(
                function(incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort, cipher, certs, verified)
                {
                    Ice.IPConnectionInfo.call(this, incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort);
                    this.cipher = cipher !== undefined ? cipher : "";
                    this.certs = certs !== undefined ? certs : null;
                    this.verified = verified !== undefined ? verified : false;
                },
                Ice.IPConnectionInfo);
        
            /**
             * Provides access to the connection details of a secure WebSocket connection
             * 
             **/
            IceSSL.WSSConnectionInfo = Slice.defineLocalObject(
                function(incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort, cipher, certs, verified, headers)
                {
                    IceSSL.ConnectionInfo.call(this, incoming, adapterName, connectionId, rcvSize, sndSize, localAddress, localPort, remoteAddress, remotePort, cipher, certs, verified);
                    this.headers = headers !== undefined ? headers : null;
                },
                IceSSL.ConnectionInfo);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        var IceSSL = Ice.__M.module("IceSSL");
        
        //
        // With Chrome we don't want to close the socket while connection is in progress,
        // see comments on close implementation below.
        //
        // We need to check for Edge browser as it might include Chrome in its user agent.
        //
        var IsChrome = navigator.userAgent.indexOf("Edge/") === -1 &&
                       navigator.userAgent.indexOf("Chrome/") !== -1;
        
        var Debug = Ice.Debug;
        var ExUtil = Ice.ExUtil;
        var Network = Ice.Network;
        var SocketOperation = Ice.SocketOperation;
        var Conn = Ice.Connection;
        var LocalException = Ice.LocalException;
        var SocketException = Ice.SocketException;
        var Timer = Ice.Timer;
        
        var StateNeedConnect = 0;
        var StateConnectPending = 1;
        var StateConnected = 2;
        var StateClosePending = 3;
        var StateClosed = 4;
        
        var WSTransceiver = Ice.Class({
            __init__: function(instance)
            {
                this._logger = instance.logger();
                this._readBuffers = [];
                this._readPosition = 0;
                this._maxSendPacketSize = instance.properties().getPropertyAsIntWithDefault("Ice.TCP.SndSize", 512 * 1024);
                this._writeReadyTimeout = 0;
            },
            writeReadyTimeout: function()
            {
                var t = Math.round(this._writeReadyTimeout);
                this._writeReadyTimeout +=  (this._writeReadyTimeout >= 5 ? 5 : 0.2);
                return Math.min(t, 25);
            },
            setCallbacks: function(connectedCallback, bytesAvailableCallback, bytesWrittenCallback)
            {
                this._connectedCallback = connectedCallback;
                this._bytesAvailableCallback = bytesAvailableCallback;
                this._bytesWrittenCallback = bytesWrittenCallback;
            },
            //
            // Returns SocketOperation.None when initialization is complete.
            //
            initialize: function(readBuffer, writeBuffer)
            {
                try
                {
                    if(this._exception)
                    {
                        throw this._exception;
                    }
        
                    if(this._state === StateNeedConnect)
                    {
                        this._state = StateConnectPending;
                        this._fd = new WebSocket(this._url, "ice.zeroc.com");
                        this._fd.binaryType = "arraybuffer";
                        var self = this;
                        this._fd.onopen = function(e) { self.socketConnected(e); };
                        this._fd.onmessage = function(e) { self.socketBytesAvailable(e.data); };
                        this._fd.onclose = function(e) { self.socketClosed(e); };
                        return SocketOperation.Connect; // Waiting for connect to complete.
                    }
                    else if(this._state === StateConnectPending)
                    {
                        //
                        // Socket is connected.
                        //
                        this._desc = fdToString(this._addr);
                        this._state = StateConnected;
                    }
                }
                catch(err)
                {
                    if(!this._exception)
                    {
                        this._exception = translateError(this._state, err);
                    }
                    throw this._exception;
                }
        
                Debug.assert(this._state === StateConnected);
                return SocketOperation.None;
            },
            register: function()
            {
                //
                // Register the socket data listener.
                //
                this._registered = true;
                if(this._hasBytesAvailable || this._exception)
                {
                    this._bytesAvailableCallback();
                    this._hasBytesAvailable = false;
                }
            },
            unregister: function()
            {
                //
                // Unregister the socket data listener.
                //
                this._registered = false;
            },
            close: function()
            {
                if(this._fd === null)
                {
                    Debug.assert(this._exception); // Websocket creation failed.
                    return;
                }
        
                //
                // With Chrome calling close() while the websocket isn't connected yet
                // doesn't abort the connection attempt, and might result in the connection
                // being reused by a different web socket.
                //
                // To workaround this problem, we always wait for the socket to be
                // connected or closed before closing the socket.
                //
                if(IsChrome && this._fd.readyState === WebSocket.CONNECTING)
                {
                    this._state = StateClosePending;
                    return;
                }
        
                Debug.assert(this._fd !== null);
                try
                {
                    this._state = StateClosed;
                    this._fd.close();
                }
                catch(ex)
                {
                    throw translateError(this._state, ex);
                }
                finally
                {
                    this._fd = null;
                }
            },
            //
            // Returns true if all of the data was flushed to the kernel buffer.
            //
            write: function(byteBuffer)
            {
                if(this._exception)
                {
                    throw this._exception;
                }
                else if(byteBuffer.remaining === 0)
                {
                    return true;
                }
                Debug.assert(this._fd);
        
                var i = byteBuffer.position;
                while(true)
                {
                    var packetSize = (this._maxSendPacketSize > 0 && byteBuffer.remaining > this._maxSendPacketSize) ?
                        this._maxSendPacketSize : byteBuffer.remaining;
                    if(byteBuffer.remaining === 0)
                    {
                        break;
                    }
                    Debug.assert(packetSize > 0);
                    if(this._fd.bufferedAmount + packetSize > this._maxSendPacketSize)
                    {
                        var transceiver = this;
                        Timer.setTimeout(function()
                            {
                                if(transceiver._fd && transceiver._fd.bufferedAmount + packetSize <= transceiver._maxSendPacketSize)
                                {
                                    transceiver._bytesWrittenCallback(0, 0);
                                }
                            },
                            this.writeReadyTimeout());
                        return false;
                    }
                    this._writeReadyTimeout = 0;
                    var slice = byteBuffer.b.slice(byteBuffer.position, byteBuffer.position + packetSize);
                    this._fd.send(slice);
                    byteBuffer.position = byteBuffer.position + packetSize;
                }
                return true;
            },
            read: function(byteBuffer, moreData)
            {
                if(this._exception)
                {
                    throw this._exception;
                }
        
                moreData.value = false;
        
                if(this._readBuffers.length === 0)
                {
                    return false; // No data available.
                }
        
                var avail = this._readBuffers[0].byteLength - this._readPosition;
                Debug.assert(avail > 0);
                var remaining = byteBuffer.remaining;
        
                while(byteBuffer.remaining > 0)
                {
                    if(avail > byteBuffer.remaining)
                    {
                        avail = byteBuffer.remaining;
                    }
        
                    new Uint8Array(byteBuffer.b).set(new Uint8Array(this._readBuffers[0], this._readPosition, avail),
                                                        byteBuffer.position);
        
                    byteBuffer.position += avail;
                    this._readPosition += avail;
                    if(this._readPosition === this._readBuffers[0].byteLength)
                    {
                        //
                        // We've exhausted the current read buffer.
                        //
                        this._readPosition = 0;
                        this._readBuffers.shift();
                        if(this._readBuffers.length === 0)
                        {
                            break; // No more data - we're done.
                        }
                        else
                        {
                            avail = this._readBuffers[0].byteLength;
                        }
                    }
                }
        
                moreData.value = this._readBuffers.byteLength > 0;
        
                return byteBuffer.remaining === 0;
            },
            type: function()
            {
                return this._secure ? "wss" : "ws";
            },
            getInfo: function()
            {
                Debug.assert(this._fd !== null);
                var info = this._secure ? new IceSSL.WSSConnectionInfo() : new Ice.WSConnectionInfo();
        
                //
                // The WebSocket API doens't provide this info
                //
                info.localAddress = "";
                info.localPort = -1;
                info.remoteAddress = this._addr.host;
                info.remotePort = this._addr.port;
                info.rcvSize = -1;
                info.sndSize = this._maxSendPacketSize;
                info.headers = {};
                return info;
            },
            checkSendSize: function(stream)
            {
            },
            setBufferSize: function(rcvSize, sndSize)
            {
                this._maxSendPacketSize = sndSize;
            },
            toString: function()
            {
                return this._desc;
            },
            socketConnected: function(e)
            {
                if(this._state == StateClosePending)
                {
                    this.close();
                    return;
                }
        
                Debug.assert(this._connectedCallback !== null);
                this._connectedCallback();
            },
            socketBytesAvailable: function(buf)
            {
                Debug.assert(this._bytesAvailableCallback !== null);
                if(buf.byteLength > 0)
                {
                    this._readBuffers.push(buf);
                    if(this._registered)
                    {
                        this._bytesAvailableCallback();
                    }
                    else if(!this._hasBytesAvailable)
                    {
                        this._hasBytesAvailable = true;
                    }
                }
            },
            socketClosed: function(err)
            {
                if(this._state == StateClosePending)
                {
                    this.close();
                    return;
                }
        
                this._exception = translateError(this._state, err);
                if(this._state < StateConnected)
                {
                    this._connectedCallback();
                }
                else if(this._registered)
                {
                    this._bytesAvailableCallback();
                }
            },
        });
        
        function fdToString(address)
        {
            return "local address = <not available>\nremote address = " + address.host + ":" + address.port;
        }
        
        function translateError(state, err)
        {
            if(state < StateConnected)
            {
                return new Ice.ConnectFailedException(err.code, err);
            }
            else
            {
                if(err.code === 1000 || err.code === 1006) // CLOSE_NORMAL | CLOSE_ABNORMAL
                {
                    return new Ice.ConnectionLostException();
                }
                return new Ice.SocketException(err.code, err);
            }
        }
        
        WSTransceiver.createOutgoing = function(instance, secure, addr, resource)
        {
            var transceiver = new WSTransceiver(instance);
        
            var url = secure ? "wss" : "ws";
            url += "://" + addr.host;
            if(addr.port !== 80)
            {
                url += ":" + addr.port;
            }
            url += resource ? resource : "/";
            transceiver._url = url;
            transceiver._fd = null;
            transceiver._addr = addr;
            transceiver._desc = "local address = <not available>\nremote address = " + addr.host + ":" + addr.port;
            transceiver._state = StateNeedConnect;
            transceiver._secure = secure;
            transceiver._exception = null;
        
            return transceiver;
        };
        
        Ice.WSTransceiver = WSTransceiver;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Router.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * The Ice router interface. Routers can be set either globally with
             * {@link Communicator#setDefaultRouter}, or with <tt>ice_router</tt> on specific
             * proxies.
             * 
             **/
            Ice.Router = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 1,
                [
                    "::Ice::Object",
                    "::Ice::Router"
                ],
                -1, undefined, undefined, false);
        
            Ice.RouterPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.Router.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.Router, Ice.RouterPrx,
            {
                "getClientProxy": [, 2, 1, , , [9], , , , , ],
                "getServerProxy": [, 2, 1, , , [9], , , , , ],
                "addProxies": [, 2, 2, , , ["Ice.ObjectProxySeqHelper"], [["Ice.ObjectProxySeqHelper"]], , , , ]
            });
        
            /**
             * This inferface should be implemented by services implementing the
             * Ice::Router interface. It should be advertised through an Ice
             * object with the identity `Ice/RouterFinder'. This allows clients to
             * retrieve the router proxy with just the endpoint information of the
             * service.
             * 
             **/
            Ice.RouterFinder = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 1,
                [
                    "::Ice::Object",
                    "::Ice::RouterFinder"
                ],
                -1, undefined, undefined, false);
        
            Ice.RouterFinderPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.RouterFinder.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.RouterFinder, Ice.RouterFinderPrx,
            {
                "getRouter": [, , , , , ["Ice.RouterPrx"], , , , , ]
            });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Locator.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * This exception is raised if an adapter cannot be found.
             * 
             **/
            Ice.AdapterNotFoundException = Slice.defineUserException(
                function(_cause)
                {
                    Ice.UserException.call(this, _cause);
                },
                Ice.UserException,
                "Ice::AdapterNotFoundException",
                undefined, undefined,
                false,
                false);
        
            /**
             * This exception is raised if the replica group provided by the
             * server is invalid.
             * 
             **/
            Ice.InvalidReplicaGroupIdException = Slice.defineUserException(
                function(_cause)
                {
                    Ice.UserException.call(this, _cause);
                },
                Ice.UserException,
                "Ice::InvalidReplicaGroupIdException",
                undefined, undefined,
                false,
                false);
        
            /**
             * This exception is raised if a server tries to set endpoints for
             * an adapter that is already active.
             * 
             **/
            Ice.AdapterAlreadyActiveException = Slice.defineUserException(
                function(_cause)
                {
                    Ice.UserException.call(this, _cause);
                },
                Ice.UserException,
                "Ice::AdapterAlreadyActiveException",
                undefined, undefined,
                false,
                false);
        
            /**
             * This exception is raised if an object cannot be found.
             * 
             **/
            Ice.ObjectNotFoundException = Slice.defineUserException(
                function(_cause)
                {
                    Ice.UserException.call(this, _cause);
                },
                Ice.UserException,
                "Ice::ObjectNotFoundException",
                undefined, undefined,
                false,
                false);
        
            /**
             * This exception is raised if a server cannot be found.
             * 
             **/
            Ice.ServerNotFoundException = Slice.defineUserException(
                function(_cause)
                {
                    Ice.UserException.call(this, _cause);
                },
                Ice.UserException,
                "Ice::ServerNotFoundException",
                undefined, undefined,
                false,
                false);
        
            /**
             * The Ice locator interface. This interface is used by clients to
             * lookup adapters and objects. It is also used by servers to get the
             * locator registry proxy.
             * 
             * <p class="Note">The {@link Locator} interface is intended to be used by
             * Ice internals and by locator implementations. Regular user code
             * should not attempt to use any functionality of this interface
             * directly.
             * 
             **/
            Ice.Locator = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Ice::Locator",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Ice.LocatorPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.Locator.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.Locator, Ice.LocatorPrx,
            {
                "findObjectById": [, 2, 1, 1, , [9], [[Ice.Identity]], , 
                [
                    Ice.ObjectNotFoundException
                ], , ],
                "findAdapterById": [, 2, 1, 1, , [9], [[7]], , 
                [
                    Ice.AdapterNotFoundException
                ], , ],
                "getRegistry": [, 2, 1, , , ["Ice.LocatorRegistryPrx"], , , , , ]
            });
        
            /**
             * The Ice locator registry interface. This interface is used by
             * servers to register adapter endpoints with the locator.
             * 
             * <p class="Note"> The {@link LocatorRegistry} interface is intended to be used
             * by Ice internals and by locator implementations. Regular user
             * code should not attempt to use any functionality of this interface
             * directly.
             * 
             **/
            Ice.LocatorRegistry = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Ice::LocatorRegistry",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Ice.LocatorRegistryPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.LocatorRegistry.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.LocatorRegistry, Ice.LocatorRegistryPrx,
            {
                "setAdapterDirectProxy": [, 2, 2, 1, , , [[7], [9]], , 
                [
                    Ice.AdapterAlreadyActiveException,
                    Ice.AdapterNotFoundException
                ], , ],
                "setReplicatedAdapterDirectProxy": [, 2, 2, 1, , , [[7], [7], [9]], , 
                [
                    Ice.AdapterAlreadyActiveException,
                    Ice.AdapterNotFoundException,
                    Ice.InvalidReplicaGroupIdException
                ], , ],
                "setServerProcessProxy": [, 2, 2, 1, , , [[7], ["Ice.ProcessPrx"]], , 
                [
                    Ice.ServerNotFoundException
                ], , ]
            });
        
            /**
             * This inferface should be implemented by services implementing the
             * Ice::Locator interface. It should be advertised through an Ice
             * object with the identity `Ice/LocatorFinder'. This allows clients
             * to retrieve the locator proxy with just the endpoint information of
             * the service.
             * 
             **/
            Ice.LocatorFinder = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Ice::LocatorFinder",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Ice.LocatorFinderPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.LocatorFinder.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.LocatorFinder, Ice.LocatorFinderPrx,
            {
                "getLocator": [, , , , , ["Ice.LocatorPrx"], , , , , ]
            });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        
        var Debug = Ice.Debug;
        var HashUtil = Ice.HashUtil;
        var StringUtil = Ice.StringUtil;
        var TcpTransceiver = typeof(Ice.TcpTransceiver) !== "undefined" ? Ice.TcpTransceiver : null;
        var Class = Ice.Class;
        
        var TcpEndpointI = Class(Ice.IPEndpointI, {
            __init__: function(instance, ho, po, sif, ti, conId, co)
            {
                Ice.IPEndpointI.call(this, instance, ho, po, sif, conId);
                this._timeout = ti === undefined ? (instance ? instance.defaultTimeout() : undefined) : ti;
                this._compress = co === undefined ? false : co;
            },
            //
            // Return the endpoint information.
            //
            getInfo: function()
            {
                var info = this.secure() ? new IceSSL.EndpointInfo() : new Ice.TCPEndpointInfo();
                this.fillEndpointInfo(info);
                return info;
            },
            //
            // Return the timeout for the endpoint in milliseconds. 0 means
            // non-blocking, -1 means no timeout.
            //
            timeout: function()
            {
                return this._timeout;
            },
            //
            // Return a new endpoint with a different timeout value, provided
            // that timeouts are supported by the endpoint. Otherwise the same
            // endpoint is returned.
            //
            changeTimeout: function(timeout)
            {
                if(timeout === this._timeout)
                {
                    return this;
                }
                else
                {
                    return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, timeout,
                                            this._connectionId, this._compress);
                }
            },
            //
            // Return a new endpoint with a different connection id.
            //
            changeConnectionId: function(connectionId)
            {
                if(connectionId === this._connectionId)
                {
                    return this;
                }
                else
                {
                    return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, this._timeout,
                                            connectionId, this._compress);
                }
            },
            //
            // Return true if the endpoints support bzip2 compress, or false
            // otherwise.
            //
            compress: function()
            {
                return this._compress;
            },
            //
            // Return a new endpoint with a different compression value,
            // provided that compression is supported by the
            // endpoint. Otherwise the same endpoint is returned.
            //
            changeCompress: function(compress)
            {
                if(compress === this._compress)
                {
                    return this;
                }
                else
                {
                    return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, this._timeout,
                                            this._connectionId, compress);
                }
            },
            //
            // Return true if the endpoint is datagram-based.
            //
            datagram: function()
            {
                return false;
            },
            connectable: function()
            {
                //
                // TCP endpoints are not connectable when running in a browser, SSL
                // isn't currently supported.
                //
                return TcpTransceiver !== null && !this.secure();
            },
            connect: function()
            {
                Debug.assert(!this.secure());
                return TcpTransceiver.createOutgoing(this._instance, this.getAddress(), this._sourceAddr);
            },
            //
            // Convert the endpoint to its string form
            //
            options: function()
            {
                //
                // WARNING: Certain features, such as proxy validation in Glacier2,
                // depend on the format of proxy strings. Changes to toString() and
                // methods called to generate parts of the reference string could break
                // these features. Please review for all features that depend on the
                // format of proxyToString() before changing this and related code.
                //
                var s = Ice.IPEndpointI.prototype.options.call(this);
                if(this._timeout == -1)
                {
                    s += " -t infinite";
                }
                else
                {
                    s += " -t " + this._timeout;
                }
        
                if(this._compress)
                {
                    s += " -z";
                }
                return s;
            },
            compareTo: function(p)
            {
                if(this === p)
                {
                    return 0;
                }
        
                if(p === null)
                {
                    return 1;
                }
        
                if(!(p instanceof TcpEndpointI))
                {
                    return this.type() < p.type() ? -1 : 1;
                }
        
                if(this._timeout < p._timeout)
                {
                    return -1;
                }
                else if(p._timeout < this._timeout)
                {
                    return 1;
                }
        
                if(!this._compress && p._compress)
                {
                    return -1;
                }
                else if(!p._compress && this._compress)
                {
                    return 1;
                }
        
                return Ice.IPEndpointI.prototype.compareTo.call(this, p);
            },
            streamWriteImpl: function(s)
            {
                Ice.IPEndpointI.prototype.streamWriteImpl.call(this, s);
                s.writeInt(this._timeout);
                s.writeBool(this._compress);
            },
            hashInit: function(h)
            {
                h = Ice.IPEndpointI.prototype.hashInit.call(this, h);
                h = HashUtil.addNumber(h, this._timeout);
                h = HashUtil.addBoolean(h, this._compress);
                return h;
            },
            fillEndpointInfo: function(info)
            {
                Ice.IPEndpointI.prototype.fillEndpointInfo.call(this, info);
                info.timeout = this._timeout;
                info.compress = this._compress;
            },
            initWithStream: function(s)
            {
                Ice.IPEndpointI.prototype.initWithStream.call(this, s);
                this._timeout = s.readInt();
                this._compress = s.readBool();
            },
            checkOption: function(option, argument, endpoint)
            {
                if(Ice.IPEndpointI.prototype.checkOption.call(this, option, argument, endpoint))
                {
                    return true;
                }
        
                if(option === "-t")
                {
                    if(argument === null)
                    {
                        throw new Ice.EndpointParseException("no argument provided for -t option in endpoint " + endpoint);
                    }
        
                    if(argument == "infinite")
                    {
                        this._timeout = -1;
                    }
                    else
                    {
                        var invalid = false;
                        try
                        {
                            this._timeout = StringUtil.toInt(argument);
                        }
                        catch(ex)
                        {
                            invalid = true;
                        }
                        if(invalid || this._timeout < 1)
                        {
                            throw new Ice.EndpointParseException("invalid timeout value `" + argument + "' in endpoint " +
                                                                 endpoint);
                        }
                    }
                }
                else if(option === "-z")
                {
                    if(argument !== null)
                    {
                        throw new Ice.EndpointParseException("unexpected argument `" + argument +
                                                             "' provided for -z option in " + endpoint);
                    }
        
                    this._compress = true;
                }
                else
                {
                    return false;
                }
                return true;
            },
            createEndpoint: function(host, port, conId)
            {
                return new TcpEndpointI(this._instance, host, port, this._sourceAddr, this._timeout, conId, this._compress);
            }
        });
        
        Ice.TcpEndpointI = TcpEndpointI;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var AsyncStatus = Ice.AsyncStatus;
        var AsyncResultBase = Ice.AsyncResultBase;
        var BasicStream = Ice.BasicStream;
        var BatchRequestQueue = Ice.BatchRequestQueue;
        var ConnectionFlushBatch = Ice.ConnectionFlushBatch;
        var Debug = Ice.Debug;
        var ExUtil = Ice.ExUtil;
        var HashMap = Ice.HashMap;
        var IncomingAsync = Ice.IncomingAsync;
        var RetryException = Ice.RetryException;
        var Promise = Ice.Promise;
        var Protocol = Ice.Protocol;
        var SocketOperation = Ice.SocketOperation;
        var Timer = Ice.Timer;
        var TraceUtil = Ice.TraceUtil;
        var ProtocolVersion = Ice.ProtocolVersion;
        var EncodingVersion = Ice.EncodingVersion;
        var ACM = Ice.ACM;
        var ACMClose = Ice.ACMClose;
        var ACMHeartbeat = Ice.ACMHeartbeat;
        
        var StateNotInitialized = 0;
        var StateNotValidated = 1;
        var StateActive = 2;
        var StateHolding = 3;
        var StateClosing = 4;
        var StateClosed = 5;
        var StateFinished = 6;
        
        var MessageInfo = function(instance)
        {
            this.stream = new BasicStream(instance, Protocol.currentProtocolEncoding);
        
            this.invokeNum = 0;
            this.requestId = 0;
            this.compress = false;
            this.servantManager = null;
            this.adapter = null;
            this.outAsync = null;
            this.heartbeatCallback = null;
        };
        
        var Class = Ice.Class;
        
        var ConnectionI = Class({
            __init__: function(communicator, instance, monitor, transceiver, endpoint, incoming, adapter)
            {
                this._communicator = communicator;
                this._instance = instance;
                this._monitor = monitor;
                this._transceiver = transceiver;
                this._desc = transceiver.toString();
                this._type = transceiver.type();
                this._endpoint = endpoint;
                this._incoming = incoming;
                this._adapter = adapter;
                var initData = instance.initializationData();
                this._logger = initData.logger; // Cached for better performance.
                this._traceLevels = instance.traceLevels(); // Cached for better performance.
                this._timer = instance.timer();
                this._writeTimeoutId = 0;
                this._writeTimeoutScheduled = false;
                this._readTimeoutId = 0;
                this._readTimeoutScheduled = false;
        
                this._hasMoreData = { value: false };
        
                this._warn = initData.properties.getPropertyAsInt("Ice.Warn.Connections") > 0;
                this._warnUdp = instance.initializationData().properties.getPropertyAsInt("Ice.Warn.Datagrams") > 0;
                this._acmLastActivity = this._monitor !== null && this._monitor.getACM().timeout > 0 ? Date.now() : -1;
                this._nextRequestId = 1;
                this._messageSizeMax = adapter ? adapter.messageSizeMax() : instance.messageSizeMax();
                this._batchRequestQueue = new BatchRequestQueue(instance, endpoint.datagram());
        
                this._sendStreams = [];
        
                this._readStream = new BasicStream(instance, Protocol.currentProtocolEncoding);
                this._readHeader = false;
                this._writeStream = new BasicStream(instance, Protocol.currentProtocolEncoding);
        
                this._readStreamPos = -1;
                this._writeStreamPos = -1;
        
                this._dispatchCount = 0;
        
                this._state = StateNotInitialized;
                this._shutdownInitiated = false;
                this._initialized = false;
                this._validated = false;
        
                this._readProtocol = new ProtocolVersion();
                this._readProtocolEncoding = new EncodingVersion();
        
                this._asyncRequests = new HashMap(); // Map<int, OutgoingAsync>
        
                this._exception = null;
        
                this._startPromise = null;
                this._closePromises = [];
                this._holdPromises = [];
                this._finishedPromises = [];
        
                if(this._adapter !== null)
                {
                    this._servantManager = this._adapter.getServantManager();
                }
                else
                {
                    this._servantManager = null;
                }
                this._callback = null;
            },
            start: function()
            {
                Debug.assert(this._startPromise === null);
        
                try
                {
                    // The connection might already be closed if the communicator was destroyed.
                    if(this._state >= StateClosed)
                    {
                        Debug.assert(this._exception !== null);
                        return new Promise().fail(this._exception);
                    }
        
                    this._startPromise = new Promise();
                    var self = this;
                    this._transceiver.setCallbacks(
                        function() { self.message(SocketOperation.Write); }, // connected callback
                        function() { self.message(SocketOperation.Read); },  // read callback
                        function(bytesSent, bytesTotal) {
                            self.message(SocketOperation.Write);
                            if(self._instance.traceLevels().network >= 3 && bytesSent > 0)
                            {
                                var s = [];
                                s.push("sent ");
                                s.push(bytesSent);
                                if(!self._endpoint.datagram())
                                {
                                    s.push(" of ");
                                    s.push(bytesTotal);
                                }
                                s.push(" bytes via ");
                                s.push(self._endpoint.protocol());
                                s.push("\n");
                                s.push(this.toString());
                                self._instance.initializationData().logger.trace(self._instance.traceLevels().networkCat,
                                                                                 s.join(""));
                            }
                        }  // write callback
                    );
                    this.initialize();
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        this.exception(ex);
                    }
                    return new Promise().fail(ex);
                }
        
                return this._startPromise;
            },
            activate: function()
            {
                if(this._state <= StateNotValidated)
                {
                    return;
                }
        
                if(this._acmLastActivity > 0)
                {
                    this._acmLastActivity = Date.now();
                }
                this.setState(StateActive);
            },
            hold: function()
            {
                if(this._state <= StateNotValidated)
                {
                    return;
                }
        
                this.setState(StateHolding);
            },
            destroy: function(reason)
            {
                switch(reason)
                {
                    case ConnectionI.ObjectAdapterDeactivated:
                    {
                        this.setState(StateClosing, new Ice.ObjectAdapterDeactivatedException());
                        break;
                    }
        
                    case ConnectionI.CommunicatorDestroyed:
                    {
                        this.setState(StateClosing, new Ice.CommunicatorDestroyedException());
                        break;
                    }
                }
            },
            close: function(force)
            {
                var __r = new AsyncResultBase(this._communicator, "close", this, null, null);
        
                if(force)
                {
                    this.setState(StateClosed, new Ice.ForcedCloseConnectionException());
                    __r.succeed(__r);
                }
                else
                {
                    //
                    // If we do a graceful shutdown, then we wait until all
                    // outstanding requests have been completed. Otherwise,
                    // the CloseConnectionException will cause all outstanding
                    // requests to be retried, regardless of whether the
                    // server has processed them or not.
                    //
                    this._closePromises.push(__r);
                    this.checkClose();
                }
        
                return __r;
            },
            checkClose: function()
            {
                //
                // If close(false) has been called, then we need to check if all
                // requests have completed and we can transition to StateClosing.
                // We also complete outstanding promises.
                //
                if(this._asyncRequests.size === 0 && this._closePromises.length > 0)
                {
                    this.setState(StateClosing, new Ice.CloseConnectionException());
                    for(var i = 0; i < this._closePromises.length; ++i)
                    {
                        this._closePromises[i].succeed(this._closePromises[i]);
                    }
                    this._closePromises = [];
                }
            },
            isActiveOrHolding: function()
            {
                return this._state > StateNotValidated && this._state < StateClosing;
            },
            isFinished: function()
            {
                if(this._state !== StateFinished || this._dispatchCount !== 0)
                {
                    return false;
                }
        
                Debug.assert(this._state === StateFinished);
                return true;
            },
            throwException: function()
            {
                if(this._exception !== null)
                {
                    Debug.assert(this._state >= StateClosing);
                    throw this._exception;
                }
            },
            waitUntilHolding: function()
            {
                var promise = new Promise();
                this._holdPromises.push(promise);
                this.checkState();
                return promise;
            },
            waitUntilFinished: function()
            {
                var promise = new Promise();
                this._finishedPromises.push(promise);
                this.checkState();
                return promise;
            },
            monitor: function(now, acm)
            {
                if(this._state !== StateActive)
                {
                    return;
                }
        
                //
                // We send a heartbeat if there was no activity in the last
                // (timeout / 4) period. Sending a heartbeat sooner than
                // really needed is safer to ensure that the receiver will
                // receive in time the heartbeat. Sending the heartbeat if
                // there was no activity in the last (timeout / 2) period
                // isn't enough since monitor() is called only every (timeout
                // / 2) period.
                //
                // Note that this doesn't imply that we are sending 4 heartbeats
                // per timeout period because the monitor() method is sill only
                // called every (timeout / 2) period.
                //
                if(acm.heartbeat == Ice.ACMHeartbeat.HeartbeatAlways ||
                    (acm.heartbeat != Ice.ACMHeartbeat.HeartbeatOff && this._writeStream.isEmpty() &&
                     now >= (this._acmLastActivity + acm.timeout / 4)))
                {
                    if(acm.heartbeat != Ice.ACMHeartbeat.HeartbeatOnInvocation || this._dispatchCount > 0)
                    {
                        this.heartbeat(); // Send heartbeat if idle in the last timeout / 2 period.
                    }
                }
        
                if(this._readStream.size > Protocol.headerSize || !this._writeStream.isEmpty())
                {
                    //
                    // If writing or reading, nothing to do, the connection
                    // timeout will kick-in if writes or reads don't progress.
                    // This check is necessary because the actitivy timer is
                    // only set when a message is fully read/written.
                    //
                    return;
                }
        
                if(acm.close != Ice.ACMClose.CloseOff && now >= (this._acmLastActivity + acm.timeout))
                {
                    if(acm.close == Ice.ACMClose.CloseOnIdleForceful ||
                        (acm.close != Ice.ACMClose.CloseOnIdle && this._asyncRequests.size > 0))
                    {
                        //
                        // Close the connection if we didn't receive a heartbeat in
                        // the last period.
                        //
                        this.setState(StateClosed, new Ice.ConnectionTimeoutException());
                    }
                    else if(acm.close != Ice.ACMClose.CloseOnInvocation &&
                            this._dispatchCount === 0 && this._batchRequestQueue.isEmpty() && this._asyncRequests.size === 0)
                    {
                        //
                        // The connection is idle, close it.
                        //
                        this.setState(StateClosing, new Ice.ConnectionTimeoutException());
                    }
                }
            },
            sendAsyncRequest: function(out, compress, response, batchRequestNum)
            {
                var requestId = 0;
                var os = out.__os();
        
                if(this._exception !== null)
                {
                    //
                    // If the connection is closed before we even have a chance
                    // to send our request, we always try to send the request
                    // again.
                    //
                    throw new RetryException(this._exception);
                }
        
                Debug.assert(this._state > StateNotValidated);
                Debug.assert(this._state < StateClosing);
        
                //
                // Ensure the message isn't bigger than what we can send with the
                // transport.
                //
                this._transceiver.checkSendSize(os);
        
                //
                // Notify the request that it's cancelable with this connection.
                // This will throw if the request is canceled.
                //
                out.__cancelable(this); // Notify the request that it's cancelable
        
                if(response)
                {
                    //
                    // Create a new unique request ID.
                    //
                    requestId = this._nextRequestId++;
                    if(requestId <= 0)
                    {
                        this._nextRequestId = 1;
                        requestId = this._nextRequestId++;
                    }
        
                    //
                    // Fill in the request ID.
                    //
                    os.pos = Protocol.headerSize;
                    os.writeInt(requestId);
                }
                else if(batchRequestNum > 0)
                {
                    os.pos = Protocol.headerSize;
                    os.writeInt(batchRequestNum);
                }
        
                var status;
                try
                {
                    status = this.sendMessage(OutgoingMessage.create(out, out.__os(), compress, requestId));
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        this.setState(StateClosed, ex);
                        Debug.assert(this._exception !== null);
                        throw this._exception;
                    }
                    else
                    {
                        throw ex;
                    }
                }
        
                if(response)
                {
                    //
                    // Add to the async requests map.
                    //
                    this._asyncRequests.set(requestId, out);
                }
        
                return status;
            },
            getBatchRequestQueue: function()
            {
                return this._batchRequestQueue;
            },
            flushBatchRequests: function()
            {
                var result = new ConnectionFlushBatch(this, this._communicator, "flushBatchRequests");
                result.__invoke();
                return result;
            },
            setCallback: function(callback)
            {
                if(this._state >= StateClosed)
                {
                    if(callback !== null)
                    {
                        var self = this;
                        Timer.setImmediate(function() {
                            try
                            {
                                callback.closed(this);
                            }
                            catch(ex)
                            {
                                self._logger.error("connection callback exception:\n" + ex + '\n' + self._desc);
                            }
                        });
                    }
                }
                else
                {
                    this._callback = callback;
                }
            },
            setACM: function(timeout, close, heartbeat)
            {
                if(this._monitor === null || this._state >= StateClosed)
                {
                    return;
                }
        
                if(this._state == StateActive)
                {
                    this._monitor.remove(this);
                }
                this._monitor = this._monitor.acm(timeout, close, heartbeat);
                if(this._state == StateActive)
                {
                    this._monitor.add(this);
                }
                if(this._monitor.getACM().timeout <= 0)
                {
                    this._acmLastActivity = -1; // Disable the recording of last activity.
                }
                else if(this._state == StateActive && this._acmLastActivity == -1)
                {
                    this._acmLastActivity = Date.now();
                }
            },
            getACM: function()
            {
                return this._monitor !== null ? this._monitor.getACM() :
                    new ACM(0, ACMClose.CloseOff, ACMHeartbeat.HeartbeatOff);
            },
            asyncRequestCanceled: function(outAsync, ex)
            {
                for(var i = 0; i < this._sendStreams.length; i++)
                {
                    var o = this._sendStreams[i];
                    if(o.outAsync === outAsync)
                    {
                        if(o.requestId > 0)
                        {
                            this._asyncRequests.del(o.requestId);
                        }
        
                        //
                        // If the request is being sent, don't remove it from the send streams,
                        // it will be removed once the sending is finished.
                        //
                        o.canceled();
                        if(i !== 0)
                        {
                            this._sendStreams.splice(i, 1);
                        }
                        outAsync.__completedEx(ex);
                        return; // We're done.
                    }
                }
        
                if(outAsync instanceof Ice.OutgoingAsync)
                {
                    for(var e = this._asyncRequests.entries; e !== null; e = e.next)
                    {
                        if(e.value === outAsync)
                        {
                            this._asyncRequests.del(e.key);
                            outAsync.__completedEx(ex);
                            return; // We're done.
                        }
                    }
                }
            },
            sendResponse: function(os, compressFlag)
            {
                Debug.assert(this._state > StateNotValidated);
        
                try
                {
                    if(--this._dispatchCount === 0)
                    {
                        if(this._state === StateFinished)
                        {
                            this.reap();
                        }
                        this.checkState();
                    }
        
                    if(this._state >= StateClosed)
                    {
                        Debug.assert(this._exception !== null);
                        throw this._exception;
                    }
        
                    this.sendMessage(OutgoingMessage.createForStream(os, compressFlag !== 0, true));
        
                    if(this._state === StateClosing && this._dispatchCount === 0)
                    {
                        this.initiateShutdown();
                    }
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        this.setState(StateClosed, ex);
                    }
                    else
                    {
                        throw ex;
                    }
                }
            },
            sendNoResponse: function()
            {
                Debug.assert(this._state > StateNotValidated);
                try
                {
                    if(--this._dispatchCount === 0)
                    {
                        if(this._state === StateFinished)
                        {
                            this.reap();
                        }
                        this.checkState();
                    }
        
                    if(this._state >= StateClosed)
                    {
                        Debug.assert(this._exception !== null);
                        throw this._exception;
                    }
        
                    if(this._state === StateClosing && this._dispatchCount === 0)
                    {
                        this.initiateShutdown();
                    }
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        this.setState(StateClosed, ex);
                    }
                    else
                    {
                        throw ex;
                    }
                }
            },
            endpoint: function()
            {
                return this._endpoint;
            },
            setAdapter: function(adapter)
            {
                if(this._state <= StateNotValidated || this._state >= StateClosing)
                {
                    return;
                }
                Debug.assert(this._state < StateClosing);
        
                this._adapter = adapter;
        
                if(this._adapter !== null)
                {
                    this._servantManager = this._adapter.getServantManager();
                    if(this._servantManager === null)
                    {
                        this._adapter = null;
                    }
                }
                else
                {
                    this._servantManager = null;
                }
            },
            getAdapter: function()
            {
                return this._adapter;
            },
            getEndpoint: function()
            {
                return this._endpoint;
            },
            createProxy: function(ident)
            {
                //
                // Create a reference and return a reverse proxy for this
                // reference.
                //
                return this._instance.proxyFactory().referenceToProxy(
                    this._instance.referenceFactory().createFixed(ident, this));
            },
            message: function(operation)
            {
                if(this._state >= StateClosed)
                {
                    return;
                }
        
                this.unscheduleTimeout(operation);
        
                //
                // Keep reading until no more data is available.
                //
                this._hasMoreData.value = (operation & SocketOperation.Read) !== 0;
        
                var info = null;
                try
                {
                    if((operation & SocketOperation.Write) !== 0 && this._writeStream.buffer.remaining > 0)
                    {
                        if(!this.write(this._writeStream.buffer))
                        {
                            Debug.assert(!this._writeStream.isEmpty());
                            this.scheduleTimeout(SocketOperation.Write, this._endpoint.timeout());
                            return;
                        }
                        Debug.assert(this._writeStream.buffer.remaining === 0);
                    }
                    if((operation & SocketOperation.Read) !== 0 && !this._readStream.isEmpty())
                    {
                        if(this._readHeader) // Read header if necessary.
                        {
                            if(!this.read(this._readStream.buffer))
                            {
                                //
                                // We didn't get enough data to complete the header.
                                //
                                return;
                            }
        
                            Debug.assert(this._readStream.buffer.remaining === 0);
                            this._readHeader = false;
        
                            var pos = this._readStream.pos;
                            if(pos < Protocol.headerSize)
                            {
                                //
                                // This situation is possible for small UDP packets.
                                //
                                throw new Ice.IllegalMessageSizeException();
                            }
        
                            this._readStream.pos = 0;
                            var magic0 = this._readStream.readByte();
                            var magic1 = this._readStream.readByte();
                            var magic2 = this._readStream.readByte();
                            var magic3 = this._readStream.readByte();
                            if(magic0 !== Protocol.magic[0] || magic1 !== Protocol.magic[1] ||
                                magic2 !== Protocol.magic[2] || magic3 !== Protocol.magic[3])
                            {
                                var bme = new Ice.BadMagicException();
                                bme.badMagic = Ice.Buffer.createNative([magic0, magic1, magic2, magic3]);
                                throw bme;
                            }
        
                            this._readProtocol.__read(this._readStream);
                            Protocol.checkSupportedProtocol(this._readProtocol);
        
                            this._readProtocolEncoding.__read(this._readStream);
                            Protocol.checkSupportedProtocolEncoding(this._readProtocolEncoding);
        
                            this._readStream.readByte(); // messageType
                            this._readStream.readByte(); // compress
                            var size = this._readStream.readInt();
                            if(size < Protocol.headerSize)
                            {
                                throw new Ice.IllegalMessageSizeException();
                            }
                            if(size > this._messageSizeMax)
                            {
                                ExUtil.throwMemoryLimitException(size, this._messageSizeMax);
                            }
                            if(size > this._readStream.size)
                            {
                                this._readStream.resize(size);
                            }
                            this._readStream.pos = pos;
                        }
        
                        if(this._readStream.pos != this._readStream.size)
                        {
                            if(this._endpoint.datagram())
                            {
                                throw new Ice.DatagramLimitException(); // The message was truncated.
                            }
                            else
                            {
                                if(!this.read(this._readStream.buffer))
                                {
                                    Debug.assert(!this._readStream.isEmpty());
                                    this.scheduleTimeout(SocketOperation.Read, this._endpoint.timeout());
                                    return;
                                }
                                Debug.assert(this._readStream.buffer.remaining === 0);
                            }
                        }
                    }
        
                    if(this._state <= StateNotValidated)
                    {
                        if(this._state === StateNotInitialized && !this.initialize())
                        {
                            return;
                        }
        
                        if(this._state <= StateNotValidated && !this.validate())
                        {
                            return;
                        }
        
                        this._transceiver.unregister();
        
                        //
                        // We start out in holding state.
                        //
                        this.setState(StateHolding);
                        if(this._startPromise !== null)
                        {
                            ++this._dispatchCount;
                        }
                    }
                    else
                    {
                        Debug.assert(this._state <= StateClosing);
        
                        //
                        // We parse messages first, if we receive a close
                        // connection message we won't send more messages.
                        //
                        if((operation & SocketOperation.Read) !== 0)
                        {
                            info = this.parseMessage();
                        }
        
                        if((operation & SocketOperation.Write) !== 0)
                        {
                            this.sendNextMessage();
                        }
                    }
                }
                catch(ex)
                {
                    if(ex instanceof Ice.DatagramLimitException) // Expected.
                    {
                        if(this._warnUdp)
                        {
                            this._logger.warning("maximum datagram size of " + this._readStream.pos + " exceeded");
                        }
                        this._readStream.resize(Protocol.headerSize);
                        this._readStream.pos = 0;
                        this._readHeader = true;
                        return;
                    }
                    else if(ex instanceof Ice.SocketException)
                    {
                        this.setState(StateClosed, ex);
                        return;
                    }
                    else if(ex instanceof Ice.LocalException)
                    {
                        if(this._endpoint.datagram())
                        {
                            if(this._warn)
                            {
                                this._logger.warning("datagram connection exception:\n" + ex + '\n' + this._desc);
                            }
                            this._readStream.resize(Protocol.headerSize);
                            this._readStream.pos = 0;
                            this._readHeader = true;
                        }
                        else
                        {
                            this.setState(StateClosed, ex);
                        }
                        return;
                    }
                    else
                    {
                        throw ex;
                    }
                }
        
                if(this._acmLastActivity > 0)
                {
                    this._acmLastActivity = Date.now();
                }
        
                this.dispatch(info);
        
                if(this._hasMoreData.value)
                {
                    var self = this;
                    Timer.setImmediate(function() { self.message(SocketOperation.Read); }); // Don't tie up the thread.
                }
            },
            dispatch: function(info)
            {
                var count = 0;
                //
                // Notify the factory that the connection establishment and
                // validation has completed.
                //
                if(this._startPromise !== null)
                {
                    this._startPromise.succeed();
                    this._startPromise = null;
                    ++count;
                }
        
                if(info !== null)
                {
                    if(info.outAsync !== null)
                    {
                        info.outAsync.__completed(info.stream);
                        ++count;
                    }
        
                    if(info.invokeNum > 0)
                    {
                        this.invokeAll(info.stream, info.invokeNum, info.requestId, info.compress, info.servantManager,
                                    info.adapter);
        
                        //
                        // Don't increase count, the dispatch count is
                        // decreased when the incoming reply is sent.
                        //
                    }
        
                    if(info.heartbeatCallback)
                    {
                        try
                        {
                            info.heartbeatCallback.heartbeat(this);
                        }
                        catch(ex)
                        {
                            this._logger.error("connection callback exception:\n" + ex + '\n' + this._desc);
                        }
                        info.heartbeatCallback = null;
                        ++count;
                    }
                }
        
                //
                // Decrease dispatch count.
                //
                if(count > 0)
                {
                    this._dispatchCount -= count;
                    if(this._dispatchCount === 0)
                    {
                        if(this._state === StateClosing && !this._shutdownInitiated)
                        {
                            try
                            {
                                this.initiateShutdown();
                            }
                            catch(ex)
                            {
                                if(ex instanceof Ice.LocalException)
                                {
                                    this.setState(StateClosed, ex);
                                }
                                else
                                {
                                    throw ex;
                                }
                            }
                        }
                        else if(this._state === StateFinished)
                        {
                            this.reap();
                        }
                        this.checkState();
                    }
                }
            },
            finish: function()
            {
                Debug.assert(this._state === StateClosed);
                this.unscheduleTimeout(SocketOperation.Read | SocketOperation.Write | SocketOperation.Connect);
        
                var s;
                var traceLevels = this._instance.traceLevels();
                if(!this._initialized)
                {
                    if(traceLevels.network >= 2)
                    {
                        s = [];
                        s.push("failed to establish ");
                        s.push(this._endpoint.protocol());
                        s.push(" connection\n");
                        s.push(this.toString());
                        s.push("\n");
                        s.push(this._exception.toString());
                        this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(""));
                    }
                }
                else
                {
                    if(traceLevels.network >= 1)
                    {
                        s = [];
                        s.push("closed ");
                        s.push(this._endpoint.protocol());
                        s.push(" connection\n");
                        s.push(this.toString());
        
                        //
                        // Trace the cause of unexpected connection closures
                        //
                        if(!(this._exception instanceof Ice.CloseConnectionException ||
                             this._exception instanceof Ice.ForcedCloseConnectionException ||
                             this._exception instanceof Ice.ConnectionTimeoutException ||
                             this._exception instanceof Ice.CommunicatorDestroyedException ||
                             this._exception instanceof Ice.ObjectAdapterDeactivatedException))
                        {
                            s.push("\n");
                            s.push(this._exception.toString());
                        }
        
                        this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(""));
                    }
                }
        
                if(this._startPromise !== null)
                {
                    this._startPromise.fail(this._exception);
                    this._startPromise = null;
                }
        
                if(this._sendStreams.length > 0)
                {
                    if(!this._writeStream.isEmpty())
                    {
                        //
                        // Return the stream to the outgoing call. This is important for
                        // retriable AMI calls which are not marshalled again.
                        //
                        var message = this._sendStreams[0];
                        this._writeStream.swap(message.stream);
                    }
        
                    //
                    // NOTE: for twoway requests which are not sent, finished can be called twice: the
                    // first time because the outgoing is in the _sendStreams set and the second time
                    // because it's either in the _requests/_asyncRequests set. This is fine, only the
                    // first call should be taken into account by the implementation of finished.
                    //
                    for(var i = 0; i < this._sendStreams.length; ++i)
                    {
                        var p = this._sendStreams[i];
                        if(p.requestId > 0)
                        {
                            this._asyncRequests.del(p.requestId);
                        }
                        p.completed(this._exception);
                    }
                    this._sendStreams = [];
                }
        
                for(var e = this._asyncRequests.entries; e !== null; e = e.next)
                {
                    e.value.__completedEx(this._exception);
                }
                this._asyncRequests.clear();
        
                //
                // Don't wait to be reaped to reclaim memory allocated by read/write streams.
                //
                this._readStream.clear();
                this._readStream.buffer.clear();
                this._writeStream.clear();
                this._writeStream.buffer.clear();
        
                if(this._callback !== null)
                {
                    try
                    {
                        this._callback.closed(this);
                    }
                    catch(ex)
                    {
                        this._logger.error("connection callback exception:\n" + ex + '\n' + this._desc);
                    }
                    this._callback = null;
                }
        
                //
                // This must be done last as this will cause waitUntilFinished() to return (and communicator
                // objects such as the timer might be destroyed too).
                //
                if(this._dispatchCount === 0)
                {
                    this.reap();
                }
                this.setState(StateFinished);
            },
            toString: function()
            {
                return this._desc;
            },
            timedOut: function(event)
            {
                if(this._state <= StateNotValidated)
                {
                    this.setState(StateClosed, new Ice.ConnectTimeoutException());
                }
                else if(this._state < StateClosing)
                {
                    this.setState(StateClosed, new Ice.TimeoutException());
                }
                else if(this._state === StateClosing)
                {
                    this.setState(StateClosed, new Ice.CloseTimeoutException());
                }
            },
            type: function()
            {
                return this._type;
            },
            timeout: function()
            {
                return this._endpoint.timeout();
            },
            getInfo: function()
            {
                if(this._state >= StateClosed)
                {
                    throw this._exception;
                }
                var info = this._transceiver.getInfo();
                info.adapterName = this._adapter !== null ? this._adapter.getName() : "";
                info.incoming = this._incoming;
                return info;
            },
            setBufferSize: function(rcvSize, sndSize)
            {
                if(this._state >= StateClosed)
                {
                    throw this._exception;
                }
                this._transceiver.setBufferSize(rcvSize, sndSize);
            },
            exception: function(ex)
            {
                this.setState(StateClosed, ex);
            },
            invokeException: function(ex, invokeNum)
            {
                //
                // Fatal exception while invoking a request. Since sendResponse/sendNoResponse isn't
                // called in case of a fatal exception we decrement this._dispatchCount here.
                //
        
                this.setState(StateClosed, ex);
        
                if(invokeNum > 0)
                {
                    Debug.assert(this._dispatchCount > 0);
                    this._dispatchCount -= invokeNum;
                    Debug.assert(this._dispatchCount >= 0);
                    if(this._dispatchCount === 0)
                    {
                        if(this._state === StateFinished)
                        {
                            this.reap();
                        }
                        this.checkState();
                    }
                }
            },
            setState: function(state, ex)
            {
                if(ex !== undefined)
                {
                    Debug.assert(ex instanceof Ice.LocalException);
        
                    //
                    // If setState() is called with an exception, then only closed
                    // and closing states are permissible.
                    //
                    Debug.assert(state >= StateClosing);
        
                    if(this._state === state) // Don't switch twice.
                    {
                        return;
                    }
        
                    if(this._exception === null)
                    {
                        this._exception = ex;
        
                        //
                        // We don't warn if we are not validated.
                        //
                        if(this._warn && this._validated)
                        {
                            //
                            // Don't warn about certain expected exceptions.
                            //
                            if(!(this._exception instanceof Ice.CloseConnectionException ||
                                 this._exception instanceof Ice.ForcedCloseConnectionException ||
                                 this._exception instanceof Ice.ConnectionTimeoutException ||
                                 this._exception instanceof Ice.CommunicatorDestroyedException ||
                                 this._exception instanceof Ice.ObjectAdapterDeactivatedException ||
                                 (this._exception instanceof Ice.ConnectionLostException && this._state === StateClosing)))
                            {
                                this.warning("connection exception", this._exception);
                            }
                        }
                    }
        
                    //
                    // We must set the new state before we notify requests of any
                    // exceptions. Otherwise new requests may retry on a
                    // connection that is not yet marked as closed or closing.
                    //
                }
        
                //
                // We don't want to send close connection messages if the endpoint
                // only supports oneway transmission from client to server.
                //
                if(this._endpoint.datagram() && state === StateClosing)
                {
                    state = StateClosed;
                }
        
                //
                // Skip graceful shutdown if we are destroyed before validation.
                //
                if(this._state <= StateNotValidated && state === StateClosing)
                {
                    state = StateClosed;
                }
        
                if(this._state === state) // Don't switch twice.
                {
                    return;
                }
        
                try
                {
                    switch(state)
                    {
                    case StateNotInitialized:
                    {
                        Debug.assert(false);
                        break;
                    }
        
                    case StateNotValidated:
                    {
                        if(this._state !== StateNotInitialized)
                        {
                            Debug.assert(this._state === StateClosed);
                            return;
                        }
                        //
                        // Register to receive validation message.
                        //
                        if(!this._endpoint.datagram() && !this._incoming)
                        {
                            //
                            // Once validation is complete, a new connection starts out in the
                            // Holding state. We only want to register the transceiver now if we
                            // need to receive data in order to validate the connection.
                            //
                            this._transceiver.register();
                        }
                        break;
                    }
        
                    case StateActive:
                    {
                        //
                        // Can only switch from holding or not validated to
                        // active.
                        //
                        if(this._state !== StateHolding && this._state !== StateNotValidated)
                        {
                            return;
                        }
                        this._transceiver.register();
                        break;
                    }
        
                    case StateHolding:
                    {
                        //
                        // Can only switch from active or not validated to
                        // holding.
                        //
                        if(this._state !== StateActive && this._state !== StateNotValidated)
                        {
                            return;
                        }
                        if(this._state === StateActive)
                        {
                            this._transceiver.unregister();
                        }
                        break;
                    }
        
                    case StateClosing:
                    {
                        //
                        // Can't change back from closed.
                        //
                        if(this._state >= StateClosed)
                        {
                            return;
                        }
                        if(this._state === StateHolding)
                        {
                            // We need to continue to read in closing state.
                            this._transceiver.register();
                        }
                        break;
                    }
        
                    case StateClosed:
                    {
                        if(this._state === StateFinished)
                        {
                            return;
                        }
                        this._batchRequestQueue.destroy(this._exception);
                        this._transceiver.unregister();
                        break;
                    }
        
                    case StateFinished:
                    {
                        Debug.assert(this._state === StateClosed);
                        this._transceiver.close();
                        this._communicator = null;
                        break;
                    }
                    }
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        var msg = "unexpected connection exception:\n " + this._desc + "\n" + ex.toString();
                        this._instance.initializationData().logger.error(msg);
                    }
                    else
                    {
                        throw ex;
                    }
                }
        
                //
                // We only register with the connection monitor if our new state
                // is StateActive. Otherwise we unregister with the connection
                // monitor, but only if we were registered before, i.e., if our
                // old state was StateActive.
                //
                if(this._monitor !== null)
                {
                    if(state === StateActive)
                    {
                        this._monitor.add(this);
                        if(this._acmLastActivity > 0)
                        {
                            this._acmLastActivity = Date.now();
                        }
                    }
                    else if(this._state === StateActive)
                    {
                        this._monitor.remove(this);
                    }
                }
        
                this._state = state;
        
                if(this._state === StateClosing && this._dispatchCount === 0)
                {
                    try
                    {
                        this.initiateShutdown();
                    }
                    catch(ex)
                    {
                        if(ex instanceof Ice.LocalException)
                        {
                            this.setState(StateClosed, ex);
                        }
                        else
                        {
                            throw ex;
                        }
                    }
                }
                else if(this._state === StateClosed)
                {
                    this.finish();
                }
        
                this.checkState();
            },
            initiateShutdown: function()
            {
                Debug.assert(this._state === StateClosing);
                Debug.assert(this._dispatchCount === 0);
                Debug.assert(!this._shutdownInitiated);
        
                if(!this._endpoint.datagram())
                {
                    //
                    // Before we shut down, we send a close connection
                    // message.
                    //
                    var os = new BasicStream(this._instance, Protocol.currentProtocolEncoding);
                    os.writeBlob(Protocol.magic);
                    Protocol.currentProtocol.__write(os);
                    Protocol.currentProtocolEncoding.__write(os);
                    os.writeByte(Protocol.closeConnectionMsg);
                    os.writeByte(0); // compression status: always report 0 for CloseConnection.
                    os.writeInt(Protocol.headerSize); // Message size.
        
                    var status = this.sendMessage(OutgoingMessage.createForStream(os, false, false));
                    if((status & AsyncStatus.Sent) > 0)
                    {
                        //
                        // Schedule the close timeout to wait for the peer to close the connection.
                        //
                        this.scheduleTimeout(SocketOperation.Write, this.closeTimeout());
                    }
        
                    //
                    // The CloseConnection message should be sufficient. Closing the write
                    // end of the socket is probably an artifact of how things were done
                    // in IIOP. In fact, shutting down the write end of the socket causes
                    // problems on Windows by preventing the peer from using the socket.
                    // For example, the peer is no longer able to continue writing a large
                    // message after the socket is shutdown.
                    //
                    //this._transceiver.shutdownWrite();
                }
            },
            heartbeat: function()
            {
                Debug.assert(this._state === StateActive);
        
                if(!this._endpoint.datagram())
                {
                    var os = new BasicStream(this._instance, Protocol.currentProtocolEncoding);
                    os.writeBlob(Protocol.magic);
                    Protocol.currentProtocol.__write(os);
                    Protocol.currentProtocolEncoding.__write(os);
                    os.writeByte(Protocol.validateConnectionMsg);
                    os.writeByte(0);
                    os.writeInt(Protocol.headerSize); // Message size.
                    try
                    {
                        this.sendMessage(OutgoingMessage.createForStream(os, false, false));
                    }
                    catch(ex)
                    {
                        this.setState(StateClosed, ex);
                        Debug.assert(this._exception !== null);
                    }
                }
            },
            initialize: function()
            {
                var s = this._transceiver.initialize(this._readStream.buffer, this._writeStream.buffer);
                if(s != SocketOperation.None)
                {
                    this.scheduleTimeout(s, this.connectTimeout());
                    return false;
                }
        
                //
                // Update the connection description once the transceiver is initialized.
                //
                this._desc = this._transceiver.toString();
                this._initialized = true;
                this.setState(StateNotValidated);
                return true;
            },
            validate: function()
            {
                if(!this._endpoint.datagram()) // Datagram connections are always implicitly validated.
                {
                    if(this._adapter !== null) // The server side has the active role for connection validation.
                    {
                        if(this._writeStream.size === 0)
                        {
                            this._writeStream.writeBlob(Protocol.magic);
                            Protocol.currentProtocol.__write(this._writeStream);
                            Protocol.currentProtocolEncoding.__write(this._writeStream);
                            this._writeStream.writeByte(Protocol.validateConnectionMsg);
                            this._writeStream.writeByte(0); // Compression status (always zero for validate connection).
                            this._writeStream.writeInt(Protocol.headerSize); // Message size.
                            TraceUtil.traceSend(this._writeStream, this._logger, this._traceLevels);
                            this._writeStream.prepareWrite();
                        }
        
                        if(this._writeStream.pos != this._writeStream.size && !this.write(this._writeStream.buffer))
                        {
                            this.scheduleTimeout(SocketOperation.Write, this.connectTimeout());
                            return false;
                        }
                    }
                    else // The client side has the passive role for connection validation.
                    {
                        if(this._readStream.size === 0)
                        {
                            this._readStream.resize(Protocol.headerSize);
                            this._readStream.pos = 0;
                        }
        
                        if(this._readStream.pos !== this._readStream.size &&
                            !this.read(this._readStream.buffer))
                        {
                            this.scheduleTimeout(SocketOperation.Read, this.connectTimeout());
                            return false;
                        }
        
                        Debug.assert(this._readStream.pos === Protocol.headerSize);
                        this._readStream.pos = 0;
                        var m = this._readStream.readBlob(4);
                        if(m[0] !== Protocol.magic[0] || m[1] !== Protocol.magic[1] ||
                            m[2] !== Protocol.magic[2] || m[3] !== Protocol.magic[3])
                        {
                            var bme = new Ice.BadMagicException();
                            bme.badMagic = m;
                            throw bme;
                        }
        
                        this._readProtocol.__read(this._readStream);
                        Protocol.checkSupportedProtocol(this._readProtocol);
        
                        this._readProtocolEncoding.__read(this._readStream);
                        Protocol.checkSupportedProtocolEncoding(this._readProtocolEncoding);
        
                        var messageType = this._readStream.readByte();
                        if(messageType !== Protocol.validateConnectionMsg)
                        {
                            throw new Ice.ConnectionNotValidatedException();
                        }
                        this._readStream.readByte(); // Ignore compression status for validate connection.
                        var size = this._readStream.readInt();
                        if(size !== Protocol.headerSize)
                        {
                            throw new Ice.IllegalMessageSizeException();
                        }
                        TraceUtil.traceRecv(this._readStream, this._logger, this._traceLevels);
                        this._validated = true;
                    }
                }
        
                this._writeStream.resize(0);
                this._writeStream.pos = 0;
        
                this._readStream.resize(Protocol.headerSize);
                this._readHeader = true;
                this._readStream.pos = 0;
        
                var traceLevels = this._instance.traceLevels();
                if(traceLevels.network >= 1)
                {
                    var s = [];
                    if(this._endpoint.datagram())
                    {
                        s.push("starting to send ");
                        s.push(this._endpoint.protocol());
                        s.push(" messages\n");
                        s.push(this._transceiver.toDetailedString());
                    }
                    else
                    {
                        s = [];
                        s.push("established ");
                        s.push(this._endpoint.protocol());
                        s.push(" connection\n");
                        s.push(this.toString());
                    }
                    this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(""));
                }
        
                return true;
            },
            sendNextMessage: function()
            {
                if(this._sendStreams.length === 0)
                {
                    return;
                }
        
                Debug.assert(!this._writeStream.isEmpty() && this._writeStream.pos === this._writeStream.size);
                try
                {
                    while(true)
                    {
                        //
                        // Notify the message that it was sent.
                        //
                        var message = this._sendStreams.shift();
                        this._writeStream.swap(message.stream);
                        message.sent();
        
                        //
                        // If there's nothing left to send, we're done.
                        //
                        if(this._sendStreams.length === 0)
                        {
                            break;
                        }
        
                        //
                        // If we are in the closed state, don't continue sending.
                        //
                        // The connection can be in the closed state if parseMessage
                        // (called before sendNextMessage by message()) closes the
                        // connection.
                        //
                        if(this._state >= StateClosed)
                        {
                            return;
                        }
        
                        //
                        // Otherwise, prepare the next message stream for writing.
                        //
                        message = this._sendStreams[0];
                        Debug.assert(!message.prepared);
                        var stream = message.stream;
        
                        stream.pos = 10;
                        stream.writeInt(stream.size);
                        stream.prepareWrite();
                        message.prepared = true;
        
                        if(message.outAsync !== null)
                        {
                            TraceUtil.trace("sending asynchronous request", stream, this._logger, this._traceLevels);
                        }
                        else
                        {
                            TraceUtil.traceSend(stream, this._logger, this._traceLevels);
                        }
                        this._writeStream.swap(message.stream);
        
                        //
                        // Send the message.
                        //
                        if(this._writeStream.pos != this._writeStream.size && !this.write(this._writeStream.buffer))
                        {
                            Debug.assert(!this._writeStream.isEmpty());
                            this.scheduleTimeout(SocketOperation.Write, this._endpoint.timeout());
                            return;
                        }
                    }
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        this.setState(StateClosed, ex);
                        return;
                    }
                    else
                    {
                        throw ex;
                    }
                }
        
                Debug.assert(this._writeStream.isEmpty());
        
                //
                // If all the messages were sent and we are in the closing state, we schedule
                // the close timeout to wait for the peer to close the connection.
                //
                if(this._state === StateClosing)
                {
                    this.scheduleTimeout(SocketOperation.Write, this.closeTimeout());
                }
            },
            sendMessage: function(message)
            {
                if(this._sendStreams.length > 0)
                {
                    message.doAdopt();
                    this._sendStreams.push(message);
                    return AsyncStatus.Queued;
                }
                Debug.assert(this._state < StateClosed);
        
                Debug.assert(!message.prepared);
        
                var stream = message.stream;
                stream.pos = 10;
                stream.writeInt(stream.size);
                stream.prepareWrite();
                message.prepared = true;
        
                if(message.outAsync)
                {
                    TraceUtil.trace("sending asynchronous request", message.stream, this._logger, this._traceLevels);
                }
                else
                {
                    TraceUtil.traceSend(message.stream, this._logger, this._traceLevels);
                }
        
                if(this.write(message.stream.buffer))
                {
                    //
                    // Entire buffer was written immediately.
                    //
                    message.sent();
        
                    if(this._acmLastActivity > 0)
                    {
                        this._acmLastActivity = Date.now();
                    }
                    return AsyncStatus.Sent;
                }
                message.doAdopt();
        
                this._writeStream.swap(message.stream);
                this._sendStreams.push(message);
                this.scheduleTimeout(SocketOperation.Write, this._endpoint.timeout());
        
                return AsyncStatus.Queued;
            },
            parseMessage: function()
            {
                Debug.assert(this._state > StateNotValidated && this._state < StateClosed);
        
                var info = new MessageInfo(this._instance);
        
                this._readStream.swap(info.stream);
                this._readStream.resize(Protocol.headerSize);
                this._readStream.pos = 0;
                this._readHeader = true;
        
                //
                // Connection is validated on first message. This is only used by
                // setState() to check wether or not we can print a connection
                // warning (a client might close the connection forcefully if the
                // connection isn't validated).
                //
                this._validated = true;
        
                Debug.assert(info.stream.pos === info.stream.size);
        
                try
                {
                    //
                    // We don't need to check magic and version here. This has already
                    // been done by the caller.
                    //
                    info.stream.pos = 8;
                    var messageType = info.stream.readByte();
                    info.compress = info.stream.readByte();
                    if(info.compress === 2)
                    {
                        var ex = new Ice.FeatureNotSupportedException();
                        ex.unsupportedFeature = "Cannot uncompress compressed message";
                        throw ex;
                    }
                    info.stream.pos = Protocol.headerSize;
        
                    switch(messageType)
                    {
                        case Protocol.closeConnectionMsg:
                        {
                            TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);
                            if(this._endpoint.datagram())
                            {
                                if(this._warn)
                                {
                                    this._logger.warning("ignoring close connection message for datagram connection:\n" +
                                                        this._desc);
                                }
                            }
                            else
                            {
                                this.setState(StateClosed, new Ice.CloseConnectionException());
                            }
                            break;
                        }
        
                        case Protocol.requestMsg:
                        {
                            if(this._state === StateClosing)
                            {
                                TraceUtil.trace("received request during closing\n" +
                                                "(ignored by server, client will retry)",
                                                info.stream, this._logger, this._traceLevels);
                            }
                            else
                            {
                                TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);
                                info.requestId = info.stream.readInt();
                                info.invokeNum = 1;
                                info.servantManager = this._servantManager;
                                info.adapter = this._adapter;
                                ++this._dispatchCount;
                            }
                            break;
                        }
        
                        case Protocol.requestBatchMsg:
                        {
                            if(this._state === StateClosing)
                            {
                                TraceUtil.trace("received batch request during closing\n" +
                                                "(ignored by server, client will retry)",
                                                info.stream, this._logger, this._traceLevels);
                            }
                            else
                            {
                                TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);
                                info.invokeNum = info.stream.readInt();
                                if(info.invokeNum < 0)
                                {
                                    info.invokeNum = 0;
                                    throw new Ice.UnmarshalOutOfBoundsException();
                                }
                                info.servantManager = this._servantManager;
                                info.adapter = this._adapter;
                                this._dispatchCount += info.invokeNum;
                            }
                            break;
                        }
        
                        case Protocol.replyMsg:
                        {
                            TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);
                            info.requestId = info.stream.readInt();
                            info.outAsync = this._asyncRequests.get(info.requestId);
                            if(info.outAsync)
                            {
                                this._asyncRequests.del(info.requestId);
                                ++this._dispatchCount;
                            }
                            else
                            {
                                info = null;
                            }
                            this.checkClose();
                            break;
                        }
        
                        case Protocol.validateConnectionMsg:
                        {
                            TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);
                            if(this._callback !== null)
                            {
                                info.heartbeatCallback = this._callback;
                                ++this._dispatchCount;
                            }
                            break;
                        }
        
                        default:
                        {
                            TraceUtil.trace("received unknown message\n(invalid, closing connection)",
                                            info.stream, this._logger, this._traceLevels);
                            throw new Ice.UnknownMessageException();
                        }
                    }
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        if(this._endpoint.datagram())
                        {
                            if(this._warn)
                            {
                                this._logger.warning("datagram connection exception:\n" + ex + '\n' + this._desc);
                            }
                        }
                        else
                        {
                            this.setState(StateClosed, ex);
                        }
                    }
                    else
                    {
                        throw ex;
                    }
                }
        
                return info;
            },
            invokeAll: function(stream, invokeNum, requestId, compress, servantManager, adapter)
            {
                var inc = null;
                try
                {
                    while(invokeNum > 0)
                    {
                        //
                        // Prepare the invocation.
                        //
                        var response = !this._endpoint.datagram() && requestId !== 0;
                        inc = new IncomingAsync(this._instance, this, adapter, response, compress, requestId);
        
                        //
                        // Dispatch the invocation.
                        //
                        inc.invoke(servantManager, stream);
        
                        --invokeNum;
                        inc = null;
                    }
        
                    stream.clear();
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        this.invokeException(ex, invokeNum);
                    }
                    else
                    {
                        throw ex;
                    }
                }
            },
            scheduleTimeout: function(op, timeout)
            {
                if(timeout < 0)
                {
                    return;
                }
        
                var self = this;
                if((op & SocketOperation.Read) !== 0)
                {
                    this._readTimeoutId = this._timer.schedule(function() { self.timedOut(); }, timeout);
                    this._readTimeoutScheduled = true;
                }
                if((op & (SocketOperation.Write | SocketOperation.Connect)) !== 0)
                {
                    this._writeTimeoutId = this._timer.schedule(function() { self.timedOut(); }, timeout);
                    this._writeTimeoutScheduled = true;
                }
            },
            unscheduleTimeout: function(op)
            {
                if((op & SocketOperation.Read) !== 0 && this._readTimeoutScheduled)
                {
                    this._timer.cancel(this._readTimeoutId);
                    this._readTimeoutScheduled = false;
                }
                if((op & (SocketOperation.Write | SocketOperation.Connect)) !== 0 && this._writeTimeoutScheduled)
                {
                    this._timer.cancel(this._writeTimeoutId);
                    this._writeTimeoutScheduled = false;
                }
            },
            connectTimeout: function()
            {
                var defaultsAndOverrides = this._instance.defaultsAndOverrides();
                if(defaultsAndOverrides.overrideConnectTimeout)
                {
                    return defaultsAndOverrides.overrideConnectTimeoutValue;
                }
                else
                {
                    return this._endpoint.timeout();
                }
            },
            closeTimeout: function()
            {
                var defaultsAndOverrides = this._instance.defaultsAndOverrides();
                if(defaultsAndOverrides.overrideCloseTimeout)
                {
                    return defaultsAndOverrides.overrideCloseTimeoutValue;
                }
                else
                {
                    return this._endpoint.timeout();
                }
            },
            warning: function(msg, ex)
            {
                this._logger.warning(msg + ":\n" + this._desc + "\n" + ex.toString());
            },
            checkState: function()
            {
                if(this._state < StateHolding || this._dispatchCount > 0)
                {
                    return;
                }
        
                var i;
                if(this._holdPromises.length > 0)
                {
                    for(i = 0; i < this._holdPromises.length; ++i)
                    {
                        this._holdPromises[i].succeed();
                    }
                    this._holdPromises = [];
                }
        
                //
                // We aren't finished until the state is finished and all
                // outstanding requests are completed. Otherwise we couldn't
                // guarantee that there are no outstanding calls when deactivate()
                // is called on the servant locators.
                //
                if(this._state === StateFinished && this._finishedPromises.length > 0)
                {
                    //
                    // Clear the OA. See bug 1673 for the details of why this is necessary.
                    //
                    this._adapter = null;
        
                    for(i = 0; i < this._finishedPromises.length; ++i)
                    {
                        this._finishedPromises[i].succeed();
                    }
                    this._finishedPromises = [];
                }
            },
            reap: function()
            {
                if(this._monitor !== null)
                {
                    this._monitor.reap(this);
                }
            },
            read: function(buf)
            {
                var start = buf.position;
                var ret = this._transceiver.read(buf, this._hasMoreData);
                if(this._instance.traceLevels().network >= 3 && buf.position != start)
                {
                    var s = [];
                    s.push("received ");
                    if(this._endpoint.datagram())
                    {
                        s.push(buf.limit);
                    }
                    else
                    {
                        s.push(buf.position - start);
                        s.push(" of ");
                        s.push(buf.limit - start);
                    }
                    s.push(" bytes via ");
                    s.push(this._endpoint.protocol());
                    s.push("\n");
                    s.push(this.toString());
                    this._instance.initializationData().logger.trace(this._instance.traceLevels().networkCat, s.join(""));
                }
                return ret;
            },
            write: function(buf)
            {
                var start = buf.position;
                var ret = this._transceiver.write(buf);
                if(this._instance.traceLevels().network >= 3 && buf.position != start)
                {
                    var s = [];
                    s.push("sent ");
                    s.push(buf.position - start);
                    if(!this._endpoint.datagram())
                    {
                        s.push(" of ");
                        s.push(buf.limit - start);
                    }
                    s.push(" bytes via ");
                    s.push(this._endpoint.protocol());
                    s.push("\n");
                    s.push(this.toString());
                    this._instance.initializationData().logger.trace(this._instance.traceLevels().networkCat, s.join(""));
                }
                return ret;
            }
        });
        
        // DestructionReason.
        ConnectionI.ObjectAdapterDeactivated = 0;
        ConnectionI.CommunicatorDestroyed = 1;
        
        Ice.ConnectionI = ConnectionI;
        
        var OutgoingMessage = Class({
            __init__: function()
            {
                this.stream = null;
                this.outAsync = null;
                this.compress = false;
                this.requestId = 0;
                this.prepared = false;
            },
            canceled: function()
            {
                Debug.assert(this.outAsync !== null);
                this.outAsync = null;
            },
            doAdopt: function()
            {
                if(this.adopt)
                {
                    var stream = new BasicStream(this.stream.instance, Protocol.currentProtocolEncoding);
                    stream.swap(this.stream);
                    this.stream = stream;
                    this.adopt = false;
                }
            },
            sent: function()
            {
                if(this.outAsync !== null)
                {
                    this.outAsync.__sent();
                }
            },
            completed: function(ex)
            {
                if(this.outAsync !== null)
                {
                    this.outAsync.__completedEx(ex);
                }
            }
        });
        
        OutgoingMessage.createForStream = function(stream, compress, adopt)
        {
            var m = new OutgoingMessage();
            m.stream = stream;
            m.compress = compress;
            m.adopt = adopt;
            m.isSent = false;
            m.requestId = 0;
            m.outAsync = null;
            return m;
        };
        
        OutgoingMessage.create = function(out, stream, compress, requestId)
        {
            var m = new OutgoingMessage();
            m.stream = stream;
            m.compress = compress;
            m.outAsync = out;
            m.requestId = requestId;
            m.isSent = false;
            m.adopt = false;
            return m;
        };
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var IceSSL = Ice.__M.module("IceSSL");
        
        var HashUtil = Ice.HashUtil;
        var StringUtil = Ice.StringUtil;
        var EndpointI = Ice.EndpointI;
        var Class = Ice.Class;
        
        var WSEndpoint = Class(EndpointI, {
            __init__: function(instance, del, re)
            {
                this._instance = instance;
                this._delegate = del;
                this._resource = re || "/";
            },
            getInfo: function()
            {
                var info = this._delegate.secure() ? new IceSSL.WSSEndpointInfo() : new Ice.WSEndpointInfo();
                info.resource = this._resource;
                this._delegate.fillEndpointInfo(info);
                return info;
            },
            type: function()
            {
                return this._delegate.type();
            },
            protocol: function()
            {
                return this._delegate.protocol();
            },
            streamWrite: function(s)
            {
                s.startWriteEncaps();
                this._delegate.streamWriteImpl(s);
                s.writeString(this._resource);
                s.endWriteEncaps();
            },
            timeout: function()
            {
                return this._delegate.timeout();
            },
            changeTimeout: function(timeout)
            {
                if(timeout === this._delegate.timeout())
                {
                    return this;
                }
                else
                {
                    return new WSEndpoint(this._instance, this._delegate.changeTimeout(timeout), this._resource);
                }
            },
            changeConnectionId: function(connectionId)
            {
                if(connectionId === this._delegate.connectionId())
                {
                    return this;
                }
                else
                {
                    return new WSEndpoint(this._instance, this._delegate.changeConnectionId(connectionId), this._resource);
                }
            },
            compress: function()
            {
                return this._delegate.compress();
            },
            changeCompress: function(compress)
            {
                if(compress === this._delegate.compress())
                {
                    return this;
                }
                else
                {
                    return new WSEndpoint(this._instance, this._delegate.changeCompress(compress), this._resource);
                }
            },
            datagram: function()
            {
                return this._delegate.datagram();
            },
            secure: function()
            {
                return this._delegate.secure();
            },
            connect: function()
            {
                return Ice.WSTransceiver.createOutgoing(this._instance,
                                                        this._delegate.secure(),
                                                        this._delegate.getAddress(),
                                                        this._resource);
            },
            hashCode: function()
            {
                if(this._hashCode === undefined)
                {
                    this._hashCode = this._delegate.hashCode();
                    this._hashCode = HashUtil.addString(this._hashCode, this._resource);
                }
                return this._hashCode;
            },
            compareTo: function(p)
            {
                if(this === p)
                {
                    return 0;
                }
        
                if(p === null)
                {
                    return 1;
                }
        
                if(!(p instanceof WSEndpoint))
                {
                    return this.type() < p.type() ? -1 : 1;
                }
        
                var r = this._delegate.compareTo(p._delegate);
                if(r !== 0)
                {
                    return r;
                }
        
                if(this._resource !== p._resource)
                {
                    return this._resource < p._resource ? -1 : 1;
                }
        
                return 0;
            },
            options: function()
            {
                //
                // WARNING: Certain features, such as proxy validation in Glacier2,
                // depend on the format of proxy strings. Changes to toString() and
                // methods called to generate parts of the reference string could break
                // these features. Please review for all features that depend on the
                // format of proxyToString() before changing this and related code.
                //
                var s = this._delegate.options();
        
                if(this._resource !== null && this._resource.length > 0)
                {
                    s += " -r ";
                    s += (this._resource.indexOf(':') !== -1) ? ("\"" + this._resource + "\"") : this._resource;
                }
        
                return s;
            },
            toConnectorString: function()
            {
                return this._delegate.toConnectorString();
            },
            initWithStream: function(s)
            {
                this._resource = s.readString();
            },
            checkOption: function(option, argument, endpoint)
            {
                if(option === "-r")
                {
                    if(argument === null)
                    {
                        throw new Ice.EndpointParseException("no argument provided for -r option in endpoint " + endpoint);
                    }
                    this._resource = argument;
                }
                else
                {
                    return false;
                }
                return true;
            },
        });
        
        if(typeof(Ice.WSTransceiver) !== "undefined")
        {
            WSEndpoint.prototype.connectable = function()
            {
                return true;
            };
        }
        else
        {
            WSEndpoint.prototype.connectable = function()
            {
                return false;
            };
        }
        
        Ice.WSEndpoint = WSEndpoint;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var HashMap = Ice.HashMap;
        var RouterInfo = Ice.RouterInfo;
        var RouterPrx = Ice.RouterPrx;
        
        var RouterManager = Ice.Class({
            __init__: function()
            {
                this._table = new HashMap(HashMap.compareEquals); // Map<Ice.RouterPrx, RouterInfo>
            },
            destroy: function()
            {
                for(var e = this._table.entries; e !== null; e = e.next)
                {
                    e.value.destroy();
                }
                this._table.clear();
            },
            //
            // Returns router info for a given router. Automatically creates
            // the router info if it doesn't exist yet.
            //
            find: function(rtr)
            {
                if(rtr === null)
                {
                    return null;
                }
        
                //
                // The router cannot be routed.
                //
                var router = RouterPrx.uncheckedCast(rtr.ice_router(null));
        
                var info = this._table.get(router);
                if(info === undefined)
                {
                    info = new RouterInfo(router);
                    this._table.set(router, info);
                }
        
                return info;
            },
            erase: function(rtr)
            {
                var info = null;
                if(rtr !== null)
                {
                    // The router cannot be routed.
                    var router = RouterPrx.uncheckedCast(rtr.ice_router(null));
        
                    info = this._table.get(router);
                    this._table.del(router);
                }
                return info;
            }
        });
        Ice.RouterManager = RouterManager;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Class = Ice.Class;
        var Debug = Ice.Debug;
        
        var ACMConfig = Class({
            __init__: function(p, l, prefix, dflt)
            {
                if(p === undefined)
                {
                    this.timeout = 60 * 1000;
                    this.heartbeat = Ice.ACMHeartbeat.HeartbeatOnInvocation;
                    this.close = Ice.ACMClose.CloseOnInvocationAndIdle;
                    return;
                }
        
                var timeoutProperty;
                if((prefix == "Ice.ACM.Client" || prefix == "Ice.ACM.Server") &&
                    p.getProperty(prefix + ".Timeout").length === 0)
                {
                    timeoutProperty = prefix; // Deprecated property.
                }
                else
                {
                    timeoutProperty = prefix + ".Timeout";
                }
        
                this.timeout = p.getPropertyAsIntWithDefault(timeoutProperty, dflt.timeout / 1000) * 1000; // To ms
        
                var hb = p.getPropertyAsIntWithDefault(prefix + ".Heartbeat", dflt.heartbeat.value);
                if(hb >= 0 && hb <= Ice.ACMHeartbeat.maxValue)
                {
                    this.heartbeat = Ice.ACMHeartbeat.valueOf(hb);
                }
                else
                {
                    l.warning("invalid value for property `" + prefix + ".Heartbeat" +
                                "', default value will be used instead");
                    this.heartbeat = dflt.heartbeat;
                }
        
                var cl = p.getPropertyAsIntWithDefault(prefix + ".Close", dflt.close.value);
                if(cl >= 0 && cl <= Ice.ACMClose.maxValue)
                {
                    this.close = Ice.ACMClose.valueOf(cl);
                }
                else
                {
                    l.warning("invalid value for property `" + prefix + ".Close" +
                                "', default value will be used instead");
                    this.close = dflt.close;
                }
            }
        });
        
        var ACMMonitor = Class({
            add: function(con)
            {
                Debug.assert(false); // Absract
            },
            remove: function(con)
            {
                Debug.assert(false); // Absract
            },
            reap: function(con)
            {
                Debug.assert(false); // Absract
            },
            acm: function(timeout)
            {
                Debug.assert(false); // Absract
                return null;
            },
            getACM: function()
            {
                Debug.assert(false); // Absract
                return 0;
            }
        });
        
        var FactoryACMMonitor = Class(ACMMonitor, {
            __init__: function(instance, config)
            {
                this._instance = instance;
                this._config = config;
                this._reapedConnections = [];
                this._connections = [];
            },
            destroy: function()
            {
                if(this._instance === null)
                {
                    return;
                }
                this._instance = null;
                this._connections = null;
            },
            add: function(connection)
            {
                if(this._config.timeout === 0)
                {
                    return;
                }
        
                this._connections.push(connection);
                if(this._connections.length == 1)
                {
                    var self = this;
                    this._timerToken = this._instance.timer().scheduleRepeated(
                        function()
                            {
                                self.runTimerTask();
                            },
                        this._config.timeout / 2);
                }
            },
            remove: function(connection)
            {
                if(this._config.timeout === 0)
                {
                    return;
                }
        
                var i = this._connections.indexOf(connection);
                Debug.assert(i >= 0);
                this._connections.splice(i, 1);
                if(this._connections.length === 0)
                {
                    this._instance.timer().cancel(this._timerToken);
                    return;
                }
            },
            reap: function(connection)
            {
                this._reapedConnections.push(connection);
            },
            acm: function(timeout, close, heartbeat)
            {
                Debug.assert(this._instance !== null);
        
                var config = new ACMConfig();
                config.timeout = this._config.timeout;
                config.close = this._config.close;
                config.heartbeat = this._config.heartbeat;
                if(timeout !== undefined)
                {
                    config.timeout = timeout * 1000; // To milliseconds
                }
                if(close !== undefined)
                {
                    config.close = close;
                }
                if(heartbeat !== undefined)
                {
                    config.heartbeat = heartbeat;
                }
                return new ConnectionACMMonitor(this, this._instance.timer(), config);
            },
            getACM: function()
            {
                return new Ice.ACM(this._config.timeout / 1000, this._config.close, this._config.heartbeat);
            },
            swapReapedConnections: function()
            {
                if(this._reapedConnections.length === 0)
                {
                    return null;
                }
                var connections = this._reapedConnections;
                this._reapedConnections = [];
                return connections;
            },
            runTimerTask: function()
            {
                if(this._instance === null)
                {
                    return;
                }
        
                //
                // Monitor connections outside the thread synchronization, so
                // that connections can be added or removed during monitoring.
                //
                var now = Date.now();
                for(var i = 0; i < this._connections.length; i++)
                {
                    try
                    {
                        this._connections[i].monitor(now, this._config);
                    }
                    catch(ex)
                    {
                        this.handleException(ex);
                    }
                }
            },
            handleException: function(ex)
            {
                if(this._instance === null)
                {
                    return;
                }
                this._instance.initializationData().logger.error("exception in connection monitor:\n" + ex);
            }
        });
        
        var ConnectionACMMonitor = Class(ACMMonitor, {
            __init__: function(parent, timer, config)
            {
                this._parent = parent;
                this._timer = timer;
                this._config = config;
                this._connection = null;
            },
            add: function(connection)
            {
                Debug.assert(this._connection === null);
                this._connection = connection;
                if(this._config.timeout > 0)
                {
                    var self = this;
                    this._timerToken = this._timer.scheduleRepeated(function() { self.runTimerTask(); },
                                                                    this._config.timeout / 2);
                }
            },
            remove: function(connection)
            {
                Debug.assert(this._connection === connection);
                this._connection = null;
                if(this._config.timeout > 0)
                {
                    this._timer.cancel(this._timerToken);
                }
            },
            reap: function(connection)
            {
                this._parent.reap(connection);
            },
            acm: function(timeout, close, heartbeat)
            {
                return this._parent.acm(timeout, close, heartbeat);
            },
            getACM: function()
            {
                return new Ice.ACM(this._config.timeout / 1000, this._config.close, this._config.heartbeat);
            },
            runTimerTask: function()
            {
                try
                {
                    this._connection.monitor(Date.now(), this._config);
                }
                catch(ex)
                {
                    this._parent.handleException(ex);
                }
            }
        });
        
        Ice.FactoryACMMonitor = FactoryACMMonitor;
        Ice.ACMConfig = ACMConfig;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Context = Ice.Context;
        var InitializationException = Ice.InitializationException;
        
        //
        // The base class for all ImplicitContext implementations
        //
        var ImplicitContextI = Ice.Class({
            __init__: function()
            {
                this._context = new Context();
            },
            getContext: function()
            {
                return new Context(this._context);
            },
            setContext: function(context)
            {
                if(context !== null && context.size > 0)
                {
                    this._context = new Context(context);
                }
                else
                {
                    this._context.clear();
                }
            },
            containsKey: function(key)
            {
                if(key === null)
                {
                    key = "";
                }
        
                return this._context.has(key);
            },
            get: function(key)
            {
                if(key === null)
                {
                    key = "";
                }
        
                var val = this._context.get(key);
                if(val === null)
                {
                    val = "";
                }
        
                return val;
            },
            put: function(key, value)
            {
                if(key === null)
                {
                    key = "";
                }
                if(value === null)
                {
                    value = "";
                }
        
                var oldVal = this._context.get(key);
                if(oldVal === null)
                {
                    oldVal = "";
                }
        
                this._context.set(key, value);
        
                return oldVal;
            },
            remove: function(key)
            {
                if(key === null)
                {
                    key = "";
                }
        
                var val = this._context.get(key);
                this._context.del(key);
        
                if(val === null)
                {
                    val = "";
                }
                return val;
            },
            write: function(prxContext, os)
            {
                if(prxContext.size === 0)
                {
                    Ice.ContextHelper.write(os, this._context);
                }
                else
                {
                    var ctx = null;
                    if(this._context.size === 0)
                    {
                        ctx = prxContext;
                    }
                    else
                    {
                        ctx = new Context(this._context);
                        ctx.merge(prxContext);
                    }
                    Ice.ContextHelper.write(os, ctx);
                }
            }
        });
        
        ImplicitContextI.create = function(kind)
        {
            if(kind.length === 0 || kind === "None")
            {
                return null;
            }
            else if(kind === "Shared")
            {
                return new ImplicitContextI();
            }
            else
            {
                throw new InitializationException("'" + kind + "' is not a valid value for Ice.ImplicitContext");
            }
        };
        Ice.ImplicitContextI = ImplicitContextI;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var ArrayUtil = Ice.ArrayUtil;
        var Debug = Ice.Debug;
        var BatchRequestQueue = Ice.BatchRequestQueue;
        var HashMap = Ice.HashMap;
        var HashUtil = Ice.HashUtil;
        var OpaqueEndpointI = Ice.OpaqueEndpointI;
        var Promise = Ice.Promise;
        var Protocol = Ice.Protocol;
        var RefMode = Ice.ReferenceMode;
        var StringUtil = Ice.StringUtil;
        var StringSeqHelper = Ice.StringSeqHelper;
        var EndpointSelectionType = Ice.EndpointSelectionType;
        var Identity = Ice.Identity;
        var RouterPrx = Ice.RouterPrx;
        var LocatorPrx = Ice.LocatorPrx;
        var PropertyNames = Ice.PropertyNames;
        var ConnectionRequestHandler = Ice.ConnectionRequestHandler;
        
        var Class = Ice.Class;
        
        var suffixes =
        [
            "EndpointSelection",
            "ConnectionCached",
            "PreferSecure",
            "EncodingVersion",
            "LocatorCacheTimeout",
            "InvocationTimeout",
            "Locator",
            "Router",
            "CollocationOptimized"
        ];
        
        //
        // Only for use by Instance
        //
        var ReferenceFactory = Class({
            __init__: function(instance, communicator)
            {
                this._instance = instance;
                this._communicator = communicator;
                this._defaultRouter = null;
                this._defaultLocator = null;
            },
            create: function(ident, facet, tmpl, endpoints)
            {
                if(ident.name.length === 0 && ident.category.length === 0)
                {
                    return null;
                }
        
                return this.createImpl(ident, facet, tmpl.getMode(), tmpl.getSecure(), tmpl.getProtocol(), tmpl.getEncoding(),
                                    endpoints, null, null);
            },
            createWithAdapterId: function(ident, facet, tmpl, adapterId)
            {
                if(ident.name.length === 0 && ident.category.length === 0)
                {
                    return null;
                }
        
                return this.createImpl(ident, facet, tmpl.getMode(), tmpl.getSecure(), tmpl.getProtocol(), tmpl.getEncoding(),
                                    null, adapterId, null);
            },
            createFixed: function(ident, fixedConnection)
            {
                if(ident.name.length === 0 && ident.category.length === 0)
                {
                    return null;
                }
        
                //
                // Create new reference
                //
                var ref = new FixedReference(
                    this._instance,
                    this._communicator,
                    ident,
                    "", // Facet
                    fixedConnection.endpoint().datagram() ? RefMode.ModeDatagram : RefMode.ModeTwoway,
                    fixedConnection.endpoint().secure(),
                    this._instance.defaultsAndOverrides().defaultEncoding,
                    fixedConnection);
                return ref;
            },
            copy: function(r)
            {
                var ident = r.getIdentity();
                if(ident.name.length === 0 && ident.category.length === 0)
                {
                    return null;
                }
                return r.clone();
            },
            createFromString: function(s, propertyPrefix)
            {
                if(s === undefined || s === null || s.length === 0)
                {
                    return null;
                }
        
                var delim = " \t\n\r";
        
                var beg;
                var end = 0;
        
                beg = StringUtil.findFirstNotOf(s, delim, end);
                if(beg == -1)
                {
                    throw new Ice.ProxyParseException("no non-whitespace characters found in `" + s + "'");
                }
        
                //
                // Extract the identity, which may be enclosed in single
                // or double quotation marks.
                //
                var idstr = null;
                end = StringUtil.checkQuote(s, beg);
                if(end === -1)
                {
                    throw new Ice.ProxyParseException("mismatched quotes around identity in `" + s + "'");
                }
                else if(end === 0)
                {
                    end = StringUtil.findFirstOf(s, delim + ":@", beg);
                    if(end === -1)
                    {
                        end = s.length;
                    }
                    idstr = s.substring(beg, end);
                }
                else
                {
                    beg++; // Skip leading quote
                    idstr = s.substring(beg, end);
                    end++; // Skip trailing quote
                }
        
                if(beg === end)
                {
                    throw new Ice.ProxyParseException("no identity in `" + s + "'");
                }
        
                //
                // Parsing the identity may raise IdentityParseException.
                //
                var ident = this._instance.stringToIdentity(idstr);
        
                if(ident.name.length === 0)
                {
                    //
                    // An identity with an empty name and a non-empty
                    // category is illegal.
                    //
                    if(ident.category.length > 0)
                    {
                        throw new Ice.IllegalIdentityException(ident);
                    }
                    //
                    // Treat a stringified proxy containing two double
                    // quotes ("") the same as an empty string, i.e.,
                    // a null proxy, but only if nothing follows the
                    // quotes.
                    //
                    else if(StringUtil.findFirstNotOf(s, delim, end) != -1)
                    {
                        throw new Ice.ProxyParseException("invalid characters after identity in `" + s + "'");
                    }
                    else
                    {
                        return null;
                    }
                }
        
                var facet = "";
                var mode = RefMode.ModeTwoway;
                var secure = false;
                var encoding = this._instance.defaultsAndOverrides().defaultEncoding;
                var protocol = Ice.Protocol_1_0;
                var adapter = "";
        
                while(true)
                {
                    beg = StringUtil.findFirstNotOf(s, delim, end);
                    if(beg === -1)
                    {
                        break;
                    }
        
                    if(s.charAt(beg) == ':' || s.charAt(beg) == '@')
                    {
                        break;
                    }
        
                    end = StringUtil.findFirstOf(s, delim + ":@", beg);
                    if(end == -1)
                    {
                        end = s.length;
                    }
        
                    if(beg == end)
                    {
                        break;
                    }
        
                    var option = s.substring(beg, end);
                    if(option.length != 2 || option.charAt(0) != '-')
                    {
                        throw new Ice.ProxyParseException("expected a proxy option but found `" + option + "' in `" + s + "'");
                    }
        
                    //
                    // Check for the presence of an option argument. The
                    // argument may be enclosed in single or double
                    // quotation marks.
                    //
                    var argument = null;
                    var argumentBeg = StringUtil.findFirstNotOf(s, delim, end);
                    if(argumentBeg != -1)
                    {
                        var ch = s.charAt(argumentBeg);
                        if(ch != "@" && ch != ":" && ch != "-")
                        {
                            beg = argumentBeg;
                            end = StringUtil.checkQuote(s, beg);
                            if(end == -1)
                            {
                                throw new Ice.ProxyParseException("mismatched quotes around value for " + option +
                                                                " option in `" + s + "'");
                            }
                            else if(end === 0)
                            {
                                end = StringUtil.findFirstOf(s, delim + ":@", beg);
                                if(end === -1)
                                {
                                    end = s.length;
                                }
                                argument = s.substring(beg, end);
                            }
                            else
                            {
                                beg++; // Skip leading quote
                                argument = s.substring(beg, end);
                                end++; // Skip trailing quote
                            }
                        }
                    }
        
                    //
                    // If any new options are added here,
                    // IceInternal::Reference::toString() and its derived classes must be updated as well.
                    //
                    switch(option.charAt(1))
                    {
                        case 'f':
                        {
                            if(argument === null)
                            {
                                throw new Ice.ProxyParseException("no argument provided for -f option in `" + s + "'");
                            }
        
                            try
                            {
                                facet = StringUtil.unescapeString(argument, 0, argument.length);
                            }
                            catch(ex)
                            {
                                throw new Ice.ProxyParseException("invalid facet in `" + s + "': " + ex.message);
                            }
        
                            break;
                        }
        
                        case 't':
                        {
                            if(argument !== null)
                            {
                                throw new Ice.ProxyParseException("unexpected argument `" + argument +
                                                                    "' provided for -t option in `" + s + "'");
                            }
                            mode = RefMode.ModeTwoway;
                            break;
                        }
        
                        case 'o':
                        {
                            if(argument !== null)
                            {
                                throw new Ice.ProxyParseException("unexpected argument `" + argument +
                                                                    "' provided for -o option in `" + s + "'");
                            }
                            mode = RefMode.ModeOneway;
                            break;
                        }
        
                        case 'O':
                        {
                            if(argument !== null)
                            {
                                throw new Ice.ProxyParseException("unexpected argument `" + argument +
                                                                    "' provided for -O option in `" + s + "'");
                            }
                            mode = RefMode.ModeBatchOneway;
                            break;
                        }
        
                        case 'd':
                        {
                            if(argument !== null)
                            {
                                throw new Ice.ProxyParseException("unexpected argument `" + argument +
                                                                    "' provided for -d option in `" + s + "'");
                            }
                            mode = RefMode.ModeDatagram;
                            break;
                        }
        
                        case 'D':
                        {
                            if(argument !== null)
                            {
                                throw new Ice.ProxyParseException("unexpected argument `" + argument +
                                                                    "' provided for -D option in `" + s + "'");
                            }
                            mode = RefMode.ModeBatchDatagram;
                            break;
                        }
        
                        case 's':
                        {
                            if(argument !== null)
                            {
                                throw new Ice.ProxyParseException("unexpected argument `" + argument +
                                                                    "' provided for -s option in `" + s + "'");
                            }
                            secure = true;
                            break;
                        }
        
                        case 'e':
                        {
                            if(argument === null)
                            {
                                throw new Ice.ProxyParseException("no argument provided for -e option in `" + s + "'");
                            }
        
                            try
                            {
                                encoding = Ice.stringToEncodingVersion(argument);
                            }
                            catch(e) // VersionParseException
                            {
                                throw new Ice.ProxyParseException("invalid encoding version `" + argument + "' in `" + s +
                                                                    "':\n" + e.str);
                            }
                            break;
                        }
        
                        case 'p':
                        {
                            if(argument === null)
                            {
                                throw new Ice.ProxyParseException("no argument provided for -p option in `" + s + "'");
                            }
        
                            try
                            {
                                protocol = Ice.stringToProtocolVersion(argument);
                            }
                            catch(e) // VersionParseException
                            {
                                throw new Ice.ProxyParseException("invalid protocol version `" + argument + "' in `" + s +
                                                                    "':\n" + e.str);
                            }
                            break;
                        }
        
                        default:
                        {
                            throw new Ice.ProxyParseException("unknown option `" + option + "' in `" + s + "'");
                        }
                    }
                }
        
                if(beg === -1)
                {
                    return this.createImpl(ident, facet, mode, secure, protocol, encoding, null, null, propertyPrefix);
                }
        
                var endpoints = [];
        
                if(s.charAt(beg) == ':')
                {
                    var unknownEndpoints = [];
                    end = beg;
        
                    while(end < s.length && s.charAt(end) == ':')
                    {
                        beg = end + 1;
        
                        end = beg;
                        while(true)
                        {
                            end = s.indexOf(':', end);
                            if(end == -1)
                            {
                                end = s.length;
                                break;
                            }
                            else
                            {
                                var quoted = false;
                                var quote = beg;
                                while(true)
                                {
                                    quote = s.indexOf("\"", quote);
                                    if(quote == -1 || end < quote)
                                    {
                                        break;
                                    }
                                    else
                                    {
                                        quote = s.indexOf('\"', ++quote);
                                        if(quote == -1)
                                        {
                                            break;
                                        }
                                        else if(end < quote)
                                        {
                                            quoted = true;
                                            break;
                                        }
                                        ++quote;
                                    }
                                }
                                if(!quoted)
                                {
                                    break;
                                }
                                ++end;
                            }
                        }
        
                        var es = s.substring(beg, end);
                        var endp = this._instance.endpointFactoryManager().create(es, false);
                        if(endp !== null)
                        {
                            endpoints.push(endp);
                        }
                        else
                        {
                            unknownEndpoints.push(es);
                        }
                    }
                    if(endpoints.length === 0)
                    {
                        Debug.assert(unknownEndpoints.length > 0);
                        throw new Ice.EndpointParseException("invalid endpoint `" + unknownEndpoints[0] + "' in `" + s + "'");
                    }
                    else if(unknownEndpoints.length !== 0 &&
                        this._instance.initializationData().properties.getPropertyAsIntWithDefault("Ice.Warn.Endpoints", 1) > 0)
                    {
                        var msg = [];
                        msg.push("Proxy contains unknown endpoints:");
                        for(var i = 0; i < unknownEndpoints.length; ++i)
                        {
                            msg.push(" `");
                            msg.push(unknownEndpoints[i]);
                            msg.push("'");
                        }
                        this._instance.initializationData().logger.warning(msg.join(""));
                    }
        
                    return this.createImpl(ident, facet, mode, secure, protocol, encoding, endpoints, null, propertyPrefix);
                }
                else if(s.charAt(beg) == '@')
                {
                    beg = StringUtil.findFirstNotOf(s, delim, beg + 1);
                    if(beg == -1)
                    {
                        throw new Ice.ProxyParseException("missing adapter id in `" + s + "'");
                    }
        
                    var adapterstr = null;
                    end = StringUtil.checkQuote(s, beg);
                    if(end === -1)
                    {
                        throw new Ice.ProxyParseException("mismatched quotes around adapter id in `" + s + "'");
                    }
                    else if(end === 0)
                    {
                        end = StringUtil.findFirstOf(s, delim, beg);
                        if(end === -1)
                        {
                            end = s.length;
                        }
                        adapterstr = s.substring(beg, end);
                    }
                    else
                    {
                        beg++; // Skip leading quote
                        adapterstr = s.substring(beg, end);
                        end++; // Skip trailing quote
                    }
        
                    if(end !== s.length && StringUtil.findFirstNotOf(s, delim, end) !== -1)
                    {
                        throw new Ice.ProxyParseException("invalid trailing characters after `" + s.substring(0, end + 1) +
                                                            "' in `" + s + "'");
                    }
        
                    try
                    {
                        adapter = StringUtil.unescapeString(adapterstr, 0, adapterstr.length);
                    }
                    catch(ex)
                    {
                        throw new Ice.ProxyParseException("invalid adapter id in `" + s + "': " + ex.message);
                    }
                    if(adapter.length === 0)
                    {
                        throw new Ice.ProxyParseException("empty adapter id in `" + s + "'");
                    }
                    return this.createImpl(ident, facet, mode, secure, protocol, encoding, null, adapter, propertyPrefix);
                }
        
                throw new Ice.ProxyParseException("malformed proxy `" + s + "'");
            },
            createFromStream: function(ident, s)
            {
                //
                // Don't read the identity here. Operations calling this
                // constructor read the identity, and pass it as a parameter.
                //
        
                if(ident.name.length === 0 && ident.category.length === 0)
                {
                    return null;
                }
        
                //
                // For compatibility with the old FacetPath.
                //
                var facetPath = StringSeqHelper.read(s); // String[]
                var facet;
                if(facetPath.length > 0)
                {
                    if(facetPath.length > 1)
                    {
                        throw new Ice.ProxyUnmarshalException();
                    }
                    facet = facetPath[0];
                }
                else
                {
                    facet = "";
                }
        
                var mode = s.readByte();
                if(mode < 0 || mode > RefMode.ModeLast)
                {
                    throw new Ice.ProxyUnmarshalException();
                }
        
                var secure = s.readBool();
        
                var protocol = null;
                var encoding = null;
                if(!s.getReadEncoding().equals(Ice.Encoding_1_0))
                {
                    protocol = new Ice.ProtocolVersion();
                    protocol.__read(s);
                    encoding = new Ice.EncodingVersion();
                    encoding.__read(s);
                }
                else
                {
                    protocol = Ice.Protocol_1_0;
                    encoding = Ice.Encoding_1_0;
                }
        
                var endpoints = null; // EndpointI[]
                var adapterId = null;
        
                var sz = s.readSize();
                if(sz > 0)
                {
                    endpoints = [];
                    for(var i = 0; i < sz; i++)
                    {
                        endpoints[i] = this._instance.endpointFactoryManager().read(s);
                    }
                }
                else
                {
                    adapterId = s.readString();
                }
        
                return this.createImpl(ident, facet, mode, secure, protocol, encoding, endpoints, adapterId, null);
            },
            setDefaultRouter: function(defaultRouter)
            {
                if(this._defaultRouter === null ? defaultRouter === null : this._defaultRouter.equals(defaultRouter))
                {
                    return this;
                }
        
                var factory = new ReferenceFactory(this._instance, this._communicator);
                factory._defaultLocator = this._defaultLocator;
                factory._defaultRouter = defaultRouter;
                return factory;
            },
            getDefaultRouter: function()
            {
                return this._defaultRouter;
            },
            setDefaultLocator: function(defaultLocator)
            {
                if(this._defaultLocator === null ? defaultLocator === null : this._defaultLocator.equals(defaultLocator))
                {
                    return this;
                }
        
                var factory = new ReferenceFactory(this._instance, this._communicator);
                factory._defaultRouter = this._defaultRouter;
                factory._defaultLocator = defaultLocator;
                return factory;
            },
            getDefaultLocator: function()
            {
                return this._defaultLocator;
            },
            checkForUnknownProperties: function(prefix)
            {
                var unknownProps = [], i, length;
                //
                // Do not warn about unknown properties for Ice prefixes (Ice, Glacier2, etc.)
                //
                for(i = 0; i < PropertyNames.clPropNames.length; ++i)
                {
                    if(prefix.indexOf(PropertyNames.clPropNames[i] + ".") === 0)
                    {
                        return;
                    }
                }
        
                var props = this._instance.initializationData().properties.getPropertiesForPrefix(prefix + ".");
                for(var e = props.entries; e !== null; e = e.next)
                {
                    var valid = false;
                    for(i = 0, length = suffixes.length; i < length; ++i)
                    {
                        if(e.key === prefix + "." + suffixes[i])
                        {
                            valid = true;
                            break;
                        }
                    }
        
                    if(!valid)
                    {
                        unknownProps.push(e.key);
                    }
                }
        
                if(unknownProps.length > 0)
                {
                    var message = [];
                    message.push("found unknown properties for proxy '");
                    message.push(prefix);
                    message.push("':");
                    for(i = 0, length = unknownProps.length; i < length; ++i)
                    {
                        message.push("\n    ");
                        message.push(unknownProps[i]);
                    }
                    this._instance.initializationData().logger.warning(message.join(""));
                }
            },
            createImpl: function(ident, facet, mode, secure, protocol, encoding, endpoints, adapterId, propertyPrefix)
            {
                var defaultsAndOverrides = this._instance.defaultsAndOverrides();
        
                //
                // Default local proxy options.
                //
                var locatorInfo = null;
                if(this._defaultLocator !== null)
                {
                    if(!this._defaultLocator.__reference().getEncoding().equals(encoding))
                    {
                        locatorInfo = this._instance.locatorManager().find(
                            this._defaultLocator.ice_encodingVersion(encoding));
                    }
                    else
                    {
                        locatorInfo = this._instance.locatorManager().find(this._defaultLocator);
                    }
                }
                var routerInfo = this._instance.routerManager().find(this._defaultRouter);
                var cacheConnection = true;
                var preferSecure = defaultsAndOverrides.defaultPreferSecure;
                var endpointSelection = defaultsAndOverrides.defaultEndpointSelection;
                var locatorCacheTimeout = defaultsAndOverrides.defaultLocatorCacheTimeout;
                var invocationTimeout = defaultsAndOverrides.defaultInvocationTimeout;
        
                //
                // Override the defaults with the proxy properties if a property prefix is defined.
                //
                if(propertyPrefix !== null && propertyPrefix.length > 0)
                {
                    var properties = this._instance.initializationData().properties;
        
                    //
                    // Warn about unknown properties.
                    //
                    if(properties.getPropertyAsIntWithDefault("Ice.Warn.UnknownProperties", 1) > 0)
                    {
                        this.checkForUnknownProperties(propertyPrefix);
                    }
        
                    var property;
        
                    property = propertyPrefix + ".Locator";
                    var locator = LocatorPrx.uncheckedCast(this._communicator.propertyToProxy(property));
                    if(locator !== null)
                    {
                        if(!locator.__reference().getEncoding().equals(encoding))
                        {
                            locatorInfo = this._instance.locatorManager().find(locator.ice_encodingVersion(encoding));
                        }
                        else
                        {
                            locatorInfo = this._instance.locatorManager().find(locator);
                        }
                    }
        
                    property = propertyPrefix + ".Router";
                    var router = RouterPrx.uncheckedCast(this._communicator.propertyToProxy(property));
                    if(router !== null)
                    {
                        var match = ".Router";
                        if(propertyPrefix.lastIndexOf(match) == propertyPrefix.length - match.length)
                        {
                            var s = "`" + property + "=" + properties.getProperty(property) +
                                "': cannot set a router on a router; setting ignored";
                            this._instance.initializationData().logger.warning(s);
                        }
                        else
                        {
                            routerInfo = this._instance.routerManager().find(router);
                        }
                    }
        
                    property = propertyPrefix + ".ConnectionCached";
                    cacheConnection = properties.getPropertyAsIntWithDefault(property, cacheConnection ? 1 : 0) > 0;
        
                    property = propertyPrefix + ".PreferSecure";
                    preferSecure = properties.getPropertyAsIntWithDefault(property, preferSecure ? 1 : 0) > 0;
        
                    property = propertyPrefix + ".EndpointSelection";
                    if(properties.getProperty(property).length > 0)
                    {
                        var type = properties.getProperty(property);
                        if(type == "Random")
                        {
                            endpointSelection = EndpointSelectionType.Random;
                        }
                        else if(type == "Ordered")
                        {
                            endpointSelection = EndpointSelectionType.Ordered;
                        }
                        else
                        {
                            throw new Ice.EndpointSelectionTypeParseException("illegal value `" + type +
                                                                                "'; expected `Random' or `Ordered'");
                        }
                    }
        
                    property = propertyPrefix + ".LocatorCacheTimeout";
                    var value = properties.getProperty(property);
                    if(value.length !== 0)
                    {
                        locatorCacheTimeout = properties.getPropertyAsIntWithDefault(property, locatorCacheTimeout);
                        if(locatorCacheTimeout < -1)
                        {
                            locatorCacheTimeout = -1;
                            this._instance.initializationData().logger.warning(
                                "invalid value for" + property + "`" + properties.getProperty(property) +
                                "': defaulting to -1");
                        }
                    }
        
                    property = propertyPrefix + ".InvocationTimeout";
                    value = properties.getProperty(property);
                    if(value.length !== 0)
                    {
                        invocationTimeout = properties.getPropertyAsIntWithDefault(property, invocationTimeout);
                        if(invocationTimeout < 1 && invocationTimeout !== -1)
                        {
                            invocationTimeout = -1;
                            this._instance.initializationData().logger.warning(
                                "invalid value for" + property + "`" + properties.getProperty(property) +
                                "': defaulting to -1");
                        }
                    }
                }
        
                //
                // Create new reference
                //
                return new RoutableReference(this._instance,
                                             this._communicator,
                                             ident,
                                             facet,
                                             mode,
                                             secure,
                                             protocol,
                                             encoding,
                                             endpoints,
                                             adapterId,
                                             locatorInfo,
                                             routerInfo,
                                             cacheConnection,
                                             preferSecure,
                                             endpointSelection,
                                             locatorCacheTimeout,
                                             invocationTimeout);
            }
        });
        
        Ice.ReferenceFactory = ReferenceFactory;
        
        var Reference = Class({
            __init__: function(instance, communicator, identity, facet, mode, secure, protocol, encoding, invocationTimeout)
            {
                //
                // Validate string arguments.
                //
                Debug.assert(identity === undefined || identity.name !== null);
                Debug.assert(identity === undefined || identity.category !== null);
                Debug.assert(facet === undefined || facet !== null);
        
                this._instance = instance;
                this._communicator = communicator;
                this._mode = mode;
                this._secure = secure;
                this._identity = identity;
                this._context = Reference._emptyContext;
                this._facet = facet;
                this._protocol = protocol;
                this._encoding = encoding;
                this._invocationTimeout = invocationTimeout;
                this._hashInitialized = false;
                this._overrideCompress = false;
                this._compress = false; // Only used if _overrideCompress == true
            },
            getMode: function()
            {
                return this._mode;
            },
            getSecure: function()
            {
                return this._secure;
            },
            getProtocol: function()
            {
                return this._protocol;
            },
            getEncoding: function()
            {
                return this._encoding;
            },
            getIdentity: function()
            {
                return this._identity;
            },
            getFacet: function()
            {
                return this._facet;
            },
            getInstance: function()
            {
                return this._instance;
            },
            getContext: function()
            {
                return this._context; // HashMap
            },
            getInvocationTimeout: function()
            {
                return this._invocationTimeout;
            },
            getCommunicator: function()
            {
                return this._communicator;
            },
            getEndpoints: function()
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            getAdapterId: function()
            {
                // Abstract
                Debug.assert(false);
                return "";
            },
            getRouterInfo: function()
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            getLocatorInfo: function()
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            getCacheConnection: function()
            {
                // Abstract
                Debug.assert(false);
                return false;
            },
            getPreferSecure: function()
            {
                // Abstract
                Debug.assert(false);
                return false;
            },
            getEndpointSelection: function()
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            getLocatorCacheTimeout: function()
            {
                // Abstract
                Debug.assert(false);
                return 0;
            },
            getConnectionId: function()
            {
                // Abstract
                Debug.assert(false);
                return "";
            },
            //
            // The change* methods (here and in derived classes) create
            // a new reference based on the existing one, with the
            // corresponding value changed.
            //
            changeContext: function(newContext)
            {
                if(newContext === undefined || newContext === null)
                {
                    newContext = Reference._emptyContext;
                }
                var r = this._instance.referenceFactory().copy(this);
                if(newContext.size === 0)
                {
                    r._context = Reference._emptyContext;
                }
                else
                {
                    r._context = new HashMap(newContext);
                }
                return r;
            },
            changeMode: function(newMode)
            {
                if(newMode === this._mode)
                {
                    return this;
                }
                var r = this._instance.referenceFactory().copy(this);
                r._mode = newMode;
                return r;
            },
            changeSecure: function(newSecure)
            {
                if(newSecure === this._secure)
                {
                    return this;
                }
                var r = this._instance.referenceFactory().copy(this);
                r._secure = newSecure;
                return r;
            },
            changeIdentity: function(newIdentity)
            {
                if(newIdentity.equals(this._identity))
                {
                    return this;
                }
                var r = this._instance.referenceFactory().copy(this);
                r._identity = new Identity(newIdentity.name, newIdentity.category);
                return r;
            },
            changeFacet: function(newFacet)
            {
                if(newFacet === this._facet)
                {
                    return this;
                }
                var r = this._instance.referenceFactory().copy(this);
                r._facet = newFacet;
                return r;
            },
            changeInvocationTimeout: function(newInvocationTimeout)
            {
                if(newInvocationTimeout === this._invocationTimeout)
                {
                    return this;
                }
                var r = this._instance.referenceFactory().copy(this);
                r._invocationTimeout = newInvocationTimeout;
                return r;
            },
            changeEncoding: function(newEncoding)
            {
                if(newEncoding.equals(this._encoding))
                {
                    return this;
                }
                var r = this._instance.referenceFactory().copy(this);
                r._encoding = newEncoding;
                return r;
            },
            changeCompress: function(newCompress)
            {
                if(this._overrideCompress && this._compress === newCompress)
                {
                    return this;
                }
                var r = this._instance.referenceFactory().copy(this);
                r._compress = newCompress;
                r._overrideCompress = true;
                return r;
            },
            changeAdapterId: function(newAdapterId)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changeEndpoints: function(newEndpoints)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changeLocator: function(newLocator)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changeRouter: function(newRouter)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changeCacheConnection: function(newCache)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changePreferSecure: function(newPreferSecure)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changeEndpointSelection: function(newType)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changeLocatorCacheTimeout: function(newTimeout)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changeTimeout: function(newTimeout)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            changeConnectionId: function(connectionId)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            hashCode: function()
            {
                if(this._hashInitialized)
                {
                    return this._hashValue;
                }
        
                var h = 5381;
                h = HashUtil.addNumber(h, this._mode);
                h = HashUtil.addBoolean(h, this._secure);
                h = HashUtil.addHashable(h, this._identity);
                if(this._context !== null && this._context !== undefined)
                {
                    for(var e = this._context.entries; e !== null; e = e.next)
                    {
                        h = HashUtil.addString(h, e.key);
                        h = HashUtil.addString(h, e.value);
                    }
                }
                h = HashUtil.addString(h, this._facet);
                h = HashUtil.addBoolean(h, this._overrideCompress);
                if(this._overrideCompress)
                {
                    h = HashUtil.addBoolean(h, this._compress);
                }
                h = HashUtil.addHashable(h, this._protocol);
                h = HashUtil.addHashable(h, this._encoding);
                h = HashUtil.addNumber(h, this._invocationTimeout);
        
                this._hashValue = h;
                this._hashInitialized = true;
        
                return this._hashValue;
            },
            //
            // Utility methods
            //
            isIndirect: function()
            {
                // Abstract
                Debug.assert(false);
                return false;
            },
            isWellKnown: function()
            {
                // Abstract
                Debug.assert(false);
                return false;
            },
            //
            // Marshal the reference.
            //
            streamWrite: function(s)
            {
                //
                // Don't write the identity here. Operations calling streamWrite
                // write the identity.
                //
        
                //
                // For compatibility with the old FacetPath.
                //
                if(this._facet.length === 0)
                {
                    s.writeSize(0); // Empty string sequence
                }
                else
                {
                    s.writeSize(1); // String sequence with one element
                    s.writeString(this._facet);
                }
        
                s.writeByte(this._mode);
        
                s.writeBool(this._secure);
        
                if(!s.getWriteEncoding().equals(Ice.Encoding_1_0))
                {
                    this._protocol.__write(s);
                    this._encoding.__write(s);
                }
        
                // Derived class writes the remainder of the reference.
            },
            //
            // Convert the reference to its string form.
            //
            toString: function()
            {
                //
                // WARNING: Certain features, such as proxy validation in Glacier2,
                // depend on the format of proxy strings. Changes to toString() and
                // methods called to generate parts of the reference string could break
                // these features. Please review for all features that depend on the
                // format of proxyToString() before changing this and related code.
                //
                var s = [];
        
                //
                // If the encoded identity string contains characters which
                // the reference parser uses as separators, then we enclose
                // the identity string in quotes.
                //
                var id = this._instance.identityToString(this._identity);
                if(id.search(/[ :@]/) != -1)
                {
                    s.push('"');
                    s.push(id);
                    s.push('"');
                }
                else
                {
                    s.push(id);
                }
        
                if(this._facet.length > 0)
                {
                    //
                    // If the encoded facet string contains characters which
                    // the reference parser uses as separators, then we enclose
                    // the facet string in quotes.
                    //
                    s.push(" -f ");
                    var fs = StringUtil.escapeString(this._facet, "");
                    if(fs.search(/[ :@]/) != -1)
                    {
                        s.push('"');
                        s.push(fs);
                        s.push('"');
                    }
                    else
                    {
                        s.push(fs);
                    }
                }
        
                switch(this._mode)
                {
                    case RefMode.ModeTwoway:
                    {
                        s.push(" -t");
                        break;
                    }
        
                    case RefMode.ModeOneway:
                    {
                        s.push(" -o");
                        break;
                    }
        
                    case RefMode.ModeBatchOneway:
                    {
                        s.push(" -O");
                        break;
                    }
        
                    case RefMode.ModeDatagram:
                    {
                        s.push(" -d");
                        break;
                    }
        
                    case RefMode.ModeBatchDatagram:
                    {
                        s.push(" -D");
                        break;
                    }
                }
        
                if(this._secure)
                {
                    s.push(" -s");
                }
        
                if(!this._protocol.equals(Ice.Protocol_1_0))
                {
                    //
                    // We only print the protocol if it's not 1.0. It's fine as
                    // long as we don't add Ice.Default.ProtocolVersion, a
                    // stringified proxy will convert back to the same proxy with
                    // stringToProxy.
                    //
                    s.push(" -p ");
                    s.push(Ice.protocolVersionToString(this._protocol));
                }
        
                //
                // Always print the encoding version to ensure a stringified proxy
                // will convert back to a proxy with the same encoding with
                // stringToProxy (and won't use Ice.Default.EncodingVersion).
                //
                s.push(" -e ");
                s.push(Ice.encodingVersionToString(this._encoding));
        
                return s.join("");
        
                // Derived class writes the remainder of the string.
            },
            //
            // Convert the reference to its property form.
            //
            toProperty: function(prefix)
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            getRequestHandler: function(proxy)
            {
                // Abstract
                Debug.assert(false);
            },
            getBatchRequestQueue: function()
            {
                // Abstract
                Debug.assert(false);
            },
            equals: function(r)
            {
                //
                // Note: if(this === r) and type test are performed by each non-abstract derived class.
                //
        
                if(this._mode !== r._mode)
                {
                    return false;
                }
        
                if(this._secure !== r._secure)
                {
                    return false;
                }
        
                if(!this._identity.equals(r._identity))
                {
                    return false;
                }
        
                if(!this._context.equals(r._context))
                {
                    return false;
                }
        
                if(this._facet !== r._facet)
                {
                    return false;
                }
        
                if(this._overrideCompress !== r._overrideCompress)
                {
                return false;
                }
                if(this._overrideCompress && this._compress !== r._compress)
                {
                    return false;
                }
        
                if(!this._protocol.equals(r._protocol))
                {
                    return false;
                }
        
                if(!this._encoding.equals(r._encoding))
                {
                    return false;
                }
        
                if(this._invocationTimeout !== r._invocationTimeout)
                {
                    return false;
                }
        
                return true;
            },
            clone: function()
            {
                // Abstract
                Debug.assert(false);
                return null;
            },
            copyMembers: function(r)
            {
                //
                // Copy the members that are not passed to the constructor.
                //
                r._context = this._context;
                r._overrideCompress = this._overrideCompress;
                r._compress = this._compress;
            }
        });
        
        Reference._emptyContext = new HashMap();
        Reference._emptyEndpoints = [];
        
        Ice.Reference = Reference;
        
        var FixedReference = Class(Reference, {
            __init__: function(instance, communicator, identity, facet, mode, secure, encoding, connection)
            {
                Reference.call(this, instance, communicator, identity, facet, mode, secure, Ice.Protocol_1_0, encoding);
                this._fixedConnection = connection;
            },
            getEndpoints: function()
            {
                return Reference._emptyEndpoints;
            },
            getAdapterId: function()
            {
                return "";
            },
            getRouterInfo: function()
            {
                return null;
            },
            getLocatorInfo: function()
            {
                return null;
            },
            getCacheConnection: function()
            {
                return true;
            },
            getPreferSecure: function()
            {
                return false;
            },
            getEndpointSelection: function()
            {
                return EndpointSelectionType.Random;
            },
            getLocatorCacheTimeout: function()
            {
                return 0;
            },
            getConnectionId: function()
            {
                return "";
            },
            changeAdapterId: function(newAdapterId)
            {
                throw new Ice.FixedProxyException();
            },
            changeEndpoints: function(newEndpoints)
            {
                throw new Ice.FixedProxyException();
            },
            changeLocator: function(newLocator)
            {
                throw new Ice.FixedProxyException();
            },
            changeRouter: function(newRouter)
            {
                throw new Ice.FixedProxyException();
            },
            changeCacheConnection: function(newCache)
            {
                throw new Ice.FixedProxyException();
            },
            changePreferSecure: function(prefSec)
            {
                throw new Ice.FixedProxyException();
            },
            changeEndpointSelection: function(newType)
            {
                throw new Ice.FixedProxyException();
            },
            changeLocatorCacheTimeout: function(newTimeout)
            {
                throw new Ice.FixedProxyException();
            },
            changeTimeout: function(newTimeout)
            {
                throw new Ice.FixedProxyException();
            },
            changeConnectionId: function(connectionId)
            {
                throw new Ice.FixedProxyException();
            },
            isIndirect: function()
            {
                return false;
            },
            isWellKnown: function()
            {
                return false;
            },
            streamWrite: function(s)
            {
                throw new Ice.FixedProxyException();
            },
            toString: function()
            {
                throw new Ice.FixedProxyException();
            },
            toProperty: function(prefix)
            {
                throw new Ice.FixedProxyException();
            },
            clone: function()
            {
                var r = new FixedReference(this.getInstance(), this.getCommunicator(), this.getIdentity(), this.getFacet(),
                                            this.getMode(), this.getSecure(), this.getEncoding(), this._fixedConnection);
                this.copyMembers(r);
                return r;
            },
            getRequestHandler: function(proxy)
            {
                switch(this.getMode())
                {
                    case RefMode.ModeTwoway:
                    case RefMode.ModeOneway:
                    case RefMode.ModeBatchOneway:
                    {
                        if(this._fixedConnection.endpoint().datagram())
                        {
                            throw new Ice.NoEndpointException("");
                        }
                        break;
                    }
        
                    case RefMode.ModeDatagram:
                    case RefMode.ModeBatchDatagram:
                    {
                        if(!this._fixedConnection.endpoint().datagram())
                        {
                            throw new Ice.NoEndpointException("");
                        }
                        break;
                    }
                }
        
                //
                // If a secure connection is requested or secure overrides is set,
                // check if the connection is secure.
                //
                var secure;
                var defaultsAndOverrides = this.getInstance().defaultsAndOverrides();
                if(defaultsAndOverrides.overrideSecure)
                {
                    secure = defaultsAndOverrides.overrideSecureValue;
                }
                else
                {
                    secure = this.getSecure();
                }
                if(secure && !this._fixedConnection.endpoint().secure())
                {
                    throw new Ice.NoEndpointException("");
                }
        
                this._fixedConnection.throwException(); // Throw in case our connection is already destroyed.
        
                var compress;
                if(defaultsAndOverrides.overrideCompress)
                {
                    compress = defaultsAndOverrides.overrideCompressValue;
                }
                else if(this._overrideCompress)
                {
                    compress = this._compress;
                }
                else
                {
                    compress = this._fixedConnection.endpoint().compress();
                }
        
                return proxy.__setRequestHandler(new ConnectionRequestHandler(this, this._fixedConnection, compress));
            },
            getBatchRequestQueue: function()
            {
                return this._fixedConnection.getBatchRequestQueue();
            },
            equals: function(rhs)
            {
                if(this === rhs)
                {
                    return true;
                }
                if(!(rhs instanceof FixedReference))
                {
                    return false;
                }
                if(!Reference.prototype.equals.call(this, rhs))
                {
                    return false;
                }
                return this._fixedConnection.equals(rhs._fixedConnection);
            }
        });
        
        Ice.FixedReference = FixedReference;
        
        var RoutableReference = Class(Reference, {
            __init__: function(instance, communicator, identity, facet, mode, secure, protocol, encoding, endpoints,
                                adapterId, locatorInfo, routerInfo, cacheConnection, preferSecure, endpointSelection,
                                locatorCacheTimeout, invocationTimeout)
            {
                Reference.call(this, instance, communicator, identity, facet, mode, secure, protocol, encoding,
                                invocationTimeout);
                this._endpoints = endpoints;
                this._adapterId = adapterId;
                this._locatorInfo = locatorInfo;
                this._routerInfo = routerInfo;
                this._cacheConnection = cacheConnection;
                this._preferSecure = preferSecure;
                this._endpointSelection = endpointSelection;
                this._locatorCacheTimeout = locatorCacheTimeout;
                this._overrideTimeout = false;
                this._timeout = -1;
        
                if(this._endpoints === null)
                {
                    this._endpoints = Reference._emptyEndpoints;
                }
                if(this._adapterId === null)
                {
                    this._adapterId = "";
                }
                this._connectionId = "";
                Debug.assert(this._adapterId.length === 0 || this._endpoints.length === 0);
            },
            getEndpoints: function()
            {
                return this._endpoints;
            },
            getAdapterId: function()
            {
                return this._adapterId;
            },
            getRouterInfo: function()
            {
                return this._routerInfo;
            },
            getLocatorInfo: function()
            {
                return this._locatorInfo;
            },
            getCacheConnection: function()
            {
                return this._cacheConnection;
            },
            getPreferSecure: function()
            {
                return this._preferSecure;
            },
            getEndpointSelection: function()
            {
                return this._endpointSelection;
            },
            getLocatorCacheTimeout: function()
            {
                return this._locatorCacheTimeout;
            },
            getConnectionId: function()
            {
                return this._connectionId;
            },
            changeEncoding: function(newEncoding)
            {
                var r = Reference.prototype.changeEncoding.call(this, newEncoding);
                if(r !== this)
                {
                    var locInfo = r._locatorInfo;
                    if(locInfo !== null && !locInfo.getLocator().ice_getEncodingVersion().equals(newEncoding))
                    {
                        r._locatorInfo = this.getInstance().locatorManager().find(
                            locInfo.getLocator().ice_encodingVersion(newEncoding));
                    }
                }
                return r;
            },
            changeCompress: function(newCompress)
            {
                var r = Reference.prototype.changeCompress.call(this, newCompress);
                if(r !== this && this._endpoints.length > 0) // Also override the compress flag on the endpoints if it was updated.
                {
                    var newEndpoints = [];
                    for(var i = 0; i < this._endpoints.length; i++)
                    {
                        newEndpoints[i] = this._endpoints[i].changeCompress(newCompress);
                    }
                    r._endpoints = newEndpoints;
                }
                return r;
            },
            changeAdapterId: function(newAdapterId)
            {
                if(this._adapterId === newAdapterId)
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._adapterId = newAdapterId;
                r._endpoints = Reference._emptyEndpoints;
                return r;
            },
            changeEndpoints: function(newEndpoints)
            {
                if(ArrayUtil.equals(newEndpoints, this._endpoints, function(e1, e2) { return e1.equals(e2); }))
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._endpoints = newEndpoints;
                r._adapterId = "";
                r.applyOverrides(r._endpoints);
                return r;
            },
            changeLocator: function(newLocator)
            {
                var newLocatorInfo = this.getInstance().locatorManager().find(newLocator);
                if(newLocatorInfo !== null && this._locatorInfo !== null && newLocatorInfo.equals(this._locatorInfo))
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._locatorInfo = newLocatorInfo;
                return r;
            },
            changeRouter: function(newRouter)
            {
                var newRouterInfo = this.getInstance().routerManager().find(newRouter);
                if(newRouterInfo !== null && this._routerInfo !== null && newRouterInfo.equals(this._routerInfo))
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._routerInfo = newRouterInfo;
                return r;
            },
            changeCacheConnection: function(newCache)
            {
                if(newCache === this._cacheConnection)
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._cacheConnection = newCache;
                return r;
            },
            changePreferSecure: function(newPreferSecure)
            {
                if(newPreferSecure === this._preferSecure)
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._preferSecure = newPreferSecure;
                return r;
            },
            changeEndpointSelection: function(newType)
            {
                if(newType === this._endpointSelection)
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._endpointSelection = newType;
                return r;
            },
            changeLocatorCacheTimeout: function(newTimeout)
            {
                if(this._locatorCacheTimeout === newTimeout)
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._locatorCacheTimeout = newTimeout;
                return r;
            },
            changeTimeout: function(newTimeout)
            {
                if(this._overrideTimeout && this._timeout === newTimeout)
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._timeout = newTimeout;
                r._overrideTimeout = true;
                if(this._endpoints.length > 0)
                {
                    var newEndpoints = [];
                    for(var i = 0; i < this._endpoints.length; i++)
                    {
                        newEndpoints[i] = this._endpoints[i].changeTimeout(newTimeout);
                    }
                    r._endpoints = newEndpoints;
                }
                return r;
            },
            changeConnectionId: function(id)
            {
                if(this._connectionId === id)
                {
                    return this;
                }
                var r = this.getInstance().referenceFactory().copy(this);
                r._connectionId = id;
                if(this._endpoints.length > 0)
                {
                    var newEndpoints = [];
                    for(var i = 0; i < this._endpoints.length; i++)
                    {
                        newEndpoints[i] = this._endpoints[i].changeConnectionId(id);
                    }
                    r._endpoints = newEndpoints;
                }
                return r;
            },
            isIndirect: function()
            {
                return this._endpoints.length === 0;
            },
            isWellKnown: function()
            {
                return this._endpoints.length === 0 && this._adapterId.length === 0;
            },
            streamWrite: function(s)
            {
                Reference.prototype.streamWrite.call(this, s);
        
                s.writeSize(this._endpoints.length);
                if(this._endpoints.length > 0)
                {
                    Debug.assert(this._adapterId.length === 0);
                    for(var i = 0; i < this._endpoints.length; ++i)
                    {
                        s.writeShort(this._endpoints[i].type());
                        this._endpoints[i].streamWrite(s);
                    }
                }
                else
                {
                    s.writeString(this._adapterId); // Adapter id.
                }
            },
            toString: function()
            {
                //
                // WARNING: Certain features, such as proxy validation in Glacier2,
                // depend on the format of proxy strings. Changes to toString() and
                // methods called to generate parts of the reference string could break
                // these features. Please review for all features that depend on the
                // format of proxyToString() before changing this and related code.
                //
                var s = [];
                s.push(Reference.prototype.toString.call(this));
                if(this._endpoints.length > 0)
                {
                    for(var i = 0; i < this._endpoints.length; ++i)
                    {
                        var endp = this._endpoints[i].toString();
                        if(endp !== null && endp.length > 0)
                        {
                            s.push(':');
                            s.push(endp);
                        }
                    }
                }
                else if(this._adapterId.length > 0)
                {
                    s.push(" @ ");
        
                    //
                    // If the encoded adapter id string contains characters which
                    // the reference parser uses as separators, then we enclose
                    // the adapter id string in quotes.
                    //
                    var a = StringUtil.escapeString(this._adapterId, null);
                    if(a.search(/[ :@]/) != -1)
                    {
                        s.push('"');
                        s.push(a);
                        s.push('"');
                    }
                    else
                    {
                        s.push(a);
                    }
                }
                return s.join("");
            },
            toProperty: function(prefix)
            {
                var properties = new HashMap(), e;
        
                properties.set(prefix, this.toString());
                properties.set(prefix + ".CollocationOptimized", "0");
                properties.set(prefix + ".ConnectionCached", this._cacheConnection ? "1" : "0");
                properties.set(prefix + ".PreferSecure", this._preferSecure ? "1" : "0");
                properties.set(prefix + ".EndpointSelection",
                            this._endpointSelection === EndpointSelectionType.Random ? "Random" : "Ordered");
        
                properties.set(prefix + ".LocatorCacheTimeout", "" + this._locatorCacheTimeout);
                properties.set(prefix + ".InvocationTimeout", "" + this.getInvocationTimeout());
        
                if(this._routerInfo !== null)
                {
                    var h = this._routerInfo.getRouter();
                    var routerProperties = h.__reference().toProperty(prefix + ".Router");
                    for(e = routerProperties.entries; e !== null; e = e.next)
                    {
                        properties.set(e.key, e.value);
                    }
                }
        
                if(this._locatorInfo !== null)
                {
                    var p = this._locatorInfo.getLocator();
                    var locatorProperties = p.__reference().toProperty(prefix + ".Locator");
                    for(e = locatorProperties.entries; e !== null; e = e.next)
                    {
                        properties.set(e.key, e.value);
                    }
                }
        
                return properties;
            },
            hashCode: function()
            {
                if(!this._hashInitialized)
                {
                    Reference.prototype.hashCode.call(this); // Initializes _hashValue.
                    this._hashValue = HashUtil.addString(this._hashValue, this._adapterId);
                }
                return this._hashValue;
            },
            equals: function(rhs)
            {
                if(this === rhs)
                {
                    return true;
                }
                if(!(rhs instanceof RoutableReference))
                {
                    return false;
                }
        
                if(!Reference.prototype.equals.call(this, rhs))
                {
                    return false;
                }
        
                if(this._locatorInfo === null ? rhs._locatorInfo !== null : !this._locatorInfo.equals(rhs._locatorInfo))
                {
                    return false;
                }
                if(this._routerInfo === null ? rhs._routerInfo !== null : !this._routerInfo.equals(rhs._routerInfo))
                {
                    return false;
                }
                if(this._cacheConnection !== rhs._cacheConnection)
                {
                    return false;
                }
                if(this._preferSecure !== rhs._preferSecure)
                {
                    return false;
                }
                if(this._endpointSelection !== rhs._endpointSelection)
                {
                    return false;
                }
                if(this._locatorCacheTimeout !== rhs._locatorCacheTimeout)
                {
                    return false;
                }
                if(this._connectionId !== rhs._connectionId)
                {
                    return false;
                }
                if(this._overrideTimeout !== rhs._overrideTimeout)
                {
                    return false;
                }
                if(this._overrideTimeout && this._timeout !== rhs._timeout)
                {
                    return false;
                }
                if(!ArrayUtil.equals(this._endpoints, rhs._endpoints, function(e1, e2) { return e1.equals(e2); }))
                {
                    return false;
                }
                if(this._adapterId !== rhs._adapterId)
                {
                    return false;
                }
                return true;
            },
            getRequestHandler: function(proxy)
            {
                return this._instance.requestHandlerFactory().getRequestHandler(this, proxy);
            },
            getBatchRequestQueue: function()
            {
                return new BatchRequestQueue(this._instance, this._mode === RefMode.ModeBatchDatagram);
            },
            getConnection: function()
            {
                var promise = new Promise(); // success callback receives (connection, compress)
        
                if(this._routerInfo !== null)
                {
                    //
                    // If we route, we send everything to the router's client
                    // proxy endpoints.
                    //
                    var self = this;
                    this._routerInfo.getClientEndpoints().then(
                        function(endpts)
                        {
                            if(endpts.length > 0)
                            {
                                self.applyOverrides(endpts);
                                self.createConnection(endpts).then(
                                    function(connection, compress)
                                    {
                                        promise.succeed(connection, compress);
                                    },
                                    function(ex)
                                    {
                                        promise.fail(ex);
                                    });
                            }
                            else
                            {
                                self.getConnectionNoRouterInfo(promise);
                            }
                        }).exception(
                            function(ex)
                            {
                                promise.fail(ex);
                            });
                }
                else
                {
                    this.getConnectionNoRouterInfo(promise);
                }
        
                return promise;
            },
            getConnectionNoRouterInfo: function(promise)
            {
                if(this._endpoints.length > 0)
                {
                    this.createConnection(this._endpoints).then(
                        function(connection, compress)
                        {
                            promise.succeed(connection, compress);
                        }).exception(
                            function(ex)
                            {
                                promise.fail(ex);
                            });
                    return;
                }
        
                var self = this;
                if(this._locatorInfo !== null)
                {
                    this._locatorInfo.getEndpoints(this, null, this._locatorCacheTimeout).then(
                        function(endpoints, cached)
                        {
                            if(endpoints.length === 0)
                            {
                                promise.fail(new Ice.NoEndpointException(self.toString()));
                                return;
                            }
        
                            self.applyOverrides(endpoints);
                            self.createConnection(endpoints).then(
                                function(connection, compress)
                                {
                                    promise.succeed(connection, compress);
                                },
                                function(ex)
                                {
                                    if(ex instanceof Ice.NoEndpointException)
                                    {
                                        //
                                        // No need to retry if there's no endpoints.
                                        //
                                        promise.fail(ex);
                                    }
                                    else
                                    {
                                        Debug.assert(self._locatorInfo !== null);
                                        self.getLocatorInfo().clearCache(self);
                                        if(cached)
                                        {
                                            var traceLevels = self.getInstance().traceLevels();
                                            if(traceLevels.retry >= 2)
                                            {
                                                var s = "connection to cached endpoints failed\n" +
                                                        "removing endpoints from cache and trying one more time\n" +
                                                        ex.toString();
                                                self.getInstance().initializationData().logger.trace(traceLevels.retryCat, s);
                                            }
                                            self.getConnectionNoRouterInfo(promise); // Retry.
                                            return;
                                        }
                                        promise.fail(ex);
                                    }
                                });
                        }).exception(
                            function(ex)
                            {
                                promise.fail(ex);
                            });
                }
                else
                {
                    promise.fail(new Ice.NoEndpointException(this.toString()));
                }
            },
            clone: function()
            {
                var r = new RoutableReference(this.getInstance(),
                                                this.getCommunicator(),
                                                this.getIdentity(),
                                                this.getFacet(),
                                                this.getMode(),
                                                this.getSecure(),
                                                this.getProtocol(),
                                                this.getEncoding(),
                                                this._endpoints,
                                                this._adapterId,
                                                this._locatorInfo,
                                                this._routerInfo,
                                                this._cacheConnection,
                                                this._preferSecure,
                                                this._endpointSelection,
                                                this._locatorCacheTimeout,
                                                this._invocationTimeout);
                this.copyMembers(r);
                return r;
            },
            copyMembers: function(rhs)
            {
                //
                // Copy the members that are not passed to the constructor.
                //
                Reference.prototype.copyMembers.call(this, rhs);
                rhs._overrideTimeout = this._overrideTimeout;
                rhs._timeout = this._timeout;
                rhs._connectionId = this._connectionId;
            },
            applyOverrides: function(endpts)
            {
                //
                // Apply the endpoint overrides to each endpoint.
                //
                for(var i = 0; i < endpts.length; ++i)
                {
                    endpts[i] = endpts[i].changeConnectionId(this._connectionId);
                    if(this._overrideCompress)
                    {
                        endpts[i] = endpts[i].changeCompress(this._compress);
                    }
                    if(this._overrideTimeout)
                    {
                        endpts[i] = endpts[i].changeTimeout(this._timeout);
                    }
                }
            },
            filterEndpoints: function(allEndpoints)
            {
                var endpoints = [];
        
                //
                // Filter out opaque endpoints or endpoints which can't connect.
                //
                for(var i = 0; i < allEndpoints.length; ++i)
                {
                    if(!(allEndpoints[i] instanceof OpaqueEndpointI) && allEndpoints[i].connectable())
                    {
                        endpoints.push(allEndpoints[i]);
                    }
                }
        
                //
                // Filter out endpoints according to the mode of the reference.
                //
                switch(this.getMode())
                {
                    case RefMode.ModeTwoway:
                    case RefMode.ModeOneway:
                    case RefMode.ModeBatchOneway:
                    {
                        //
                        // Filter out datagram endpoints.
                        //
                        endpoints = ArrayUtil.filter(endpoints, function(e, index, arr) { return !e.datagram(); });
                        break;
                    }
        
                    case RefMode.ModeDatagram:
                    case RefMode.ModeBatchDatagram:
                    {
                        //
                        // Filter out non-datagram endpoints.
                        //
                        endpoints = ArrayUtil.filter(endpoints, function(e, index, arr) { return e.datagram(); });
                        break;
                    }
                }
        
                //
                // Sort the endpoints according to the endpoint selection type.
                //
                switch(this.getEndpointSelection())
                {
                    case EndpointSelectionType.Random:
                    {
                        //
                        // Shuffle the endpoints.
                        //
                        ArrayUtil.shuffle(endpoints);
                        break;
                    }
                    case EndpointSelectionType.Ordered:
                    {
                        // Nothing to do.
                        break;
                    }
                    default:
                    {
                        Debug.assert(false);
                        break;
                    }
                }
        
                //
                // If a secure connection is requested or secure overrides is
                // set, remove all non-secure endpoints. Otherwise if preferSecure is set
                // make secure endpoints prefered. By default make non-secure
                // endpoints preferred over secure endpoints.
                //
                var overrides = this.getInstance().defaultsAndOverrides();
                if(overrides.overrideSecure ? overrides.overrideSecureValue : this.getSecure())
                {
                    endpoints = ArrayUtil.filter(endpoints, function(e, index, arr) { return e.secure(); });
                }
                else
                {
                    var preferSecure = this.getPreferSecure();
                    var compare = function(e1, e2)
                    {
                        var ls = e1.secure();
                        var rs = e2.secure();
                        if((ls && rs) || (!ls && !rs))
                        {
                            return 0;
                        }
                        else if(!ls && rs)
                        {
                            return preferSecure ? 1 : -1;
                        }
                        else
                        {
                            return preferSecure ? -1 : 1;
                        }
                    };
                    endpoints.sort(compare);
                }
                return endpoints;
            },
            createConnection: function(allEndpoints)
            {
                var endpoints = this.filterEndpoints(allEndpoints);
                if(endpoints.length === 0)
                {
                    return new Promise().fail(new Ice.NoEndpointException(this.toString()));
                }
        
                //
                // Finally, create the connection.
                //
                var promise = new Promise();
                var factory = this.getInstance().outgoingConnectionFactory();
                var cb;
                if(this.getCacheConnection() || endpoints.length == 1)
                {
                    //
                    // Get an existing connection or create one if there's no
                    // existing connection to one of the given endpoints.
                    //
                    cb = new CreateConnectionCallback(this, null, promise);
                    factory.create(endpoints, false, this.getEndpointSelection()).then(
                        function(connection, compress)
                        {
                            cb.setConnection(connection, compress);
                        }).exception(
                            function(ex)
                            {
                                cb.setException(ex);
                            });
                }
                else
                {
                    //
                    // Go through the list of endpoints and try to create the
                    // connection until it succeeds. This is different from just
                    // calling create() with the given endpoints since this might
                    // create a new connection even if there's an existing
                    // connection for one of the endpoints.
                    //
                    var v = [ endpoints[0] ];
                    cb = new CreateConnectionCallback(this, endpoints, promise);
                    factory.create(v, true, this.getEndpointSelection()).then(
                        function(connection, compress)
                        {
                            cb.setConnection(connection, compress);
                        }).exception(
                            function(ex)
                            {
                                cb.setException(ex);
                            });
                }
        
                return promise;
            }
        });
        
        Ice.RoutableReference = RoutableReference;
        
        var CreateConnectionCallback = Class({
            __init__: function(r, endpoints, promise)
            {
                this.ref = r;
                this.endpoints = endpoints;
                this.promise = promise;
                this.i = 0;
                this.exception = null;
            },
            setConnection: function(connection, compress)
            {
                //
                // If we have a router, set the object adapter for this router
                // (if any) to the new connection, so that callbacks from the
                // router can be received over this new connection.
                //
                if(this.ref.getRouterInfo() !== null && this.ref.getRouterInfo().getAdapter() !== null)
                {
                    connection.setAdapter(this.ref.getRouterInfo().getAdapter());
                }
                this.promise.succeed(connection, compress);
            },
            setException: function(ex)
            {
                if(this.exception === null)
                {
                    this.exception = ex;
                }
        
                if(this.endpoints === null || ++this.i === this.endpoints.length)
                {
                    this.promise.fail(this.exception);
                    return;
                }
        
                var more = this.i != this.endpoints.length - 1;
                var arr = [ this.endpoints[this.i] ];
                var self = this;
                this.ref.getInstance().outgoingConnectionFactory().create(arr, more, this.ref.getEndpointSelection()).then(
                    function(connection, compress)
                    {
                        self.setConnection(connection, compress);
                    }).exception(
                        function(ex)
                        {
                            self.setException(ex);
                        });
            }
        });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        //
        // Local aliases.
        //
        var Debug = Ice.Debug;
        var BasicStream = Ice.BasicStream;
        var EndpointParseException = Ice.EndpointParseException;
        var OpaqueEndpointI = Ice.OpaqueEndpointI;
        var Protocol = Ice.Protocol;
        var StringUtil = Ice.StringUtil;
        
        var EndpointFactoryManager = Ice.Class({
            __init__: function(instance)
            {
                this._instance = instance;
                this._factories = [];
            },
            add: function(factory)
            {
                for(var i = 0; i < this._factories.length; ++i)
                {
                    Debug.assert(this._factories[i].type() != factory.type());
                }
        
                this._factories.push(factory);
            },
            get: function(type)
            {
                for(var i = 0; i < this._factories.length; ++i)
                {
                    if(this._factories[i].type() === type)
                    {
                        return this._factories[i];
                    }
                }
                return null;
            },
            create: function(str, oaEndpoint)
            {
                var s = str.trim();
                if(s.length === 0)
                {
                    throw new EndpointParseException("value has no non-whitespace characters");
                }
        
                var arr = StringUtil.splitString(s, " \t\n\r");
                if(arr.length === 0)
                {
                    throw new EndpointParseException("value has no non-whitespace characters");
                }
        
                var protocol = arr[0];
                arr.splice(0, 1);
        
                if(protocol === "default")
                {
                    protocol = this._instance.defaultsAndOverrides().defaultProtocol;
                }
        
                for(var i = 0, length = this._factories.length; i < length; ++i)
                {
                    if(this._factories[i].protocol() === protocol)
                    {
                        var e = this._factories[i].create(arr, oaEndpoint);
                        if(arr.length > 0)
                        {
                            throw new EndpointParseException("unrecognized argument `" + arr[0] + "' in endpoint `" +
                                                             str + "'");
                        }
                        return e;
                    }
                }
        
                //
                // If the stringified endpoint is opaque, create an unknown endpoint,
                // then see whether the type matches one of the known endpoints.
                //
                if(protocol === "opaque")
                {
                    var ue = new OpaqueEndpointI();
                    ue.initWithOptions(arr);
                    if(arr.length > 0)
                    {
                        throw new EndpointParseException("unrecognized argument `" + arr[0] + "' in endpoint `" + str + "'");
                    }
        
                    for(i = 0, length =  this._factories.length; i < length; ++i)
                    {
                        if(this._factories[i].type() == ue.type())
                        {
                            //
                            // Make a temporary stream, write the opaque endpoint data into the stream,
                            // and ask the factory to read the endpoint data from that stream to create
                            // the actual endpoint.
                            //
                            var bs = new BasicStream(this._instance, Protocol.currentProtocolEncoding);
                            bs.writeShort(ue.type());
                            ue.streamWrite(bs);
                            bs.pos = 0;
                            bs.readShort(); // type
                            bs.startReadEncaps();
                            var endpoint = this._factories[i].read(bs);
                            bs.endReadEncaps();
                            return endpoint;
                        }
                    }
                    return ue; // Endpoint is opaque, but we don't have a factory for its type.
                }
        
                return null;
            },
            read: function(s)
            {
                var e;
                var type = s.readShort();
                for(var i = 0; i < this._factories.length; ++i)
                {
                    if(this._factories[i].type() == type)
                    {
                        s.startReadEncaps();
                        e = this._factories[i].read(s);
                        s.endReadEncaps();
                        return e;
                    }
                }
                s.startReadEncaps();
                e = new OpaqueEndpointI(type);
                e.initWithStream(s);
                s.endReadEncaps();
                return e;
            },
            destroy: function()
            {
                for(var i = 0; i < this._factories.length; ++i)
                {
                    this._factories[i].destroy();
                }
                this._factories = [];
            }
        });
        
        Ice.EndpointFactoryManager = EndpointFactoryManager;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Debug = Ice.Debug;
        var HashMap = Ice.HashMap;
        var ObjectPrx = Ice.ObjectPrx;
        var StringUtil = Ice.StringUtil;
        var Identity = Ice.Identity;
        
        //
        // Only for use by Instance.
        //
        var ProxyFactory = Ice.Class({
            __init__: function(instance)
            {
                this._instance = instance;
        
                var arr = this._instance.initializationData().properties.getPropertyAsList("Ice.RetryIntervals");
        
                if(arr.length > 0)
                {
                    this._retryIntervals = [];
        
                    for(var i = 0; i < arr.length; i++)
                    {
                        var v;
        
                        try
                        {
                            v = StringUtil.toInt(arr[i]);
                        }
                        catch(ex)
                        {
                            v = 0;
                        }
        
                        //
                        // If -1 is the first value, no retry and wait intervals.
                        //
                        if(i === 0 && v === -1)
                        {
                            break;
                        }
        
                        this._retryIntervals[i] = v > 0 ? v : 0;
                    }
                }
                else
                {
                    this._retryIntervals = [ 0 ];
                }
            },
            stringToProxy: function(str)
            {
                var ref = this._instance.referenceFactory().createFromString(str, null);
                return this.referenceToProxy(ref);
            },
            proxyToString: function(proxy)
            {
                if(proxy !== null)
                {
                    return proxy.__reference().toString();
                }
                else
                {
                    return "";
                }
            },
            propertyToProxy: function(prefix)
            {
                var proxy = this._instance.initializationData().properties.getProperty(prefix);
                var ref = this._instance.referenceFactory().createFromString(proxy, prefix);
                return this.referenceToProxy(ref);
            },
            proxyToProperty: function(proxy, prefix)
            {
                if(proxy !== null)
                {
                    return proxy.__reference().toProperty(prefix);
                }
                else
                {
                    return new HashMap();
                }
            },
            streamToProxy: function(s, type)
            {
                var ident = new Identity();
                ident.__read(s);
        
                var ref = this._instance.referenceFactory().createFromStream(ident, s);
                return this.referenceToProxy(ref, type);
            },
            referenceToProxy: function(ref, type)
            {
                if(ref !== null)
                {
                    var proxy = type ? new type() : new ObjectPrx();
                    proxy.__setup(ref);
                    return proxy;
                }
                else
                {
                    return null;
                }
            },
            proxyToStream: function(proxy, s)
            {
                if(proxy !== null)
                {
                    var ref = proxy.__reference();
                    ref.getIdentity().__write(s);
                    ref.streamWrite(s);
                }
                else
                {
                    var ident = new Identity("", "");
                    ident.__write(s);
                }
            },
            checkRetryAfterException: function(ex, ref, sleepInterval, cnt)
            {
                var traceLevels = this._instance.traceLevels();
                var logger = this._instance.initializationData().logger;
        
                //
                // We don't retry batch requests because the exception might have caused
                // the all the requests batched with the connection to be aborted and we
                // want the application to be notified.
                //
                if(ref.getMode() === Ice.Reference.ModeBatchOneway || ref.getMode() === Ice.Reference.ModeBatchDatagram)
                {
                    throw ex;
                }
        
                if(ex instanceof Ice.ObjectNotExistException)
                {
                    var one = ex;
        
                    if(ref.getRouterInfo() !== null && one.operation === "ice_add_proxy")
                    {
                        //
                        // If we have a router, an ObjectNotExistException with an
                        // operation name "ice_add_proxy" indicates to the client
                        // that the router isn't aware of the proxy (for example,
                        // because it was evicted by the router). In this case, we
                        // must *always* retry, so that the missing proxy is added
                        // to the router.
                        //
        
                        ref.getRouterInfo().clearCache(ref);
        
                        if(traceLevels.retry >= 1)
                        {
                            logger.trace(traceLevels.retryCat, "retrying operation call to add proxy to router\n" +
                                                            ex.toString());
                        }
        
                        if(sleepInterval !== null)
                        {
                            sleepInterval.value = 0;
                        }
                        return cnt; // We must always retry, so we don't look at the retry count.
                    }
                    else if(ref.isIndirect())
                    {
                        //
                        // We retry ObjectNotExistException if the reference is
                        // indirect.
                        //
        
                        if(ref.isWellKnown())
                        {
                            var li = ref.getLocatorInfo();
                            if(li !== null)
                            {
                                li.clearCache(ref);
                            }
                        }
                    }
                    else
                    {
                        //
                        // For all other cases, we don't retry ObjectNotExistException.
                        //
                        throw ex;
                    }
                }
                else if(ex instanceof Ice.RequestFailedException)
                {
                    //
                    // For all other cases, we don't retry ObjectNotExistException
                    //
                    throw ex;
                }
        
                //
                // There is no point in retrying an operation that resulted in a
                // MarshalException. This must have been raised locally (because
                // if it happened in a server it would result in an
                // UnknownLocalException instead), which means there was a problem
                // in this process that will not change if we try again.
                //
                // The most likely cause for a MarshalException is exceeding the
                // maximum message size, which is represented by the the subclass
                // MemoryLimitException. For example, a client can attempt to send
                // a message that exceeds the maximum memory size, or accumulate
                // enough batch requests without flushing that the maximum size is
                // reached.
                //
                // This latter case is especially problematic, because if we were
                // to retry a batch request after a MarshalException, we would in
                // fact silently discard the accumulated requests and allow new
                // batch requests to accumulate. If the subsequent batched
                // requests do not exceed the maximum message size, it appears to
                // the client that all of the batched requests were accepted, when
                // in reality only the last few are actually sent.
                //
                if(ex instanceof Ice.MarshalException)
                {
                    throw ex;
                }
        
                //
                // Don't retry if the communicator is destroyed or object adapter
                // deactivated.
                //
                if(ex instanceof Ice.CommunicatorDestroyedException || ex instanceof Ice.ObjectAdapterDeactivatedException)
                {
                    throw ex;
                }
        
                //
                // Don't retry invocation timeouts.
                //
                if(ex instanceof Ice.InvocationTimeoutException || ex instanceof Ice.InvocationCanceledException)
                {
                    throw ex;
                }
        
                ++cnt;
                Debug.assert(cnt > 0);
        
                var interval;
                if(cnt === (this._retryIntervals.length + 1) && ex instanceof Ice.CloseConnectionException)
                {
                    //
                    // A close connection exception is always retried at least once, even if the retry
                    // limit is reached.
                    //
                    interval = 0;
                }
                else if(cnt > this._retryIntervals.length)
                {
                    if(traceLevels.retry >= 1)
                    {
                        logger.trace(traceLevels.retryCat,
        			     "cannot retry operation call because retry limit has been exceeded\n" + ex.toString());
                    }
                    throw ex;
                }
                else
                {
                    interval = this._retryIntervals[cnt - 1];
                }
        
                if(traceLevels.retry >= 1)
                {
                    var msg = "retrying operation call";
                    if(interval > 0)
                    {
                        msg += " in " + interval + "ms";
                    }
                    msg += " because of exception\n" + ex.toString();
                    logger.trace(traceLevels.retryCat, msg);
                }
        
                Debug.assert(sleepInterval !== null);
                sleepInterval.value = interval;
        
                return cnt;
            }
        });
        
        Ice.ProxyFactory = ProxyFactory;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        
        var FormatType = Ice.FormatType;
        var EndpointSelectionType = Ice.EndpointSelectionType;
        var Protocol = Ice.Protocol;
        
        var DefaultsAndOverrides = function(properties, logger)
        {
            this.defaultProtocol = properties.getPropertyWithDefault("Ice.Default.Protocol",
                                                                     Ice.TcpEndpointFactory !== undefined ? "tcp" : "ws");
        
            var value = properties.getProperty("Ice.Default.Host");
            this.defaultHost = value.length > 0 ? value : null;
        
            value = properties.getProperty("Ice.Default.SourceAddress");
            this.defaultSourceAddress = value.length > 0 ? value : null;
        
            value = properties.getProperty("Ice.Override.Timeout");
            if(value.length > 0)
            {
                this.overrideTimeout = true;
                this.overrideTimeoutValue = properties.getPropertyAsInt("Ice.Override.Timeout");
                if(this.overrideTimeoutValue < 1 && this.overrideTimeoutValue !== -1)
                {
                    this.overrideTimeoutValue = -1;
                    logger.warning("invalid value for Ice.Override.Timeout `" +
                                    properties.getProperty("Ice.Override.Timeout") + "': defaulting to -1");
                }
            }
            else
            {
                this.overrideTimeout = false;
                this.overrideTimeoutValue = -1;
            }
        
            value = properties.getProperty("Ice.Override.ConnectTimeout");
            if(value.length > 0)
            {
                this.overrideConnectTimeout = true;
                this.overrideConnectTimeoutValue = properties.getPropertyAsInt("Ice.Override.ConnectTimeout");
                if(this.overrideConnectTimeoutValue < 1 && this.overrideConnectTimeoutValue !== -1)
                {
                    this.overrideConnectTimeoutValue = -1;
                    logger.warning("invalid value for Ice.Override.ConnectTimeout `" +
                                    properties.getProperty("Ice.Override.ConnectTimeout") + "': defaulting to -1");
                }
            }
            else
            {
                this.overrideConnectTimeout = false;
                this.overrideConnectTimeoutValue = -1;
            }
        
            value = properties.getProperty("Ice.Override.CloseTimeout");
            if(value.length > 0)
            {
                this.overrideCloseTimeout = true;
                this.overrideCloseTimeoutValue = properties.getPropertyAsInt("Ice.Override.CloseTimeout");
                if(this.overrideCloseTimeoutValue < 1 && this.overrideCloseTimeoutValue !== -1)
                {
                    this.overrideCloseTimeoutValue = -1;
                    logger.warning("invalid value for Ice.Override.CloseTimeout `" +
                                    properties.getProperty("Ice.Override.CloseTimeout") + "': defaulting to -1");
                }
            }
            else
            {
                this.overrideCloseTimeout = false;
                this.overrideCloseTimeoutValue = -1;
            }
        
            this.overrideCompress = false;
            this.overrideSecure = false;
        
            value = properties.getPropertyWithDefault("Ice.Default.EndpointSelection", "Random");
            if(value === "Random")
            {
                this.defaultEndpointSelection = EndpointSelectionType.Random;
            }
            else if(value === "Ordered")
            {
                this.defaultEndpointSelection = EndpointSelectionType.Ordered;
            }
            else
            {
                var ex = new Ice.EndpointSelectionTypeParseException();
                ex.str = "illegal value `" + value + "'; expected `Random' or `Ordered'";
                throw ex;
            }
        
            this.defaultTimeout = properties.getPropertyAsIntWithDefault("Ice.Default.Timeout", 60000);
            if(this.defaultTimeout < 1 && this.defaultTimeout !== -1)
            {
                this.defaultTimeout = 60000;
                logger.warning("invalid value for Ice.Default.Timeout `" + properties.getProperty("Ice.Default.Timeout") +
                               "': defaulting to 60000");
            }
        
            this.defaultLocatorCacheTimeout = properties.getPropertyAsIntWithDefault("Ice.Default.LocatorCacheTimeout", -1);
            if(this.defaultLocatorCacheTimeout < -1)
            {
                this.defaultLocatorCacheTimeout = -1;
                logger.warning("invalid value for Ice.Default.LocatorCacheTimeout `" +
                               properties.getProperty("Ice.Default.LocatorCacheTimeout") + "': defaulting to -1");
            }
        
            this.defaultInvocationTimeout = properties.getPropertyAsIntWithDefault("Ice.Default.InvocationTimeout", -1);
            if(this.defaultInvocationTimeout < 1 && this.defaultInvocationTimeout !== -1)
            {
                this.defaultInvocationTimeout = -1;
                logger.warning("invalid value for Ice.Default.InvocationTimeout `" +
                               properties.getProperty("Ice.Default.InvocationTimeout") + "': defaulting to -1");
            }
        
            this.defaultPreferSecure = properties.getPropertyAsIntWithDefault("Ice.Default.PreferSecure", 0) > 0;
        
            value = properties.getPropertyWithDefault("Ice.Default.EncodingVersion",
                                                      Ice.encodingVersionToString(Protocol.currentEncoding));
            this.defaultEncoding = Ice.stringToEncodingVersion(value);
            Protocol.checkSupportedEncoding(this.defaultEncoding);
        
            var slicedFormat = properties.getPropertyAsIntWithDefault("Ice.Default.SlicedFormat", 0) > 0;
            this.defaultFormat = slicedFormat ? FormatType.SlicedFormat : FormatType.CompactFormat;
        };
        
        Ice.DefaultsAndOverrides = DefaultsAndOverrides;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var StringUtil = Ice.StringUtil;
        var Identity = Ice.Identity;
        var IdentityParseException = Ice.IdentityParseException;
        
        /**
        * Converts a string to an object identity.
        *
        * @param s The string to convert.
        *
        * @return The converted object identity.
        **/
        Ice.stringToIdentity = function(s)
        {
            var ident = new Identity();
        
            //
            // Find unescaped separator; note that the string may contain an escaped
            // backslash before the separator.
            //
            var slash = -1;
            var pos = 0;
            while((pos = s.indexOf('/', pos)) !== -1)
            {
                var escapes = 0;
                while(pos - escapes > 0 && s.charAt(pos - escapes - 1) == '\\')
                {
                    escapes++;
                }
                    
                //
                // We ignore escaped escapes
                //
                if(escapes % 2 === 0)
                {
                    if(slash == -1)
                    {
                        slash = pos;
                    }
                    else
                    {
                        //
                        // Extra unescaped slash found.
                        //
                        var ex = new IdentityParseException();
                        ex.str = "unescaped backslash in identity `" + s + "'";
                        throw ex;
                    }
                }
                pos++;
            }
        
            if(slash == -1)
            {
                ident.category = "";
                try
                {
                    ident.name = StringUtil.unescapeString(s);
                }
                catch(e)
                {
                    var ex = new IdentityParseException();
                    ex.str = "invalid identity name `" + s + "': " + ex.toString();
                    throw ex;
                }
            }
            else
            {
                try
                {
                    ident.category = StringUtil.unescapeString(s, 0, slash);
                }
                catch(e)
                {
                    var ex = new IdentityParseException();
                    ex.str = "invalid category in identity `" + s + "': " + ex.toString();
                    throw ex;
                }
                if(slash + 1 < s.length)
                {
                    try
                    {
                        ident.name = StringUtil.unescapeString(s, slash + 1, s.length);
                    }
                    catch(e)
                    {
                        var ex = new IdentityParseException();
                        ex.str = "invalid name in identity `" + s + "': " + ex.toString();
                        throw ex;
                    }
                }
                else
                {
                    ident.name = "";
                }
            }
        
            return ident;
        };
        
        /**
        * Converts an object identity to a string.
        *
        * @param ident The object identity to convert.
        *
        * @return The string representation of the object identity.
        **/
        Ice.identityToString = function(ident)
        {
            if(ident.category === null || ident.category.length === 0)
            {
                return StringUtil.escapeString(ident.name, "/");
            }
            else
            {
                return StringUtil.escapeString(ident.category, "/") + '/' + StringUtil.escapeString(ident.name, "/");
            }
        };
        
        /**
        * Compares the object identities of two proxies.
        *
        * @param lhs A proxy.
        * @param rhs A proxy.
        * @return -1 if the identity in <code>lhs</code> compares
        * less than the identity in <code>rhs</code>; 0 if the identities
        * compare equal; 1, otherwise.
        *
        * @see ProxyIdentityKey
        * @see ProxyIdentityAndFacetKey
        * @see ProxyIdentityAndFacetCompare
        **/
        Ice.proxyIdentityCompare = function(lhs, rhs)
        {
            if(lhs === rhs)
            {
                return 0;
            }
            else if(lhs === null && rhs !== null)
            {
                return -1;
            }
            else if(lhs !== null && rhs === null)
            {
                return 1;
            }
            else
            {
                var lhsIdentity = lhs.ice_getIdentity();
                var rhsIdentity = rhs.ice_getIdentity();
                var n;
                if((n = lhsIdentity.name.localeCompare(rhsIdentity.name)) !== 0)
                {
                    return n;
                }
                return lhsIdentity.category.localeCompare(rhsIdentity.category);
            }
        };
        
        /**
        * Compares the object identities and facets of two proxies.
        *
        * @param lhs A proxy.
        * @param rhs A proxy.
        * @return -1 if the identity and facet in <code>lhs</code> compare
        * less than the identity and facet in <code>rhs</code>; 0 if the identities
        * and facets compare equal; 1, otherwise.
        *
        * @see ProxyIdentityAndFacetKey
        * @see ProxyIdentityKey
        * @see ProxyIdentityCompare
        **/
        Ice.proxyIdentityAndFacetCompare = function(lhs, rhs)
        {
            if(lhs === rhs)
            {
                return 0;
            }
            else if(lhs === null && rhs !== null)
            {
                return -1;
            }
            else if(lhs !== null && rhs === null)
            {
                return 1;
            }
            else
            {
                var lhsIdentity = lhs.ice_getIdentity();
                var rhsIdentity = rhs.ice_getIdentity();
                var n;
                if((n = lhsIdentity.name.localeCompare(rhsIdentity.name)) !== 0)
                {
                    return n;
                }
                if((n = lhsIdentity.category.localeCompare(rhsIdentity.category)) !== 0)
                {
                    return n;
                }
        
                var lhsFacet = lhs.ice_getFacet();
                var rhsFacet = rhs.ice_getFacet();
                if(lhsFacet === null && rhsFacet === null)
                {
                    return 0;
                }
                else if(lhsFacet === null)
                {
                    return -1;
                }
                else if(rhsFacet === null)
                {
                    return 1;
                }
                return lhsFacet.localeCompare(rhsFacet);
            }
        };
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var ArrayUtil = Ice.ArrayUtil;
        var AsyncResultBase = Ice.AsyncResultBase;
        var ConnectionI = Ice.ConnectionI;
        var ConnectionReaper = Ice.ConnectionReaper;
        var Debug = Ice.Debug;
        var HashMap = Ice.HashMap;
        var Promise = Ice.Promise;
        var EndpointSelectionType = Ice.EndpointSelectionType;
        var FactoryACMMonitor = Ice.FactoryACMMonitor;
        var Class = Ice.Class;
        
        //
        // Only for use by Instance.
        //
        var OutgoingConnectionFactory = Class({
            __init__: function(communicator, instance)
            {
                this._communicator = communicator;
                this._instance = instance;
                this._destroyed = false;
        
                this._monitor = new FactoryACMMonitor(this._instance, this._instance.clientACM());
        
                this._connectionsByEndpoint = new ConnectionListMap(); // map<EndpointI, Array<Ice.ConnectionI>>
                this._pending = new HashMap(HashMap.compareEquals); // map<EndpointI, Array<ConnectCallback>>
                this._pendingConnectCount = 0;
        
                this._waitPromise = null;
            },
            destroy: function()
            {
                if(this._destroyed)
                {
                    return;
                }
        
                this._connectionsByEndpoint.forEach(function(connection)
                                                    {
                                                        connection.destroy(ConnectionI.CommunicatorDestroyed);
                                                    });
        
                this._destroyed = true;
                this._communicator = null;
                this.checkFinished();
            },
            waitUntilFinished: function()
            {
                this._waitPromise = new Promise();
                this.checkFinished();
                return this._waitPromise;
            },
            //
            // Returns a promise, success callback receives (connection, compress)
            //
            create: function(endpts, hasMore, selType)
            {
                Debug.assert(endpts.length > 0);
        
                //
                // Apply the overrides.
                //
                var endpoints = this.applyOverrides(endpts);
        
                //
                // Try to find a connection to one of the given endpoints.
                //
                try
                {
                    var compress = { value: false };
                    var connection = this.findConnectionByEndpoint(endpoints, compress);
                    if(connection !== null)
                    {
                        return new Promise().succeed(connection, compress.value);
                    }
                }
                catch(ex)
                {
                    return new Promise().fail(ex);
                }
        
                var cb = new ConnectCallback(this, endpoints, hasMore, selType);
                return cb.start();
            },
            setRouterInfo: function(routerInfo)
            {
                var self = this;
                return Ice.Promise.try2(
                    function()
                    {
                        if(self._destroyed)
                        {
                            throw new Ice.CommunicatorDestroyedException();
                        }
                        return routerInfo.getClientEndpoints();
                    }
                ).then(
                    function(endpoints)
                    {
                        //
                        // Search for connections to the router's client proxy
                        // endpoints, and update the object adapter for such
                        // connections, so that callbacks from the router can be
                        // received over such connections.
                        //
                        var adapter = routerInfo.getAdapter();
                        var defaultsAndOverrides = self._instance.defaultsAndOverrides();
                        for(var i = 0; i < endpoints.length; ++i)
                        {
                            var endpoint = endpoints[i];
        
                            //
                            // Modify endpoints with overrides.
                            //
                            if(defaultsAndOverrides.overrideTimeout)
                            {
                                endpoint = endpoint.changeTimeout(defaultsAndOverrides.overrideTimeoutValue);
                            }
        
                            //
                            // The Connection object does not take the compression flag of
                            // endpoints into account, but instead gets the information
                            // about whether messages should be compressed or not from
                            // other sources. In order to allow connection sharing for
                            // endpoints that differ in the value of the compression flag
                            // only, we always set the compression flag to false here in
                            // this connection factory.
                            //
                            endpoint = endpoint.changeCompress(false);
        
                            for(var j = 0; j < self._connectionsByEndpoint.length; ++j)
                            {
                                var connection = self._connectionsByEndpoint[j];
                                if(connection.endpoint().equals(endpoint))
                                {
                                    connection.setAdapter(adapter);
                                }
                            }
                        }
                    }
                );
            },
            removeAdapter: function(adapter)
            {
                if(this._destroyed)
                {
                    return;
                }
                this._connectionsByEndpoint.forEach(function(connection)
                                                    {
                                                        if(connection.getAdapter() === adapter)
                                                        {
                                                            connection.setAdapter(null);
                                                        }
                                                    });
            },
            flushAsyncBatchRequests: function()
            {
                var promise = new AsyncResultBase(this._communicator, "flushBatchRequests", null, null, null);
                if(this._destroyed)
                {
                    promise.succeed();
                    return;
                }
        
                Promise.all(
                    this._connectionsByEndpoint.map(
                        function(connection)
                        {
                            if(connection.isActiveOrHolding())
                            {
                                return connection.flushBatchRequests().exception(
                                    function(ex)
                                    {
                                        if(ex instanceof Ice.LocalException)
                                        {
                                            // Ignore
                                        }
                                        else
                                        {
                                            throw ex;
                                        }
                                    });
                            }
                        })
                ).then(
                    function()
                    {
                        promise.succeed(promise);
                    },
                    function(ex)
                    {
                        promise.fail(ex, promise);
                    }
                );
                return promise;
            },
            applyOverrides: function(endpts)
            {
                var defaultsAndOverrides = this._instance.defaultsAndOverrides();
                var endpoints = [];
                for(var i = 0; i < endpts.length; ++i)
                {
                    var endpoint = endpts[i];
        
                    //
                    // Modify endpoints with overrides.
                    //
                    if(defaultsAndOverrides.overrideTimeout)
                    {
                        endpoints.push(endpoint.changeTimeout(defaultsAndOverrides.overrideTimeoutValue));
                    }
                    else
                    {
                        endpoints.push(endpoint);
                    }
                }
        
                return endpoints;
            },
            findConnectionByEndpoint: function(endpoints, compress)
            {
                if(this._destroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                var defaultsAndOverrides = this._instance.defaultsAndOverrides();
                Debug.assert(endpoints.length > 0);
        
                for(var i = 0; i < endpoints.length; ++i)
                {
                    var endpoint = endpoints[i];
        
                    if(this._pending.has(endpoint))
                    {
                        continue;
                    }
        
                    var connectionList = this._connectionsByEndpoint.get(endpoint);
                    if(connectionList === undefined)
                    {
                        continue;
                    }
        
                    for(var j = 0; j < connectionList.length; ++j)
                    {
                        if(connectionList[j].isActiveOrHolding()) // Don't return destroyed or un-validated connections
                        {
                            if(defaultsAndOverrides.overrideCompress)
                            {
                                compress.value = defaultsAndOverrides.overrideCompressValue;
                            }
                            else
                            {
                                compress.value = endpoint.compress();
                            }
                            return connectionList[j];
                        }
                    }
                }
        
                return null;
            },
            incPendingConnectCount: function()
            {
                //
                // Keep track of the number of pending connects. The outgoing connection factory
                // waitUntilFinished() method waits for all the pending connects to terminate before
                // to return. This ensures that the communicator client thread pool isn't destroyed
                // too soon and will still be available to execute the ice_exception() callbacks for
                // the asynchronous requests waiting on a connection to be established.
                //
        
                if(this._destroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
                ++this._pendingConnectCount;
            },
            decPendingConnectCount: function()
            {
                --this._pendingConnectCount;
                Debug.assert(this._pendingConnectCount >= 0);
                if(this._destroyed && this._pendingConnectCount === 0)
                {
                    this.checkFinished();
                }
            },
            getConnection: function(endpoints, cb, compress)
            {
                if(this._destroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                //
                // Reap closed connections
                //
                var cons = this._monitor.swapReapedConnections();
                if(cons !== null)
                {
                    for(var i = 0; i < cons.length; ++i)
                    {
                        var c = cons[i];
                        this._connectionsByEndpoint.removeConnection(c.endpoint(), c);
                        this._connectionsByEndpoint.removeConnection(c.endpoint().changeCompress(true), c);
                    }
                }
        
                //
                // Try to get the connection.
                //
                while(true)
                {
                    if(this._destroyed)
                    {
                        throw new Ice.CommunicatorDestroyedException();
                    }
        
                    //
                    // Search for a matching connection. If we find one, we're done.
                    //
                    var connection = this.findConnectionByEndpoint(endpoints, compress);
                    if(connection !== null)
                    {
                        return connection;
                    }
        
                    if(this.addToPending(cb, endpoints))
                    {
                        //
                        // A connection is already pending.
                        //
                        return null;
                    }
                    else
                    {
                        //
                        // No connection is currently pending to one of our endpoints, so we
                        // get out of this loop and start the connection establishment to one of the
                        // given endpoints.
                        //
                        break;
                    }
                }
        
                //
                // At this point, we're responsible for establishing the connection to one of
                // the given endpoints. If it's a non-blocking connect, calling nextEndpoint
                // will start the connection establishment. Otherwise, we return null to get
                // the caller to establish the connection.
                //
                cb.nextEndpoint();
        
                return null;
            },
            createConnection: function(transceiver, endpoint)
            {
                Debug.assert(this._pending.has(endpoint) && transceiver !== null);
        
                //
                // Create and add the connection to the connection map. Adding the connection to the map
                // is necessary to support the interruption of the connection initialization and validation
                // in case the communicator is destroyed.
                //
                var connection = null;
                try
                {
                    if(this._destroyed)
                    {
                        throw new Ice.CommunicatorDestroyedException();
                    }
        
                    connection = new ConnectionI(this._communicator, this._instance, this._monitor, transceiver,
                                                endpoint.changeCompress(false), false, null);
                }
                catch(ex)
                {
                    if(ex instanceof Ice.LocalException)
                    {
                        try
                        {
                            transceiver.close();
                        }
                        catch(exc)
                        {
                            // Ignore
                        }
                    }
                    throw ex;
                }
        
                this._connectionsByEndpoint.set(connection.endpoint(), connection);
                this._connectionsByEndpoint.set(connection.endpoint().changeCompress(true), connection);
                return connection;
            },
            finishGetConnection: function(endpoints, endpoint, connection, cb)
            {
                // cb is-a ConnectCallback
        
                var connectionCallbacks = [];
                if(cb !== null)
                {
                    connectionCallbacks.push(cb);
                }
        
                var i;
                var cc;
                var callbacks = [];
                for(i = 0; i < endpoints.length; ++i)
                {
                    var endpt = endpoints[i];
                    var cbs = this._pending.get(endpt);
                    if(cbs !== undefined)
                    {
                        this._pending.del(endpt);
                        for(var j = 0; j < cbs.length; ++j)
                        {
                            cc = cbs[j];
                            if(cc.hasEndpoint(endpoint))
                            {
                                if(connectionCallbacks.indexOf(cc) === -1)
                                {
                                    connectionCallbacks.push(cc);
                                }
                            }
                            else
                            {
                                if(callbacks.indexOf(cc) === -1)
                                {
                                    callbacks.push(cc);
                                }
                            }
                        }
                    }
                }
        
                for(i = 0; i < connectionCallbacks.length; ++i)
                {
                    cc = connectionCallbacks[i];
                    cc.removeFromPending();
                    var idx = callbacks.indexOf(cc);
                    if(idx !== -1)
                    {
                        callbacks.splice(idx, 1);
                    }
                }
                for(i = 0; i < callbacks.length; ++i)
                {
                    cc = callbacks[i];
                    cc.removeFromPending();
                }
        
                var compress;
                var defaultsAndOverrides = this._instance.defaultsAndOverrides();
                if(defaultsAndOverrides.overrideCompress)
                {
                    compress = defaultsAndOverrides.overrideCompressValue;
                }
                else
                {
                    compress = endpoint.compress();
                }
        
                for(i = 0; i < callbacks.length; ++i)
                {
                    cc = callbacks[i];
                    cc.getConnection();
                }
                for(i = 0; i < connectionCallbacks.length; ++i)
                {
                    cc = connectionCallbacks[i];
                    cc.setConnection(connection, compress);
                }
        
                this.checkFinished();
            },
            finishGetConnectionEx: function(endpoints, ex, cb)
            {
                // cb is-a ConnectCallback
        
                var failedCallbacks = [];
                if(cb !== null)
                {
                    failedCallbacks.push(cb);
                }
                var i;
                var cc;
                var callbacks = [];
                for(i = 0; i < endpoints.length; ++i)
                {
                    var endpt = endpoints[i];
                    var cbs = this._pending.get(endpt);
                    if(cbs !== undefined)
                    {
                        this._pending.del(endpt);
                        for(var j = 0; j < cbs.length; ++j)
                        {
                            cc = cbs[j];
                            if(cc.removeEndpoints(endpoints))
                            {
                                if(failedCallbacks.indexOf(cc) === -1)
                                {
                                    failedCallbacks.push(cc);
                                }
                            }
                            else
                            {
                                if(callbacks.indexOf(cc) === -1)
                                {
                                    callbacks.push(cc);
                                }
                            }
                        }
                    }
                }
        
                for(i = 0; i < callbacks.length; ++i)
                {
                    cc = callbacks[i];
                    Debug.assert(failedCallbacks.indexOf(cc) === -1);
                    cc.removeFromPending();
                }
                this.checkFinished();
        
                for(i = 0; i < callbacks.length; ++i)
                {
                    cc = callbacks[i];
                    cc.getConnection();
                }
                for(i = 0; i < failedCallbacks.length; ++i)
                {
                    cc = failedCallbacks[i];
                    cc.setException(ex);
                }
            },
            addToPending: function(cb, endpoints)
            {
                // cb is-a ConnectCallback
        
                //
                // Add the callback to each pending list.
                //
                var found = false;
                var p;
                var i;
                if(cb !== null)
                {
                    for(i = 0; i < endpoints.length; ++i)
                    {
                        p = endpoints[i];
                        var cbs = this._pending.get(p);
                        if(cbs !== undefined)
                        {
                            found = true;
                            if(cbs.indexOf(cb) === -1)
                            {
                                cbs.push(cb); // Add the callback to each pending endpoint.
                            }
                        }
                    }
                }
        
                if(found)
                {
                    return true;
                }
        
                //
                // If there's no pending connection for the given endpoints, we're
                // responsible for its establishment. We add empty pending lists,
                // other callbacks to the same endpoints will be queued.
                //
                for(i = 0; i < endpoints.length; ++i)
                {
                    p = endpoints[i];
                    if(!this._pending.has(p))
                    {
                        this._pending.set(p, []);
                    }
                }
        
                return false;
            },
            removeFromPending: function(cb, endpoints)
            {
                // cb is-a ConnectCallback
        
                for(var i = 0; i < endpoints.length; ++i)
                {
                    var p = endpoints[i];
                    var cbs = this._pending.get(p);
                    if(cbs !== undefined)
                    {
                        var idx = cbs.indexOf(cb);
                        if(idx !== -1)
                        {
                            cbs.splice(idx, 1);
                        }
                    }
                }
            },
            handleConnectionException: function(ex, hasMore)
            {
                var traceLevels = this._instance.traceLevels();
                if(traceLevels.retry >= 2)
                {
                    var s = [];
                    s.push("connection to endpoint failed");
                    if(ex instanceof Ice.CommunicatorDestroyedException)
                    {
                        s.push("\n");
                    }
                    else
                    {
                        if(hasMore)
                        {
                            s.push(", trying next endpoint\n");
                        }
                        else
                        {
                            s.push(" and no more endpoints to try\n");
                        }
                    }
                    s.push(ex.toString());
                    this._instance.initializationData().logger.trace(traceLevels.retryCat, s.join(""));
                }
            },
            handleException: function(ex, hasMore)
            {
                var traceLevels = this._instance.traceLevels();
                if(traceLevels.retry >= 2)
                {
                    var s = [];
                    s.push("couldn't resolve endpoint host");
                    if(ex instanceof Ice.CommunicatorDestroyedException)
                    {
                        s.push("\n");
                    }
                    else
                    {
                        if(hasMore)
                        {
                            s.push(", trying next endpoint\n");
                        }
                        else
                        {
                            s.push(" and no more endpoints to try\n");
                        }
                    }
                    s.push(ex.toString());
                    this._instance.initializationData().logger.trace(traceLevels.retryCat, s.join(""));
                }
            },
            checkFinished: function()
            {
                //
                // Can't continue until the factory is destroyed and there are no pending connections.
                //
                if(!this._waitPromise || !this._destroyed || this._pending.size > 0 || this._pendingConnectCount > 0)
                {
                    return;
                }
        
                var self = this;
                Promise.all(
                    self._connectionsByEndpoint.map(
                        function(connection)
                        {
                            return connection.waitUntilFinished().exception(function(ex)
                                                                            {
                                                                                Debug.assert(false);
                                                                            });
                        }
                    )
                ).then(
                    function()
                    {
                        var cons = self._monitor.swapReapedConnections();
                        if(cons !== null)
                        {
                            var arr = [];
                            for(var e = self._connectionsByEndpoint.entries; e !== null; e = e.next)
                            {
                                var connectionList = e.value;
                                for(var i = 0; i < connectionList.length; ++i)
                                {
                                    if(arr.indexOf(connectionList[i]) === -1)
                                    {
                                        arr.push(connectionList[i]);
                                    }
                                }
                            }
                            Debug.assert(cons.length === arr.length);
                            self._connectionsByEndpoint.clear();
                        }
                        else
                        {
                            Debug.assert(self._connectionsByEndpoint.size === 0);
                        }
        
                        Debug.assert(self._waitPromise !== null);
                        self._waitPromise.succeed();
                        self._monitor.destroy();
                    }
                );
            }
        });
        
        Ice.OutgoingConnectionFactory = OutgoingConnectionFactory;
        
        //
        // Value is a Vector<Ice.ConnectionI>
        //
        var ConnectionListMap = Class(HashMap, {
            __init__: function(h)
            {
                HashMap.call(this, h || HashMap.compareEquals);
            },
            set: function(key, value)
            {
                var list = this.get(key);
                if(list === undefined)
                {
                    list = [];
                    HashMap.prototype.set.call(this, key, list);
                }
                Debug.assert(value instanceof ConnectionI);
                list.push(value);
                return undefined;
            },
            removeConnection: function(key, conn)
            {
                var list = this.get(key);
                Debug.assert(list !== null);
                var idx = list.indexOf(conn);
                Debug.assert(idx !== -1);
                list.splice(idx, 1);
                if(list.length === 0)
                {
                    this.del(key);
                }
            },
            map: function(fn)
            {
                var arr = [];
                this.forEach(function(c) { arr.push(fn(c)); });
                return arr;
            },
            forEach: function(fn)
            {
                for(var e = this._head; e !== null; e = e._next)
                {
                    for(var i = 0; i < e.value.length; ++i)
                    {
                        fn(e.value[i]);
                    }
                }
            }
        });
        
        var ConnectCallback = Class({
            __init__: function(f, endpoints, more, selType)
            {
                this._factory = f;
                this._endpoints = endpoints;
                this._hasMore = more;
                this._selType = selType;
                this._promise = new Promise();
                this._index = 0;
                this._current = null;
            },
            //
            // Methods from ConnectionI_StartCallback
            //
            connectionStartCompleted: function(connection)
            {
                connection.activate();
                this._factory.finishGetConnection(this._endpoints, this._current, connection, this);
            },
            connectionStartFailed: function(connection, ex)
            {
                Debug.assert(this._current !== null);
        
                if(ex instanceof Ice.LocalException)
                {
                    this._factory.handleConnectionException(ex, this._hasMore || this._index < this._endpoints.length);
                    if(ex instanceof Ice.CommunicatorDestroyedException) // No need to continue.
                    {
                        this._factory.finishGetConnectionEx(this._endpoints, ex, this);
                    }
                    else if(this._index < this._endpoints.length) // Try the next endpoint.
                    {
                        this.nextEndpoint();
                    }
                    else
                    {
                        this._factory.finishGetConnectionEx(this._endpoints, ex, this);
                    }
                }
                else
                {
                    this._factory.finishGetConnectionEx(this._endpoints, ex, this);
                }
            },
            setConnection: function(connection, compress)
            {
                //
                // Callback from the factory: the connection to one of the callback
                // connectors has been established.
                //
                this._promise.succeed(connection, compress);
                this._factory.decPendingConnectCount(); // Must be called last.
            },
            setException: function(ex)
            {
                //
                // Callback from the factory: connection establishment failed.
                //
                this._promise.fail(ex);
                this._factory.decPendingConnectCount(); // Must be called last.
            },
            hasEndpoint: function(endpt)
            {
                return this.findEndpoint(endpt) !== -1;
            },
            findEndpoint: function(endpt)
            {
                for(var index = 0; index < this._endpoints.length; ++index)
                {
                    if(endpt.equals(this._endpoints[index]))
                    {
                        return index;
                    }
                }
                return -1;
            },
            removeEndpoints: function(endpoints)
            {
                for(var i = 0; i < endpoints.length; ++i)
                {
                    var idx = this.findEndpoint(endpoints[i]);
                    if(idx !== -1)
                    {
                        this._endpoints.splice(idx, 1);
                    }
                }
                this._index = 0;
                return this._endpoints.length === 0;
            },
            removeFromPending: function()
            {
                this._factory.removeFromPending(this, this._endpoints);
            },
            start: function()
            {
                try
                {
                    //
                    // Notify the factory that there's an async connect pending. This is necessary
                    // to prevent the outgoing connection factory to be destroyed before all the
                    // pending asynchronous connects are finished.
                    //
                    this._factory.incPendingConnectCount();
                }
                catch(ex)
                {
                    this._promise.fail(ex);
                    return;
                }
        
                this.getConnection();
                return this._promise;
            },
            getConnection: function()
            {
                try
                {
                    //
                    // Ask the factory to get a connection.
                    //
                    var compress = { value: false };
                    var connection = this._factory.getConnection(this._endpoints, this, compress);
                    if(connection === null)
                    {
                        //
                        // A null return value from getConnection indicates that the connection
                        // is being established and that everthing has been done to ensure that
                        // the callback will be notified when the connection establishment is
                        // done.
                        //
                        return;
                    }
        
                    this._promise.succeed(connection, compress.value);
                    this._factory.decPendingConnectCount(); // Must be called last.
                }
                catch(ex)
                {
                    this._promise.fail(ex);
                    this._factory.decPendingConnectCount(); // Must be called last.
                }
            },
            nextEndpoint: function()
            {
                var connection = null;
                var traceLevels = this._factory._instance.traceLevels();
                try
                {
                    Debug.assert(this._index < this._endpoints.length);
                    this._current = this._endpoints[this._index++];
        
                    if(traceLevels.network >= 2)
                    {
                        var s = [];
                        s.push("trying to establish ");
                        s.push(this._current.protocol());
                        s.push(" connection to ");
                        s.push(this._current.toConnectorString());
                        this._factory._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(""));
                    }
        
                    connection = this._factory.createConnection(this._current.connect(), this._current);
                    var self = this;
                    connection.start().then(
                        function()
                        {
                            self.connectionStartCompleted(connection);
                        },
                        function(ex)
                        {
                            self.connectionStartFailed(connection, ex);
                        });
                }
                catch(ex)
                {
                    if(traceLevels.network >= 2)
                    {
                        var s = [];
                        s.push("failed to establish ");
                        s.push(this._current.protocol());
                        s.push(" connection to ");
                        s.push(this._current.toString());
                        s.push("\n");
                        s.push(ex.toString());
                        this._factory._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(""));
                    }
        
                    this.connectionStartFailed(connection, ex);
                }
            }
        });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Debug = Ice.Debug;
        var HashMap = Ice.HashMap;
        var Promise = Ice.Promise;
        var Protocol = Ice.Protocol;
        var LocatorRegistryPrx = Ice.LocatorRegisterPrx;
        
        var  Class = Ice.Class;
        
        var LocatorInfo = Class({
            __init__: function(locator, table, background)
            {
                this._locator = locator;
                this._locatorRegistry = null;
                this._table = table;
                this._background = background;
        
                this._adapterRequests = new HashMap(); // Map<String, Request>
                this._objectRequests = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, Request>
            },
            destroy: function()
            {
                this._locatorRegistry = null;
                this._table.clear();
            },
            equals: function(rhs)
            {
                if(this === rhs)
                {
                    return true;
                }
        
                if(rhs instanceof LocatorInfo)
                {
                    return this._locator.equals(rhs._locator);
                }
        
                return false;
            },
            hashCode: function()
            {
                return this._locator.hashCode();
            },
            getLocator: function()
            {
                return this._locator;
            },
            getLocatorRegistry: function()
            {
                if(this._locatorRegistry !== null)
                {
                    return new Promise().succeed(this._locatorRegistry);
                }
        
                var self = this;
                return this._locator.getRegistry().then(
                    function(reg)
                    {
                        //
                        // The locator registry can't be located. We use ordered
                        // endpoint selection in case the locator returned a proxy
                        // with some endpoints which are prefered to be tried first.
                        //
                        self._locatorRegistry = LocatorRegistryPrx.uncheckedCast(reg.ice_locator(null).ice_endpointSelection(
                            Ice.EndpointSelectionType.Ordered));
                        return self._locatorRegistry;
                    });
            },
            getEndpoints: function(ref, wellKnownRef, ttl, p)
            {
                var promise = p || new Promise(); // success callback receives (endpoints, cached)
        
                Debug.assert(ref.isIndirect());
                var endpoints = null;
                var cached = { value: false };
                if(!ref.isWellKnown())
                {
                    endpoints = this._table.getAdapterEndpoints(ref.getAdapterId(), ttl, cached);
                    if(!cached.value)
                    {
                        if(this._background && endpoints !== null)
                        {
                            this.getAdapterRequest(ref).addCallback(ref, wellKnownRef, ttl, null);
                        }
                        else
                        {
                            this.getAdapterRequest(ref).addCallback(ref, wellKnownRef, ttl, promise);
                            return promise;
                        }
                    }
                }
                else
                {
                    var r = this._table.getObjectReference(ref.getIdentity(), ttl, cached);
                    if(!cached.value)
                    {
                        if(this._background && r !== null)
                        {
                            this.getObjectRequest(ref).addCallback(ref, null, ttl, null);
                        }
                        else
                        {
                            this.getObjectRequest(ref).addCallback(ref, null, ttl, promise);
                            return promise;
                        }
                    }
        
                    if(!r.isIndirect())
                    {
                        endpoints = r.getEndpoints();
                    }
                    else if(!r.isWellKnown())
                    {
                        this.getEndpoints(r, ref, ttl, promise);
                        return promise;
                    }
                }
        
                Debug.assert(endpoints !== null);
                if(ref.getInstance().traceLevels().location >= 1)
                {
                    this.getEndpointsTrace(ref, endpoints, true);
                }
                promise.succeed(endpoints, true);
        
                return promise;
            },
            clearCache: function(ref)
            {
                Debug.assert(ref.isIndirect());
        
                if(!ref.isWellKnown())
                {
                    var endpoints = this._table.removeAdapterEndpoints(ref.getAdapterId());
        
                    if(endpoints !== null && ref.getInstance().traceLevels().location >= 2)
                    {
                        this.trace("removed endpoints from locator table\n", ref, endpoints);
                    }
                }
                else
                {
                    var r =  this._table.removeObjectReference(ref.getIdentity());
                    if(r !== null)
                    {
                        if(!r.isIndirect())
                        {
                            if(ref.getInstance().traceLevels().location >= 2)
                            {
                                this.trace("removed endpoints from locator table", ref, r.getEndpoints());
                            }
                        }
                        else if(!r.isWellKnown())
                        {
                            this.clearCache(r);
                        }
                    }
                }
            },
            trace: function(msg, ref, endpoints)
            {
                Debug.assert(ref.isIndirect());
        
                var s = [];
                s.push(msg);
                s.push("\n");
                if(!ref.isWellKnown())
                {
                    s.push("adapter = ");
                    s.push(ref.getAdapterId());
                    s.push("\n");
                }
                else
                {
                    s.push("object = ");
                    s.push(ref.getInstance().identityToString(ref.getIdentity()));
                    s.push("\n");
                }
        
                s.push("endpoints = ");
                for(var i = 0; i < endpoints.length; i++)
                {
                    s.push(endpoints[i].toString());
                    if(i + 1 < endpoints.length)
                    {
                        s.push(":");
                    }
                }
        
                ref.getInstance().initializationData().logger.trace(ref.getInstance().traceLevels().locationCat, s.join(""));
            },
            getEndpointsException: function(ref, exc)
            {
                Debug.assert(ref.isIndirect());
        
                var instance = ref.getInstance();
                var s, e;
                try
                {
                    throw exc;
                }
                catch(ex)
                {
                    if(ex instanceof Ice.AdapterNotFoundException)
                    {
                        if(instance.traceLevels().location >= 1)
                        {
                            s = [];
                            s.push("adapter not found\n");
                            s.push("adapter = ");
                            s.push(ref.getAdapterId());
                            instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(""));
                        }
        
                        e = new Ice.NotRegisteredException();
                        e.kindOfObject = "object adapter";
                        e.id = ref.getAdapterId();
                        throw e;
                    }
                    else if(ex instanceof Ice.ObjectNotFoundException)
                    {
                        if(instance.traceLevels().location >= 1)
                        {
                            s = [];
                            s.push("object not found\n");
                            s.push("object = ");
                            s.push(instance.identityToString(ref.getIdentity()));
                            instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(""));
                        }
        
                        e = new Ice.NotRegisteredException();
                        e.kindOfObject = "object";
                        e.id = instance.identityToString(ref.getIdentity());
                        throw e;
                    }
                    else if(ex instanceof Ice.NotRegisteredException)
                    {
                        throw ex;
                    }
                    else if(ex instanceof Ice.LocalException)
                    {
                        if(instance.traceLevels().location >= 1)
                        {
                            s = [];
                            s.push("couldn't contact the locator to retrieve adapter endpoints\n");
                            if(ref.getAdapterId().length > 0)
                            {
                                s.push("adapter = ");
                                s.push(ref.getAdapterId());
                                s.push("\n");
                            }
                            else
                            {
                                s.push("object = ");
                                s.push(instance.identityToString(ref.getIdentity()));
                                s.push("\n");
                            }
                            s.push("reason = " + ex.toString());
                            instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(""));
                        }
                        throw ex;
                    }
                    else
                    {
                        Debug.assert(false);
                    }
                }
            },
            getEndpointsTrace: function(ref, endpoints, cached)
            {
                if(endpoints !== null && endpoints.length > 0)
                {
                    if(cached)
                    {
                        this.trace("found endpoints in locator table", ref, endpoints);
                    }
                    else
                    {
                        this.trace("retrieved endpoints from locator, adding to locator table", ref, endpoints);
                    }
                }
                else
                {
                    var instance = ref.getInstance();
                    var s = [];
                    s.push("no endpoints configured for ");
                    if(ref.getAdapterId().length > 0)
                    {
                        s.push("adapter\n");
                        s.push("adapter = ");
                        s.push(ref.getAdapterId());
                        s.push("\n");
                    }
                    else
                    {
                        s.push("object\n");
                        s.push("object = ");
                        s.push(instance.identityToString(ref.getIdentity()));
                        s.push("\n");
                    }
                    instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(""));
                }
            },
            getAdapterRequest: function(ref)
            {
                if(ref.getInstance().traceLevels().location >= 1)
                {
                    var instance = ref.getInstance();
                    var s = [];
                    s.push("searching for adapter by id\n");
                    s.push("adapter = ");
                    s.push(ref.getAdapterId());
                    instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(""));
                }
        
                var request = this._adapterRequests.get(ref.getAdapterId());
                if(request !== undefined)
                {
                    return request;
                }
                request = new AdapterRequest(this, ref);
                this._adapterRequests.set(ref.getAdapterId(), request);
                return request;
            },
            getObjectRequest: function(ref)
            {
                if(ref.getInstance().traceLevels().location >= 1)
                {
                    var instance = ref.getInstance();
                    var s = [];
                    s.push("searching for object by id\n");
                    s.push("object = ");
                    s.push(instance.identityToString(ref.getIdentity()));
                    instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(""));
                }
        
                var request = this._objectRequests.get(ref.getIdentity());
                if(request !== undefined)
                {
                    return request;
                }
                request = new ObjectRequest(this, ref);
                this._objectRequests.set(ref.getIdentity(), request);
                return request;
            },
            finishRequest: function(ref, wellKnownRefs, proxy, notRegistered)
            {
                if(proxy === null || proxy.__reference().isIndirect())
                {
                    //
                    // Remove the cached references of well-known objects for which we tried
                    // to resolved the endpoints if these endpoints are empty.
                    //
                    for(var i = 0; i < wellKnownRefs.length; ++i)
                    {
                        this._table.removeObjectReference(wellKnownRefs[i].getIdentity());
                    }
                }
        
                if(!ref.isWellKnown())
                {
                    if(proxy !== null && !proxy.__reference().isIndirect())
                    {
                        // Cache the adapter endpoints.
                        this._table.addAdapterEndpoints(ref.getAdapterId(), proxy.__reference().getEndpoints());
                    }
                    else if(notRegistered) // If the adapter isn't registered anymore, remove it from the cache.
                    {
                        this._table.removeAdapterEndpoints(ref.getAdapterId());
                    }
        
                    Debug.assert(this._adapterRequests.has(ref.getAdapterId()));
                    this._adapterRequests.del(ref.getAdapterId());
                }
                else
                {
                    if(proxy !== null && !proxy.__reference().isWellKnown())
                    {
                        // Cache the well-known object reference.
                        this._table.addObjectReference(ref.getIdentity(), proxy.__reference());
                    }
                    else if(notRegistered) // If the well-known object isn't registered anymore, remove it from the cache.
                    {
                        this._table.removeObjectReference(ref.getIdentity());
                    }
        
                    Debug.assert(this._objectRequests.has(ref.getIdentity()));
                    this._objectRequests.del(ref.getIdentity());
                }
            }
        });
        
        Ice.LocatorInfo = LocatorInfo;
        
        var RequestCallback = Class({
            __init__: function(ref, ttl, promise)
            {
                this._ref = ref;
                this._ttl = ttl;
                this._promise = promise;
            },
            response: function(locatorInfo, proxy)
            {
                var endpoints = null;
                if(proxy !== null)
                {
                    var r = proxy.__reference();
                    if(this._ref.isWellKnown() && !Protocol.isSupported(this._ref.getEncoding(), r.getEncoding()))
                    {
                        //
                        // If a well-known proxy and the returned proxy
                        // encoding isn't supported, we're done: there's
                        // no compatible endpoint we can use.
                        //
                    }
                    else if(!r.isIndirect())
                    {
                        endpoints = r.getEndpoints();
                    }
                    else if(this._ref.isWellKnown() && !r.isWellKnown())
                    {
                        //
                        // We're resolving the endpoints of a well-known object and the proxy returned
                        // by the locator is an indirect proxy. We now need to resolve the endpoints
                        // of this indirect proxy.
                        //
                        var self = this;
                        locatorInfo.getEndpoints(r, this._ref, this._ttl).then(
                            function(endpts, b)
                            {
                                if(self._promise !== null)
                                {
                                    self._promise.succeed(endpts, b);
                                }
                            },
                            function(ex)
                            {
                                if(self._promise !== null)
                                {
                                    self._promise.fail(ex);
                                }
                            });
                        return;
                    }
                }
        
                if(this._ref.getInstance().traceLevels().location >= 1)
                {
                    locatorInfo.getEndpointsTrace(this._ref, endpoints, false);
                }
        
                if(this._promise !== null)
                {
                    this._promise.succeed(endpoints === null ? [] : endpoints, false);
                }
            },
            exception: function(locatorInfo, exc)
            {
                try
                {
                    locatorInfo.getEndpointsException(this._ref, exc); // This throws.
                }
                catch(ex)
                {
                    if(this._promise !== null)
                    {
                        this._promise.fail(ex);
                    }
                }
            }
        });
        
        var Request = Class({
            __init__: function(locatorInfo, ref)
            {
                this._locatorInfo = locatorInfo;
                this._ref = ref;
        
                this._callbacks = []; // Array<RequestCallback>
                this._wellKnownRefs = []; // Array<Reference>
                this._sent = false;
                this._response = false;
                this._proxy = null;
                this._exception = null;
            },
            addCallback: function(ref, wellKnownRef, ttl, promise)
            {
                var callback = new RequestCallback(ref, ttl, promise);
                if(this._response)
                {
                    callback.response(this._locatorInfo, this._proxy);
                }
                else if(this._exception !== null)
                {
                    callback.exception(this._locatorInfo, this._exception);
                }
                else
                {
                    this._callbacks.push(callback);
                    if(wellKnownRef !== null) // This request is to resolve the endpoints of a cached well-known object ref
                    {
                        this._wellKnownRefs.push(wellKnownRef);
                    }
                    if(!this._sent)
                    {
                        this._sent = true;
                        this.send();
                    }
                }
            },
            response: function(proxy)
            {
                this._locatorInfo.finishRequest(this._ref, this._wellKnownRefs, proxy, false);
                this._response = true;
                this._proxy = proxy;
                for(var i = 0; i < this._callbacks.length; ++i)
                {
                    this._callbacks[i].response(this._locatorInfo, proxy);
                }
            },
            exception: function(ex)
            {
                this._locatorInfo.finishRequest(this._ref, this._wellKnownRefs, null, ex instanceof Ice.UserException);
                this._exception = ex;
                for(var i = 0; i < this._callbacks.length; ++i)
                {
                    this._callbacks[i].exception(this._locatorInfo, ex);
                }
            }
        });
        
        var ObjectRequest = Class(Request, {
            __init__: function(locatorInfo, reference)
            {
                Request.call(this, locatorInfo, reference);
                Debug.assert(reference.isWellKnown());
            },
            send: function()
            {
                try
                {
                    var self = this;
                    this._locatorInfo.getLocator().findObjectById(this._ref.getIdentity()).then(
                        function(proxy)
                        {
                            self.response(proxy);
                        },
                        function(ex)
                        {
                            self.exception(ex);
                        });
                }
                catch(ex)
                {
                    this.exception(ex);
                }
            }
        });
        
        var AdapterRequest = Class(Request, {
            __init__: function(locatorInfo, reference)
            {
                Request.call(this, locatorInfo, reference);
                Debug.assert(reference.isIndirect());
            },
            send: function()
            {
                try
                {
                    var self = this;
                    this._locatorInfo.getLocator().findAdapterById(this._ref.getAdapterId()).then(
                        function(proxy)
                        {
                            self.response(proxy);
                        },
                        function(ex)
                        {
                            self.exception(ex);
                        });
                }
                catch(ex)
                {
                    this.exception(ex);
                }
            }
        });
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var AsyncResultBase = Ice.AsyncResultBase;
        var Debug = Ice.Debug;
        var Identity = Ice.Identity;
        var Promise = Ice.Promise;
        var PropertyNames = Ice.PropertyNames;
        var ServantManager = Ice.ServantManager;
        var StringUtil = Ice.StringUtil;
        
        var _suffixes =
        [
            "ACM",
            "AdapterId",
            "Endpoints",
            "Locator",
            "Locator.EncodingVersion",
            "Locator.EndpointSelection",
            "Locator.ConnectionCached",
            "Locator.PreferSecure",
            "Locator.CollocationOptimized",
            "Locator.Router",
            "MessageSizeMax",
            "PublishedEndpoints",
            "ReplicaGroupId",
            "Router",
            "Router.EncodingVersion",
            "Router.EndpointSelection",
            "Router.ConnectionCached",
            "Router.PreferSecure",
            "Router.CollocationOptimized",
            "Router.Locator",
            "Router.Locator.EndpointSelection",
            "Router.Locator.ConnectionCached",
            "Router.Locator.PreferSecure",
            "Router.Locator.CollocationOptimized",
            "Router.Locator.LocatorCacheTimeout",
            "Router.Locator.InvocationTimeout",
            "Router.LocatorCacheTimeout",
            "Router.InvocationTimeout",
            "ProxyOptions",
            "ThreadPool.Size",
            "ThreadPool.SizeMax",
            "ThreadPool.SizeWarn",
            "ThreadPool.StackSize",
            "ThreadPool.Serialize"
        ];
        
        var StateUninitialized = 0; // Just constructed.
        //var StateHeld = 1;
        //var StateWaitActivate = 2;
        //var StateActive = 3;
        //var StateDeactivating = 4;
        var StateDeactivated = 5;
        var StateDestroyed  = 6;
        
        //
        // Only for use by IceInternal.ObjectAdapterFactory
        //
        var ObjectAdapterI = Ice.Class({
            __init__: function(instance, communicator, objectAdapterFactory, name, router, noConfig, promise)
            {
                this._instance = instance;
                this._communicator = communicator;
                this._objectAdapterFactory = objectAdapterFactory;
                this._servantManager = new ServantManager(instance, name);
                this._name = name;
                this._routerEndpoints = [];
                this._routerInfo = null;
                this._state = StateUninitialized;
                this._noConfig = noConfig;
        
                if(this._noConfig)
                {
                    this._reference = this._instance.referenceFactory().createFromString("dummy -t", "");
                    this._messageSizeMax = this._instance.messageSizeMax();
                    promise.succeed(this, promise);
                    return;
                }
        
                var properties = this._instance.initializationData().properties;
                var unknownProps = [];
                var noProps = this.filterProperties(unknownProps);
        
                //
                // Warn about unknown object adapter properties.
                //
                if(unknownProps.length !== 0 && properties.getPropertyAsIntWithDefault("Ice.Warn.UnknownProperties", 1) > 0)
                {
                    var message = ["found unknown properties for object adapter `" + name + "':"];
                    for(var i = 0; i < unknownProps.length; ++i)
                    {
                        message.push("\n    " + unknownProps[i]);
                    }
                    this._instance.initializationData().logger.warning(message.join(""));
                }
        
                //
                // Make sure named adapter has some configuration.
                //
                if(router === null && noProps)
                {
                    var ex = new Ice.InitializationException();
                    ex.reason = "object adapter `" + this._name + "' requires configuration";
                    throw ex;
                }
        
                //
                // Setup a reference to be used to get the default proxy options
                // when creating new proxies. By default, create twoway proxies.
                //
                var proxyOptions = properties.getPropertyWithDefault(this._name + ".ProxyOptions", "-t");
                try
                {
                    this._reference = this._instance.referenceFactory().createFromString("dummy " + proxyOptions, "");
                }
                catch(e)
                {
                    if(e instanceof Ice.ProxyParseException)
                    {
                        var ex = new Ice.InitializationException();
                        ex.reason = "invalid proxy options `" + proxyOptions + "' for object adapter `" + name + "'";
                        throw ex;
                    }
                    else
                    {
                        throw e;
                    }
                }
        
                {
                    var defaultMessageSizeMax = this._instance.messageSizeMax() / 1024;
                    var num = properties.getPropertyAsIntWithDefault(this._name + ".MessageSizeMax", defaultMessageSizeMax);
                    if(num < 1 || num > 0x7fffffff / 1024)
                    {
                        this._messageSizeMax = 0x7fffffff;
                    }
                    else
                    {
                        this._messageSizeMax = num * 1024; // Property is in kilobytes, _messageSizeMax in bytes
                    }
                }
        
                try
                {
        
                    if(router === null)
                    {
                        router = Ice.RouterPrx.uncheckedCast(
                            this._instance.proxyFactory().propertyToProxy(this._name + ".Router"));
                    }
                    if(router !== null)
                    {
                        this._routerInfo = this._instance.routerManager().find(router);
                        Debug.assert(this._routerInfo !== null);
        
                        //
                        // Make sure this router is not already registered with another adapter.
                        //
                        if(this._routerInfo.getAdapter() !== null)
                        {
                            throw new Ice.AlreadyRegisteredException(
                                "object adapter with router",
                                this._instance.identityToString(router.ice_getIdentity()));
                        }
        
                        //
                        // Add the router's server proxy endpoints to this object
                        // adapter.
                        //
                        var self = this;
                        this._routerInfo.getServerEndpoints().then(
                            function(endpoints)
                            {
                                var i;
        
                                for(i = 0; i < endpoints.length; ++i)
                                {
                                    self._routerEndpoints.push(endpoints[i]);
                                }
                                self._routerEndpoints.sort(     // Must be sorted.
                                    function(e1, e2)
                                    {
                                        return e1.compareTo(e2);
                                    });
        
                                //
                                // Remove duplicate endpoints, so we have a list of unique
                                // endpoints.
                                //
                                for(i = 0; i < self._routerEndpoints.length - 1;)
                                {
                                    var e1 = self._routerEndpoints[i];
                                    var e2 = self._routerEndpoints[i + 1];
                                    if(e1.equals(e2))
                                    {
                                        self._routerEndpoints.splice(i, 1);
                                    }
                                    else
                                    {
                                        ++i;
                                    }
                                }
        
                                //
                                // Associate this object adapter with the router. This way,
                                // new outgoing connections to the router's client proxy will
                                // use this object adapter for callbacks.
                                //
                                self._routerInfo.setAdapter(self);
        
                                //
                                // Also modify all existing outgoing connections to the
                                // router's client proxy to use this object adapter for
                                // callbacks.
                                //
                                return self._instance.outgoingConnectionFactory().setRouterInfo(self._routerInfo);
                            }
                        ).then(
                            function()
                            {
                                promise.succeed(self, promise);
                            },
                            function(ex)
                            {
                                promise.fail(ex, promise);
                            });
                    }
                    else
                    {
                        var endpoints = properties.getProperty(this._name + ".Endpoints");
                        if(endpoints.length > 0)
                        {
                            throw new Ice.FeatureNotSupportedException("object adapter endpoints not supported");
                        }
                        promise.succeed(this, promise);
                    }
                }
                catch(ex)
                {
                    this.destroy();
                    throw ex;
                }
            },
            getName: function()
            {
                //
                // No mutex lock necessary, _name is immutable.
                //
                return this._noConfig ? "" : this._name;
            },
            getCommunicator: function()
            {
                return this._communicator;
            },
            activate: function()
            {
            },
            hold: function()
            {
                this.checkForDeactivation();
            },
            waitForHold: function()
            {
                var promise = new AsyncResultBase(this._communicator, "waitForHold", null, null, this);
                if(this.checkForDeactivation(promise))
                {
                    return promise;
                }
                return promise.succeed(promise);
            },
            deactivate: function()
            {
                var promise = new AsyncResultBase(this._communicator, "deactivate", null, null, this);
                if(this._state < StateDeactivated)
                {
                    this._state = StateDeactivated;
                    this._instance.outgoingConnectionFactory().removeAdapter(this);
                }
                return promise.succeed(promise);
            },
            waitForDeactivate: function()
            {
                var promise = new AsyncResultBase(this._communicator, "deactivate", null, null, this);
                return promise.succeed(promise);
            },
            isDeactivated: function()
            {
                return this._state >= StateDeactivated;
            },
            destroy: function()
            {
                var promise = new AsyncResultBase(this._communicator, "destroy", null, null, this);
                var self = this;
                var destroyInternal = function()
                {
                    if(self._state < StateDestroyed)
                    {
                        self._state = StateDestroyed;
                        self._servantManager.destroy();
                        self._objectAdapterFactory.removeObjectAdapter(self);
                    }
                    return promise.succeed(promise);
                };
        
                return this._state < StateDeactivated ? this.deactivate().then(destroyInternal) : destroyInternal();
            },
            add: function(object, ident)
            {
                return this.addFacet(object, ident, "");
            },
            addFacet: function(object, ident, facet)
            {
                this.checkForDeactivation();
                this.checkIdentity(ident);
                this.checkServant(object);
        
                //
                // Create a copy of the Identity argument, in case the caller
                // reuses it.
                //
                var id = ident.clone();
        
                this._servantManager.addServant(object, id, facet);
        
                return this.newProxy(id, facet);
            },
            addWithUUID: function(object)
            {
                return this.addFacetWithUUID(object, "");
            },
            addFacetWithUUID: function(object, facet)
            {
                return this.addFacet(object, new Identity(Ice.generateUUID(), ""), facet);
            },
            addDefaultServant: function(servant, category)
            {
                this.checkServant(servant);
                this.checkForDeactivation();
        
                this._servantManager.addDefaultServant(servant, category);
            },
            remove: function(ident)
            {
                return this.removeFacet(ident, "");
            },
            removeFacet: function(ident, facet)
            {
                this.checkForDeactivation();
                this.checkIdentity(ident);
        
                return this._servantManager.removeServant(ident, facet);
            },
            removeAllFacets: function(ident)
            {
                this.checkForDeactivation();
                this.checkIdentity(ident);
        
                return this._servantManager.removeAllFacets(ident);
            },
            removeDefaultServant: function(category)
            {
                this.checkForDeactivation();
        
                return this._servantManager.removeDefaultServant(category);
            },
            find: function(ident)
            {
                return this.findFacet(ident, "");
            },
            findFacet: function(ident, facet)
            {
                this.checkForDeactivation();
                this.checkIdentity(ident);
        
                return this._servantManager.findServant(ident, facet);
            },
            findAllFacets: function(ident)
            {
                this.checkForDeactivation();
                this.checkIdentity(ident);
        
                return this._servantManager.findAllFacets(ident);
            },
            findByProxy: function(proxy)
            {
                this.checkForDeactivation();
        
                var ref = proxy.__reference();
                return this.findFacet(ref.getIdentity(), ref.getFacet());
            },
            findDefaultServant: function(category)
            {
                this.checkForDeactivation();
        
                return this._servantManager.findDefaultServant(category);
            },
            addServantLocator: function(locator, prefix)
            {
                this.checkForDeactivation();
        
                this._servantManager.addServantLocator(locator, prefix);
            },
            removeServantLocator: function(prefix)
            {
                this.checkForDeactivation();
        
                return this._servantManager.removeServantLocator(prefix);
            },
            findServantLocator: function(prefix)
            {
                this.checkForDeactivation();
        
                return this._servantManager.findServantLocator(prefix);
            },
            createProxy: function(ident)
            {
                this.checkForDeactivation();
                this.checkIdentity(ident);
        
                return this.newProxy(ident, "");
            },
            createDirectProxy: function(ident)
            {
                return this.createProxy(ident);
            },
            createIndirectProxy: function(ident)
            {
                throw new Ice.FeatureNotSupportedException("setLocator not supported");
            },
            setLocator: function(locator)
            {
                throw new Ice.FeatureNotSupportedException("setLocator not supported");
            },
            refreshPublishedEndpoints: function()
            {
                throw new Ice.FeatureNotSupportedException("refreshPublishedEndpoints not supported");
            },
            getEndpoints: function()
            {
                return [];
            },
            getPublishedEndpoints: function()
            {
                return [];
            },
            getServantManager: function()
            {
                //
                // _servantManager is immutable.
                //
                return this._servantManager;
            },
            messageSizeMax: function()
            {
                return this._messageSizeMax;
            },
            newProxy: function(ident, facet)
            {
                var endpoints = [];
        
                //
                // Now we also add the endpoints of the router's server proxy, if
                // any. This way, object references created by this object adapter
                // will also point to the router's server proxy endpoints.
                //
                for(var i = 0; i < this._routerEndpoints.length; ++i)
                {
                    endpoints.push(this._routerEndpoints[i]);
                }
        
                //
                // Create a reference and return a proxy for this reference.
                //
                var ref = this._instance.referenceFactory().create(ident, facet, this._reference, endpoints);
                return this._instance.proxyFactory().referenceToProxy(ref);
            },
            checkForDeactivation: function(promise)
            {
                if(this._state >= StateDeactivated)
                {
                    var ex = new Ice.ObjectAdapterDeactivatedException();
                    ex.name = this.getName();
        
                    if(promise !== undefined)
                    {
                        promise.fail(ex, promise);
                        return true;
                    }
                    else
                    {
                        throw ex;
                    }
                }
        
                return false;
            },
            checkIdentity: function(ident)
            {
                if(ident.name === undefined || ident.name === null || ident.name.length === 0)
                {
                    throw new Ice.IllegalIdentityException(ident);
                }
        
                if(ident.category === undefined || ident.category === null)
                {
                    ident.category = "";
                }
            },
            checkServant: function(servant)
            {
                if(servant === undefined || servant === null)
                {
                    throw new Ice.IllegalServantException("cannot add null servant to Object Adapter");
                }
            },
            filterProperties: function(unknownProps)
            {
                //
                // Do not create unknown properties list if Ice prefix, i.e., Ice, Glacier2, etc.
                //
                var addUnknown = true, i;
                var prefix = this._name + ".";
                for(i = 0; i < PropertyNames.clPropNames.length; ++i)
                {
                    if(prefix.indexOf(PropertyNames.clPropNames[i] + ".") === 0)
                    {
                        addUnknown = false;
                        break;
                    }
                }
        
                var noProps = true;
                var props = this._instance.initializationData().properties.getPropertiesForPrefix(prefix);
                for(var e = props.entries; e !== null; e = e.next)
                {
                    var valid = false;
                    for(i = 0; i < _suffixes.length; ++i)
                    {
                        if(e.key === prefix + _suffixes[i])
                        {
                            noProps = false;
                            valid = true;
                            break;
                        }
                    }
        
                    if(!valid && addUnknown)
                    {
                        unknownProps.push(e.key);
                    }
                }
        
                return noProps;
            }
        });
        
        Ice.ObjectAdapterI = ObjectAdapterI;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var HashMap = Ice.HashMap;
        var LocatorInfo = Ice.LocatorInfo;
        var LocatorTable = Ice.LocatorTable;
        var LocatorPrx = Ice.LocatorPrx;
        
        var LocatorManager = Ice.Class({
            __init__: function(properties)
            {
                this._background = properties.getPropertyAsInt("Ice.BackgroundLocatorCacheUpdates") > 0;
        
                this._table = new HashMap(HashMap.compareEquals); // Map<Ice.LocatorPrx, LocatorInfo>
                this._locatorTables = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, LocatorTable>
            },
            destroy: function()
            {
                for(var e = this._table.entries; e !== null; e = e.next)
                {
                    e.value.destroy();
                }
                this._table.clear();
                this._locatorTables.clear();
            },
            //
            // Returns locator info for a given locator. Automatically creates
            // the locator info if it doesn't exist yet.
            //
            find: function(loc)
            {
                if(loc === null)
                {
                    return null;
                }
        
                //
                // The locator can't be located.
                //
                var locator = LocatorPrx.uncheckedCast(loc.ice_locator(null));
        
                //
                // TODO: reap unused locator info objects?
                //
        
                var info = this._table.get(locator);
                if(info === undefined)
                {
                    //
                    // Rely on locator identity for the adapter table. We want to
                    // have only one table per locator (not one per locator
                    // proxy).
                    //
                    var table = this._locatorTables.get(locator.ice_getIdentity());
                    if(table === undefined)
                    {
                        table = new LocatorTable();
                        this._locatorTables.set(locator.ice_getIdentity(), table);
                    }
        
                    info = new LocatorInfo(locator, table, this._background);
                    this._table.set(locator, info);
                }
        
                return info;
            }
        });
        
        Ice.LocatorManager = LocatorManager;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var AsyncResultBase = Ice.AsyncResultBase;
        var ObjectAdapterI = Ice.ObjectAdapterI;
        var Promise = Ice.Promise;
        
        //
        // Only for use by Instance.
        //
        var ObjectAdapterFactory = Ice.Class({
            __init__: function(instance, communicator)
            {
                this._instance = instance;
                this._communicator = communicator;
                this._adapters = [];
                this._adapterNamesInUse = [];
                this._shutdownPromise = new Promise();
            },
            shutdown: function()
            {
                //
                // Ignore shutdown requests if the object adapter factory has
                // already been shut down.
                //
                if(this._instance === null)
                {
                    return this._shutdownPromise;
                }
        
                this._instance = null;
                this._communicator = null;
                this._shutdownPromise = Promise.all(
                    this._adapters.map(function(adapter)
                                       {
                                           return adapter.deactivate();
                                       }));
                return this._shutdownPromise;
            },
            waitForShutdown: function()
            {
                var self = this;
                return this._shutdownPromise.then(
                    function()
                    {
                        return Promise.all(self._adapters.map(function(adapter)
                                                              {
                                                                  return adapter.waitForDeactivate();
                                                              }));
                    });
            },
            isShutdown: function()
            {
                return this._instance === null;
            },
            destroy: function()
            {
                var self = this;
                return this.waitForShutdown().then(
                    function()
                    {
                        return Promise.all(self._adapters.map(function(adapter)
                                                              {
                                                                  return adapter.destroy();
                                                              }));
                    });
            },
            createObjectAdapter: function(name, router, promise)
            {
                if(this._instance === null)
                {
                    throw new Ice.ObjectAdapterDeactivatedException();
                }
        
                var adapter = null;
                try
                {
                    if(name.length === 0)
                    {
                        var uuid = Ice.generateUUID();
                        adapter = new ObjectAdapterI(this._instance, this._communicator, this, uuid, null, true, promise);
                    }
                    else
                    {
                        if(this._adapterNamesInUse.indexOf(name) !== -1)
                        {
                            throw new Ice.AlreadyRegisteredException("object adapter", name);
                        }
                        adapter = new ObjectAdapterI(this._instance, this._communicator, this, name, router, false, promise);
                        this._adapterNamesInUse.push(name);
                    }
                    this._adapters.push(adapter);
                }
                catch(ex)
                {
                    promise.fail(ex, promise);
                }
            },
            removeObjectAdapter: function(adapter)
            {
                if(this._instance === null)
                {
                    return;
                }
        
                var n = this._adapters.indexOf(adapter);
                if(n !== -1)
                {
                    this._adapters.splice(n, 1);
                }
        
                n = this._adapterNamesInUse.indexOf(adapter.getName());
                if(n !== -1)
                {
                    this._adapterNamesInUse.splice(n, 1);
                }
            }
        });
        
        Ice.ObjectAdapterFactory = ObjectAdapterFactory;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Metrics.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
            Slice.defineDictionary(IceMX, "StringIntDict", "StringIntDictHelper", "Ice.StringHelper", "Ice.IntHelper", false, undefined, undefined);
        
            /**
             * The base class for metrics. A metrics object represents a
             * collection of measurements associated to a given a system.
             * 
             **/
            IceMX.Metrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures)
                {
                    Ice.Object.call(this);
                    this.id = id !== undefined ? id : "";
                    this.total = total !== undefined ? total : new Ice.Long(0, 0);
                    this.current = current !== undefined ? current : 0;
                    this.totalLifetime = totalLifetime !== undefined ? totalLifetime : new Ice.Long(0, 0);
                    this.failures = failures !== undefined ? failures : 0;
                },
                Ice.Object, undefined, 1,
                [
                    "::Ice::Object",
                    "::IceMX::Metrics"
                ],
                -1,
                function(__os)
                {
                    __os.writeString(this.id);
                    __os.writeLong(this.total);
                    __os.writeInt(this.current);
                    __os.writeLong(this.totalLifetime);
                    __os.writeInt(this.failures);
                },
                function(__is)
                {
                    this.id = __is.readString();
                    this.total = __is.readLong();
                    this.current = __is.readInt();
                    this.totalLifetime = __is.readLong();
                    this.failures = __is.readInt();
                },
                false);
        
            IceMX.MetricsPrx = Slice.defineProxy(Ice.ObjectPrx, IceMX.Metrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.Metrics, IceMX.MetricsPrx);
        
            /**
             * A structure to keep track of failures associated with a given
             * metrics.
             * 
             **/
            IceMX.MetricsFailures = Slice.defineStruct(
                function(id, failures)
                {
                    this.id = id !== undefined ? id : "";
                    this.failures = failures !== undefined ? failures : null;
                },
                false,
                function(__os)
                {
                    __os.writeString(this.id);
                    IceMX.StringIntDictHelper.write(__os, this.failures);
                },
                function(__is)
                {
                    this.id = __is.readString();
                    this.failures = IceMX.StringIntDictHelper.read(__is);
                },
                2, 
                false);
            Slice.defineSequence(IceMX, "MetricsFailuresSeqHelper", "IceMX.MetricsFailures", false);
            Slice.defineSequence(IceMX, "MetricsMapHelper", "Ice.ObjectHelper", false, "IceMX.Metrics");
            Slice.defineDictionary(IceMX, "MetricsView", "MetricsViewHelper", "Ice.StringHelper", "IceMX.MetricsMapHelper", false, undefined, undefined, Ice.ArrayUtil.equals);
        
            /**
             * Raised if a metrics view cannot be found.
             * 
             **/
            IceMX.UnknownMetricsView = Slice.defineUserException(
                function(_cause)
                {
                    Ice.UserException.call(this, _cause);
                },
                Ice.UserException,
                "IceMX::UnknownMetricsView",
                undefined, undefined,
                false,
                false);
        
            /**
             * The metrics administrative facet interface. This interface allows
             * remote administrative clients to access metrics of an application
             * that enabled the Ice administrative facility and configured some
             * metrics views.
             * 
             **/
            IceMX.MetricsAdmin = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 1,
                [
                    "::Ice::Object",
                    "::IceMX::MetricsAdmin"
                ],
                -1, undefined, undefined, false);
        
            IceMX.MetricsAdminPrx = Slice.defineProxy(Ice.ObjectPrx, IceMX.MetricsAdmin.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.MetricsAdmin, IceMX.MetricsAdminPrx,
            {
                "getMetricsViewNames": [, , , , 2, ["Ice.StringSeqHelper"], , [["Ice.StringSeqHelper"]], , , ],
                "enableMetricsView": [, , , , 2, , [[7]], , 
                [
                    IceMX.UnknownMetricsView
                ], , ],
                "disableMetricsView": [, , , , 2, , [[7]], , 
                [
                    IceMX.UnknownMetricsView
                ], , ],
                "getMetricsView": [, , , , 2, ["IceMX.MetricsViewHelper"], [[7]], [[4]], 
                [
                    IceMX.UnknownMetricsView
                ], , true],
                "getMapMetricsFailures": [, , , , 2, ["IceMX.MetricsFailuresSeqHelper"], [[7], [7]], , 
                [
                    IceMX.UnknownMetricsView
                ], , ],
                "getMetricsFailures": [, , , , 2, [IceMX.MetricsFailures], [[7], [7], [7]], , 
                [
                    IceMX.UnknownMetricsView
                ], , ]
            });
        
            /**
             * Provides information on the number of threads currently in use and
             * their activity.
             * 
             **/
            IceMX.ThreadMetrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures, inUseForIO, inUseForUser, inUseForOther)
                {
                    IceMX.Metrics.call(this, id, total, current, totalLifetime, failures);
                    this.inUseForIO = inUseForIO !== undefined ? inUseForIO : 0;
                    this.inUseForUser = inUseForUser !== undefined ? inUseForUser : 0;
                    this.inUseForOther = inUseForOther !== undefined ? inUseForOther : 0;
                },
                IceMX.Metrics, undefined, 2,
                [
                    "::Ice::Object",
                    "::IceMX::Metrics",
                    "::IceMX::ThreadMetrics"
                ],
                -1,
                function(__os)
                {
                    __os.writeInt(this.inUseForIO);
                    __os.writeInt(this.inUseForUser);
                    __os.writeInt(this.inUseForOther);
                },
                function(__is)
                {
                    this.inUseForIO = __is.readInt();
                    this.inUseForUser = __is.readInt();
                    this.inUseForOther = __is.readInt();
                },
                false);
        
            IceMX.ThreadMetricsPrx = Slice.defineProxy(IceMX.MetricsPrx, IceMX.ThreadMetrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.ThreadMetrics, IceMX.ThreadMetricsPrx);
        
            /**
             * Provides information on servant dispatch.
             * 
             **/
            IceMX.DispatchMetrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures, userException, size, replySize)
                {
                    IceMX.Metrics.call(this, id, total, current, totalLifetime, failures);
                    this.userException = userException !== undefined ? userException : 0;
                    this.size = size !== undefined ? size : new Ice.Long(0, 0);
                    this.replySize = replySize !== undefined ? replySize : new Ice.Long(0, 0);
                },
                IceMX.Metrics, undefined, 1,
                [
                    "::Ice::Object",
                    "::IceMX::DispatchMetrics",
                    "::IceMX::Metrics"
                ],
                -1,
                function(__os)
                {
                    __os.writeInt(this.userException);
                    __os.writeLong(this.size);
                    __os.writeLong(this.replySize);
                },
                function(__is)
                {
                    this.userException = __is.readInt();
                    this.size = __is.readLong();
                    this.replySize = __is.readLong();
                },
                false);
        
            IceMX.DispatchMetricsPrx = Slice.defineProxy(IceMX.MetricsPrx, IceMX.DispatchMetrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.DispatchMetrics, IceMX.DispatchMetricsPrx);
        
            /**
             * Provides information on child invocations. A child invocation is
             * either remote (sent over an Ice connection) or collocated. An
             * invocation can have multiple child invocation if it is
             * retried. Child invocation metrics are embedded within {@link
             * InvocationMetrics}.
             * 
             **/
            IceMX.ChildInvocationMetrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures, size, replySize)
                {
                    IceMX.Metrics.call(this, id, total, current, totalLifetime, failures);
                    this.size = size !== undefined ? size : new Ice.Long(0, 0);
                    this.replySize = replySize !== undefined ? replySize : new Ice.Long(0, 0);
                },
                IceMX.Metrics, undefined, 1,
                [
                    "::Ice::Object",
                    "::IceMX::ChildInvocationMetrics",
                    "::IceMX::Metrics"
                ],
                -1,
                function(__os)
                {
                    __os.writeLong(this.size);
                    __os.writeLong(this.replySize);
                },
                function(__is)
                {
                    this.size = __is.readLong();
                    this.replySize = __is.readLong();
                },
                false);
        
            IceMX.ChildInvocationMetricsPrx = Slice.defineProxy(IceMX.MetricsPrx, IceMX.ChildInvocationMetrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.ChildInvocationMetrics, IceMX.ChildInvocationMetricsPrx);
        
            /**
             * Provides information on invocations that are collocated. Collocated
             * metrics are embedded within {@link InvocationMetrics}.
             * 
             **/
            IceMX.CollocatedMetrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures, size, replySize)
                {
                    IceMX.ChildInvocationMetrics.call(this, id, total, current, totalLifetime, failures, size, replySize);
                },
                IceMX.ChildInvocationMetrics, undefined, 2,
                [
                    "::Ice::Object",
                    "::IceMX::ChildInvocationMetrics",
                    "::IceMX::CollocatedMetrics",
                    "::IceMX::Metrics"
                ],
                -1, undefined, undefined, false);
        
            IceMX.CollocatedMetricsPrx = Slice.defineProxy(IceMX.ChildInvocationMetricsPrx, IceMX.CollocatedMetrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.CollocatedMetrics, IceMX.CollocatedMetricsPrx);
        
            /**
             * Provides information on invocations that are specifically sent over
             * Ice connections. Remote metrics are embedded within {@link
             * InvocationMetrics}.
             * 
             **/
            IceMX.RemoteMetrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures, size, replySize)
                {
                    IceMX.ChildInvocationMetrics.call(this, id, total, current, totalLifetime, failures, size, replySize);
                },
                IceMX.ChildInvocationMetrics, undefined, 3,
                [
                    "::Ice::Object",
                    "::IceMX::ChildInvocationMetrics",
                    "::IceMX::Metrics",
                    "::IceMX::RemoteMetrics"
                ],
                -1, undefined, undefined, false);
        
            IceMX.RemoteMetricsPrx = Slice.defineProxy(IceMX.ChildInvocationMetricsPrx, IceMX.RemoteMetrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.RemoteMetrics, IceMX.RemoteMetricsPrx);
        
            /**
             * Provide measurements for proxy invocations. Proxy invocations can
             * either be sent over the wire or be collocated.
             * 
             **/
            IceMX.InvocationMetrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures, retry, userException, remotes, collocated)
                {
                    IceMX.Metrics.call(this, id, total, current, totalLifetime, failures);
                    this.retry = retry !== undefined ? retry : 0;
                    this.userException = userException !== undefined ? userException : 0;
                    this.remotes = remotes !== undefined ? remotes : null;
                    this.collocated = collocated !== undefined ? collocated : null;
                },
                IceMX.Metrics, undefined, 1,
                [
                    "::Ice::Object",
                    "::IceMX::InvocationMetrics",
                    "::IceMX::Metrics"
                ],
                -1,
                function(__os)
                {
                    __os.writeInt(this.retry);
                    __os.writeInt(this.userException);
                    IceMX.MetricsMapHelper.write(__os, this.remotes);
                    IceMX.MetricsMapHelper.write(__os, this.collocated);
                },
                function(__is)
                {
                    this.retry = __is.readInt();
                    this.userException = __is.readInt();
                    this.remotes = IceMX.MetricsMapHelper.read(__is);
                    this.collocated = IceMX.MetricsMapHelper.read(__is);
                },
                false);
        
            IceMX.InvocationMetricsPrx = Slice.defineProxy(IceMX.MetricsPrx, IceMX.InvocationMetrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.InvocationMetrics, IceMX.InvocationMetricsPrx);
        
            /**
             * Provides information on the data sent and received over Ice
             * connections.
             * 
             **/
            IceMX.ConnectionMetrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures, receivedBytes, sentBytes)
                {
                    IceMX.Metrics.call(this, id, total, current, totalLifetime, failures);
                    this.receivedBytes = receivedBytes !== undefined ? receivedBytes : new Ice.Long(0, 0);
                    this.sentBytes = sentBytes !== undefined ? sentBytes : new Ice.Long(0, 0);
                },
                IceMX.Metrics, undefined, 1,
                [
                    "::Ice::Object",
                    "::IceMX::ConnectionMetrics",
                    "::IceMX::Metrics"
                ],
                -1,
                function(__os)
                {
                    __os.writeLong(this.receivedBytes);
                    __os.writeLong(this.sentBytes);
                },
                function(__is)
                {
                    this.receivedBytes = __is.readLong();
                    this.sentBytes = __is.readLong();
                },
                false);
        
            IceMX.ConnectionMetricsPrx = Slice.defineProxy(IceMX.MetricsPrx, IceMX.ConnectionMetrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.ConnectionMetrics, IceMX.ConnectionMetricsPrx);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Debug = Ice.Debug;
        var HashMap = Ice.HashMap;
        var ConnectRequestHandler = Ice.ConnectRequestHandler;
        
        var RequestHandlerFactory = Ice.Class({
            __init__: function(instance)
            {
                this._instance = instance;
                this._handlers = new HashMap(HashMap.compareEquals);
            },
            getRequestHandler: function(ref, proxy)
            {
                var connect = false;
                var handler;
                if(ref.getCacheConnection())
                {
                    handler = this._handlers.get(ref);
                    if(!handler)
                    {
                        handler = new ConnectRequestHandler(ref, proxy);
                        this._handlers.set(ref, handler);
                        connect = true;
                    }
                }
                else
                {
                    connect = true;
                    handler = new ConnectRequestHandler(ref, proxy);
                }
        
                if(connect)
                {
                    ref.getConnection().then(function(connection, compress)
                                             {
                                                 handler.setConnection(connection, compress);
                                             },
                                             function(ex)
                                             {
                                                 handler.setException(ex);
                                             });
                }
                return proxy.__setRequestHandler(handler.connect(proxy));
            },
            removeRequestHandler: function(ref, handler)
            {
                if(ref.getCacheConnection())
                {
                    if(this._handlers.get(ref) === handler)
                    {
                        this._handlers.del(ref);
                    }
                }
            }
        });
        
        Ice.RequestHandlerFactory = RequestHandlerFactory;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Process.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * An administrative interface for process management. Managed servers must
             * implement this interface.
             * 
             * <p class="Note">A servant implementing this interface is a potential target
             * for denial-of-service attacks, therefore proper security precautions
             * should be taken. For example, the servant can use a UUID to make its
             * identity harder to guess, and be registered in an object adapter with
             * a secured endpoint.
             * 
             **/
            Ice.Process = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 1,
                [
                    "::Ice::Object",
                    "::Ice::Process"
                ],
                -1, undefined, undefined, false);
        
            Ice.ProcessPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.Process.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.Process, Ice.ProcessPrx,
            {
                "shutdown": [, , , , , , , , , , ],
                "writeMessage": [, , , , , , [[7], [3]], , , , ]
            });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var TcpEndpointI = Ice.TcpEndpointI;
        
        var TcpEndpointFactory = Ice.Class({
            __init__: function(instance)
            {
                this._instance = instance;
            },
            type: function()
            {
                return this._instance.type();
            },
            protocol: function()
            {
                return this._instance.protocol();
            },
            create: function(args, oaEndpoint)
            {
                var e = new TcpEndpointI(this._instance);
                e.initWithOptions(args, oaEndpoint);
                return e;
            },
            read: function(s)
            {
                var e = new TcpEndpointI(this._instance);
                e.initWithStream(s);
                return e;
            },
            destroy: function()
            {
                this._instance = null;
            },
            clone:function(instance)
            {
                return new TcpEndpointFactory(instance);
            }
        });
        
        Ice.TcpEndpointFactory = TcpEndpointFactory;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `PropertiesAdmin.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
            Slice.defineDictionary(Ice, "PropertyDict", "PropertyDictHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);
        
            /**
             * The PropertiesAdmin interface provides remote access to the properties
             * of a communicator.
             * 
             **/
            Ice.PropertiesAdmin = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 1,
                [
                    "::Ice::Object",
                    "::Ice::PropertiesAdmin"
                ],
                -1, undefined, undefined, false);
        
            Ice.PropertiesAdminPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.PropertiesAdmin.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.PropertiesAdmin, Ice.PropertiesAdminPrx,
            {
                "getProperty": [, , , , , [7], [[7]], , , , ],
                "getPropertiesForPrefix": [, , , , , ["Ice.PropertyDictHelper"], [[7]], , , , ],
                "setProperties": [, , , 1, , , [["Ice.PropertyDictHelper"]], , , , ]
            });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `RemoteLogger.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * An enumeration representing the different types of log messages.
             * 
             **/
            Ice.LogMessageType = Slice.defineEnum([
                ['PrintMessage', 0], ['TraceMessage', 1], ['WarningMessage', 2], ['ErrorMessage', 3]]);
            Slice.defineSequence(Ice, "LogMessageTypeSeqHelper", "Ice.LogMessageType.__helper", false);
        
            /**
             * A complete log message.
             * 
             **/
            Ice.LogMessage = Slice.defineStruct(
                function(type, timestamp, traceCategory, message)
                {
                    this.type = type !== undefined ? type : Ice.LogMessageType.PrintMessage;
                    this.timestamp = timestamp !== undefined ? timestamp : 0;
                    this.traceCategory = traceCategory !== undefined ? traceCategory : "";
                    this.message = message !== undefined ? message : "";
                },
                true,
                function(__os)
                {
                    Ice.LogMessageType.__write(__os, this.type);
                    __os.writeLong(this.timestamp);
                    __os.writeString(this.traceCategory);
                    __os.writeString(this.message);
                },
                function(__is)
                {
                    this.type = Ice.LogMessageType.__read(__is);
                    this.timestamp = __is.readLong();
                    this.traceCategory = __is.readString();
                    this.message = __is.readString();
                },
                11, 
                false);
            Slice.defineSequence(Ice, "LogMessageSeqHelper", "Ice.LogMessage", false);
        
            /**
             * The Ice remote logger interface. An application can implement a
             * RemoteLogger to receive the log messages sent to the local {@link Logger}
             * of another Ice application.
             * 
             **/
            Ice.RemoteLogger = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 1,
                [
                    "::Ice::Object",
                    "::Ice::RemoteLogger"
                ],
                -1, undefined, undefined, false);
        
            Ice.RemoteLoggerPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.RemoteLogger.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.RemoteLogger, Ice.RemoteLoggerPrx,
            {
                "init": [, , , , , , [[7], ["Ice.LogMessageSeqHelper"]], , , , ],
                "log": [, , , , , , [[Ice.LogMessage]], , , , ]
            });
        
            /**
             * An exception thrown by {@link LoggerAdmin#attachRemoteLogger} to report
             * that the provided {@link RemoteLogger} was previously attached to this
             * {@link LoggerAdmin}.
             * 
             **/
            Ice.RemoteLoggerAlreadyAttachedException = Slice.defineUserException(
                function(_cause)
                {
                    Ice.UserException.call(this, _cause);
                },
                Ice.UserException,
                "Ice::RemoteLoggerAlreadyAttachedException",
                undefined, undefined,
                false,
                false);
        
            /**
             * The interface of the admin object that allows an Ice application the attach its 
             * {@link RemoteLogger} to the {@link Logger} of this admin object's Ice communicator.
             * 
             **/
            Ice.LoggerAdmin = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Ice::LoggerAdmin",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Ice.LoggerAdminPrx = Slice.defineProxy(Ice.ObjectPrx, Ice.LoggerAdmin.ice_staticId, undefined);
        
            Slice.defineOperations(Ice.LoggerAdmin, Ice.LoggerAdminPrx,
            {
                "attachRemoteLogger": [, , , , , , [["Ice.RemoteLoggerPrx"], ["Ice.LogMessageTypeSeqHelper"], ["Ice.StringSeqHelper"], [3]], , 
                [
                    Ice.RemoteLoggerAlreadyAttachedException
                ], , ],
                "detachRemoteLogger": [, , , , , [1], [["Ice.RemoteLoggerPrx"]], , , , ],
                "getLog": [, , , , , ["Ice.LogMessageSeqHelper"], [["Ice.LogMessageTypeSeqHelper"], ["Ice.StringSeqHelper"], [3]], [[7]], , , ]
            });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var WSEndpoint = Ice.WSEndpoint;
        
        var WSEndpointFactory = Ice.Class({
            __init__:function(instance, delegate)
            {
                this._instance = instance;
                this._delegate = delegate;
            },
            type: function()
            {
                return this._instance.type();
            },
            protocol: function()
            {
                return this._instance.protocol();
            },
            create: function(args, oaEndpoint)
            {
                var e = new WSEndpoint(this._instance, this._delegate.create(args, oaEndpoint));
                e.initWithOptions(args);
                return e;
            },
            read: function(s)
            {
                var e = new WSEndpoint(this._instance, this._delegate.read(s));
                e.initWithStream(s);
                return e;
            },
            destroy: function()
            {
                this._delegate.destroy();
                this._instance = null;
            }
        });
        Ice.WSEndpointFactory = WSEndpointFactory;
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `SliceChecksumDict.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
            Slice.defineDictionary(Ice, "SliceChecksumDict", "SliceChecksumDictHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        
        var AsyncResultBase = Ice.AsyncResultBase;
        var Debug = Ice.Debug;
        var DefaultsAndOverrides = Ice.DefaultsAndOverrides;
        var EndpointFactoryManager = Ice.EndpointFactoryManager;
        var HashMap = Ice.HashMap;
        var ImplicitContextI = Ice.ImplicitContextI;
        var LocatorManager = Ice.LocatorManager;
        var Logger = Ice.Logger;
        var ObjectAdapterFactory = Ice.ObjectAdapterFactory;
        var ObjectFactoryManager = Ice.ObjectFactoryManager;
        var OutgoingConnectionFactory = Ice.OutgoingConnectionFactory;
        var Promise = Ice.Promise;
        var Properties = Ice.Properties;
        var ProxyFactory = Ice.ProxyFactory;
        var RetryQueue = Ice.RetryQueue;
        var RouterManager = Ice.RouterManager;
        var Timer = Ice.Timer;
        var TraceLevels = Ice.TraceLevels;
        var ReferenceFactory = Ice.ReferenceFactory;
        var RequestHandlerFactory = Ice.RequestHandlerFactory;
        var ACMConfig = Ice.ACMConfig;
        
        var StateActive = 0;
        var StateDestroyInProgress = 1;
        var StateDestroyed = 2;
        
        //
        // Instance - only for use by Communicator
        //
        var Instance = Ice.Class({
            __init__: function(initData)
            {
                this._state = StateActive;
                this._initData = initData;
        
                this._traceLevels = null;
                this._defaultsAndOverrides = null;
                this._messageSizeMax = 0;
                this._batchAutoFlushSize = 0;
                this._clientACM = null;
                this._implicitContext = null;
                this._routerManager = null;
                this._locatorManager = null;
                this._referenceFactory = null;
                this._requestHandlerFactory = null;
                this._proxyFactory = null;
                this._outgoingConnectionFactory = null;
                this._servantFactoryManager = null;
                this._objectAdapterFactory = null;
                this._retryQueue = null;
                this._endpointHostResolver = null;
                this._endpointFactoryManager = null;
            },
            initializationData: function()
            {
                //
                // No check for destruction. It must be possible to access the
                // initialization data after destruction.
                //
                // This value is immutable.
                //
                return this._initData;
            },
            traceLevels: function()
            {
                // This value is immutable.
                Debug.assert(this._traceLevels !== null);
                return this._traceLevels;
            },
            defaultsAndOverrides: function()
            {
                // This value is immutable.
                Debug.assert(this._defaultsAndOverrides !== null);
                return this._defaultsAndOverrides;
            },
            routerManager: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._routerManager !== null);
                return this._routerManager;
            },
            locatorManager: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._locatorManager !== null);
                return this._locatorManager;
            },
            referenceFactory: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._referenceFactory !== null);
                return this._referenceFactory;
            },
            requestHandlerFactory: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._requestHandlerFactory !== null);
                return this._requestHandlerFactory;
            },
            proxyFactory: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._proxyFactory !== null);
                return this._proxyFactory;
            },
            outgoingConnectionFactory: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._outgoingConnectionFactory !== null);
                return this._outgoingConnectionFactory;
            },
            servantFactoryManager: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._servantFactoryManager !== null);
                return this._servantFactoryManager;
            },
            objectAdapterFactory: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._objectAdapterFactory !== null);
                return this._objectAdapterFactory;
            },
            retryQueue: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._retryQueue !== null);
                return this._retryQueue;
            },
            timer: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._timer !== null);
                return this._timer;
            },
            endpointFactoryManager: function()
            {
                if(this._state === StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                Debug.assert(this._endpointFactoryManager !== null);
                return this._endpointFactoryManager;
            },
            messageSizeMax: function()
            {
                // This value is immutable.
                return this._messageSizeMax;
            },
            batchAutoFlushSize: function()
            {
                // This value is immutable.
                return this._batchAutoFlushSize;
            },
            clientACM: function()
            {
                // This value is immutable.
                return this._clientACM;
            },
            getImplicitContext: function()
            {
                return this._implicitContext;
            },
            stringToIdentity: function(s)
            {
                return Ice.stringToIdentity(s);
            },
            identityToString: function(ident)
            {
                return Ice.identityToString(ident);
            },
        
            setDefaultLocator: function(locator)
            {
                if(this._state == StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                this._referenceFactory = this._referenceFactory.setDefaultLocator(locator);
            },
            setDefaultRouter: function(router)
            {
                if(this._state == StateDestroyed)
                {
                    throw new Ice.CommunicatorDestroyedException();
                }
        
                this._referenceFactory = this._referenceFactory.setDefaultRouter(router);
            },
            setLogger: function(logger)
            {
                this._initData.logger = logger;
            },
            finishSetup: function(communicator, promise)
            {
                //
                // If promise == null, it means the caller is requesting a synchronous setup.
                // Otherwise, we resolve the promise after all initialization is complete.
                //
        
                try
                {
                    if(this._initData.properties === null)
                    {
                        this._initData.properties = Properties.createProperties();
                    }
        
                    if(Ice.__oneOfDone === undefined)
                    {
                        Ice.__printStackTraces =
                            this._initData.properties.getPropertyAsIntWithDefault("Ice.PrintStackTraces", 0) > 0;
        
                        Ice.__oneOfDone = true;
                    }
        
                    if(this._initData.logger === null)
                    {
                        this._initData.logger = Ice.getProcessLogger();
                    }
        
                    this._traceLevels = new TraceLevels(this._initData.properties);
        
                    this._defaultsAndOverrides = new DefaultsAndOverrides(this._initData.properties, this._initData.logger);
        
                    var defMessageSizeMax = 1024;
                    var num = this._initData.properties.getPropertyAsIntWithDefault("Ice.MessageSizeMax", defMessageSizeMax);
                    if(num < 1 || num > 0x7fffffff / 1024)
                    {
                        this._messageSizeMax = 0x7fffffff;
                    }
                    else
                    {
                        this._messageSizeMax = num * 1024; // Property is in kilobytes, _messageSizeMax in bytes
                    }
        
                    if(this._initData.properties.getProperty("Ice.BatchAutoFlushSize").length === 0 &&
                       this._initData.properties.getProperty("Ice.BatchAutoFlush").length > 0)
                    {
                        if(this._initData.properties.getPropertyAsInt("Ice.BatchAutoFlush") > 0)
                        {
                            this._batchAutoFlushSize = this._messageSizeMax;
                        }
                    }
                    else
                    {
                        num = this._initData.properties.getPropertyAsIntWithDefault("Ice.BatchAutoFlushSize", 1024); // 1MB
                        if(num < 1)
                        {
                            this._batchAutoFlushSize = num;
                        }
                        else if(num > 0x7fffffff / 1024)
                        {
                            this._batchAutoFlushSize = 0x7fffffff;
                        }
                        else
                        {
                            this._batchAutoFlushSize = num * 1024; // Property is in kilobytes, _batchAutoFlushSize in bytes
                        }
                    }
        
                    this._clientACM = new ACMConfig(this._initData.properties, this._initData.logger, "Ice.ACM.Client",
                                                    new ACMConfig(this._initData.properties, this._initData.logger,
                                                                    "Ice.ACM", new ACMConfig()));
        
                    this._implicitContext =
                        ImplicitContextI.create(this._initData.properties.getProperty("Ice.ImplicitContext"));
        
                    this._routerManager = new RouterManager();
        
                    this._locatorManager = new LocatorManager(this._initData.properties);
        
                    this._referenceFactory = new ReferenceFactory(this, communicator);
        
                    this._requestHandlerFactory = new RequestHandlerFactory(this, communicator);
        
                    this._proxyFactory = new ProxyFactory(this);
        
                    this._endpointFactoryManager = new EndpointFactoryManager(this);
        
                    var tcpInstance = new Ice.ProtocolInstance(this, Ice.TCPEndpointType, "tcp", false);
                    var tcpEndpointFactory = new Ice.TcpEndpointFactory(tcpInstance);
                    this._endpointFactoryManager.add(tcpEndpointFactory);
        
                    var wsInstance = new Ice.ProtocolInstance(this, Ice.WSEndpointType, "ws", false);
                    var wsEndpointFactory = new Ice.WSEndpointFactory(wsInstance, tcpEndpointFactory.clone(wsInstance));
                    this._endpointFactoryManager.add(wsEndpointFactory);
        
                    var sslInstance = new Ice.ProtocolInstance(this, IceSSL.EndpointType, "ssl", true);
                    var sslEndpointFactory = new Ice.TcpEndpointFactory(sslInstance);
                    this._endpointFactoryManager.add(sslEndpointFactory);
        
                    var wssInstance = new Ice.ProtocolInstance(this, Ice.WSSEndpointType, "wss", true);
                    var wssEndpointFactory = new Ice.WSEndpointFactory(wssInstance, sslEndpointFactory.clone(wssInstance));
                    this._endpointFactoryManager.add(wssEndpointFactory);
        
                    this._outgoingConnectionFactory = new OutgoingConnectionFactory(communicator, this);
                    this._servantFactoryManager = new ObjectFactoryManager();
        
                    this._objectAdapterFactory = new ObjectAdapterFactory(this, communicator);
        
                    this._retryQueue = new RetryQueue(this);
                    this._timer = new Timer(this._initData.logger);
        
                    var router = Ice.RouterPrx.uncheckedCast(this._proxyFactory.propertyToProxy("Ice.Default.Router"));
                    if(router !== null)
                    {
                        this._referenceFactory = this._referenceFactory.setDefaultRouter(router);
                    }
        
                    var loc = Ice.LocatorPrx.uncheckedCast(this._proxyFactory.propertyToProxy("Ice.Default.Locator"));
                    if(loc !== null)
                    {
                        this._referenceFactory = this._referenceFactory.setDefaultLocator(loc);
                    }
        
                    if(promise !== null)
                    {
                        promise.succeed(communicator);
                    }
                }
                catch(ex)
                {
                    if(promise !== null)
                    {
                        if(ex instanceof Ice.LocalException)
                        {
                            this.destroy().finally2(function()
                                                    {
                                                        promise.fail(ex);
                                                    });
                        }
                        else
                        {
                            promise.fail(ex);
                        }
                    }
                    else
                    {
                        if(ex instanceof Ice.LocalException)
                        {
                            this.destroy();
                        }
                        throw ex;
                    }
                }
            },
            //
            // Only for use by Ice.CommunicatorI
            //
            destroy: function()
            {
                var promise = new AsyncResultBase(null, "destroy", null, this, null);
        
                //
                // If destroy is in progress, wait for it to be done. This is
                // necessary in case destroy() is called concurrently by
                // multiple threads.
                //
                if(this._state == StateDestroyInProgress)
                {
                    if(!this._destroyPromises)
                    {
                        this._destroyPromises = [];
                    }
                    this._destroyPromises.push(promise);
                    return promise;
                }
                this._state = StateDestroyInProgress;
        
                //
                // Shutdown and destroy all the incoming and outgoing Ice
                // connections and wait for the connections to be finished.
                //
                var self = this;
                Ice.Promise.try2(
                    function()
                    {
                        if(self._objectAdapterFactory)
                        {
                            return self._objectAdapterFactory.shutdown();
                        }
                    }
                ).then(
                    function()
                    {
                        if(self._outgoingConnectionFactory !== null)
                        {
                            self._outgoingConnectionFactory.destroy();
                        }
        
                        if(self._objectAdapterFactory !== null)
                        {
                            return self._objectAdapterFactory.destroy();
                        }
                    }
                ).then(
                    function()
                    {
                        if(self._outgoingConnectionFactory !== null)
                        {
                            return self._outgoingConnectionFactory.waitUntilFinished();
                        }
                    }
                ).then(
                    function()
                    {
                        if(self._retryQueue)
                        {
                            self._retryQueue.destroy();
                        }
                        if(self._timer)
                        {
                            self._timer.destroy();
                        }
        
                        if(self._servantFactoryManager)
                        {
                            self._servantFactoryManager.destroy();
                        }
                        if(self._routerManager)
                        {
                            self._routerManager.destroy();
                        }
                        if(self._locatorManager)
                        {
                            self._locatorManager.destroy();
                        }
                        if(self._endpointFactoryManager)
                        {
                            self._endpointFactoryManager.destroy();
                        }
        
                        var i;
                        if(self._initData.properties.getPropertyAsInt("Ice.Warn.UnusedProperties") > 0)
                        {
                            var unusedProperties = self._initData.properties.getUnusedProperties();
                            if(unusedProperties.length > 0)
                            {
                                var message = [];
                                message.push("The following properties were set but never read:");
                                for(i = 0; i < unusedProperties.length; ++i)
                                {
                                    message.push("\n    ");
                                    message.push(unusedProperties[i]);
                                }
                                self._initData.logger.warning(message.join(""));
                            }
                        }
        
                        self._objectAdapterFactory = null;
                        self._outgoingConnectionFactory = null;
                        self._retryQueue = null;
                        self._timer = null;
        
                        self._servantFactoryManager = null;
                        self._referenceFactory = null;
                        self._requestHandlerFactory = null;
                        self._proxyFactory = null;
                        self._routerManager = null;
                        self._locatorManager = null;
                        self._endpointFactoryManager = null;
        
                        self._state = StateDestroyed;
        
                        if(this._destroyPromises)
                        {
                            for(i = 0; i < this._destroyPromises.length; ++i)
                            {
                                this._destroyPromises[i].succeed(this._destroyPromises[i]);
                            }
                        }
                        promise.succeed(promise);
                    }
                ).exception(
                    function(ex)
                    {
                        if(this._destroyPromises)
                        {
                            for(var i = 0; i < this._destroyPromises.length; ++i)
                            {
                                this._destroyPromises[i].fail(ex, this._destroyPromises[i]);
                            }
                        }
                        promise.fail(ex, promise);
                    }
                );
                return promise;
            },
        });
        
        Ice.Instance = Instance;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Instance = Ice.Instance;
        var Promise = Ice.Promise;
        
        //
        // Ice.Communicator
        //
        var Communicator = Ice.Class({
            __init__: function(initData)
            {
                this._instance = new Instance(initData);
            },
            //
            // Certain initialization tasks need to be completed after the
            // constructor.
            //
            finishSetup: function(promise)
            {
                this._instance.finishSetup(this, promise);
            },
            destroy: function()
            {
                return this._instance.destroy();
            },
            shutdown: function()
            {
                this._instance.objectAdapterFactory().shutdown();
            },
            waitForShutdown: function()
            {
                return this._instance.objectAdapterFactory().waitForShutdown();
            },
            isShutdown: function()
            {
                return this._instance.objectAdapterFactory().isShutdown();
            },
            stringToProxy: function(s)
            {
                return this._instance.proxyFactory().stringToProxy(s);
            },
            proxyToString: function(proxy)
            {
                return this._instance.proxyFactory().proxyToString(proxy);
            },
            propertyToProxy: function(s)
            {
                return this._instance.proxyFactory().propertyToProxy(s);
            },
            proxyToProperty: function(proxy, prefix)
            {
                return this._instance.proxyFactory().proxyToProperty(proxy, prefix);
            },
            stringToIdentity: function(s)
            {
                return this._instance.stringToIdentity(s);
            },
            identityToString: function(ident)
            {
                return this._instance.identityToString(ident);
            },
            createObjectAdapter: function(name)
            {
                var promise = new Ice.AsyncResultBase(this, "createObjectAdapter", this, null, null);
                this._instance.objectAdapterFactory().createObjectAdapter(name, null, promise);
                return promise;
            },
            createObjectAdapterWithEndpoints: function(name, endpoints)
            {
                if(name.length === 0)
                {
                    name = Ice.generateUUID();
                }
        
                this.getProperties().setProperty(name + ".Endpoints", endpoints);
                var promise = new Ice.AsyncResultBase(this, "createObjectAdapterWithEndpoints", this, null, null);
                this._instance.objectAdapterFactory().createObjectAdapter(name, null, promise);
                return promise;
            },
            createObjectAdapterWithRouter: function(name, router)
            {
                if(name.length === 0)
                {
                    name = Ice.generateUUID();
                }
        
                var promise = new Ice.AsyncResultBase(this, "createObjectAdapterWithRouter", this, null, null);
        
                //
                // We set the proxy properties here, although we still use the proxy supplied.
                //
                var properties = this.proxyToProperty(router, name + ".Router");
                for(var e = properties.entries; e !== null; e = e.next)
                {
                    this.getProperties().setProperty(e.key, e.value);
                }
        
                this._instance.objectAdapterFactory().createObjectAdapter(name, router, promise);
                return promise;
            },
            addObjectFactory: function(factory, id)
            {
                this._instance.servantFactoryManager().add(factory, id);
            },
            findObjectFactory: function(id)
            {
                return this._instance.servantFactoryManager().find(id);
            },
            getImplicitContext: function()
            {
                return this._instance.getImplicitContext();
            },
            getProperties: function()
            {
                return this._instance.initializationData().properties;
            },
            getLogger: function()
            {
                return this._instance.initializationData().logger;
            },
            getDefaultRouter: function()
            {
                return this._instance.referenceFactory().getDefaultRouter();
            },
            setDefaultRouter: function(router)
            {
                this._instance.setDefaultRouter(router);
            },
            getDefaultLocator: function()
            {
                return this._instance.referenceFactory().getDefaultLocator();
            },
            setDefaultLocator: function(locator)
            {
                this._instance.setDefaultLocator(locator);
            },
            flushBatchRequests: function()
            {
                return this._instance.outgoingConnectionFactory().flushAsyncBatchRequests();
            }
        });
        
        Object.defineProperty(Communicator.prototype, "instance", {
            get: function() { return this._instance; }
        });
        
        Ice.Communicator = Communicator;
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        
        
        var Protocol = Ice.Protocol;
        
        //
        // Ice.InitializationData
        //
        Ice.InitializationData = function()
        {
            this.properties = null;
            this.logger = null;
        };
        
        Ice.InitializationData.prototype.clone = function()
        {
            var r = new Ice.InitializationData();
            r.properties = this.properties;
            r.logger = this.logger;
            return r;
        };
        
        //
        // Ice.initialize()
        //
        Ice.initialize = function(arg1, arg2)
        {
            var args = null;
            var initData = null;
        
            if(arg1 instanceof Array)
            {
                args = arg1;
            }
            else if(arg1 instanceof Ice.InitializationData)
            {
                initData = arg1;
            }
            else if(arg1 !== undefined && arg1 !== null)
            {
                throw new Ice.InitializationException("invalid argument to initialize");
            }
        
            if(arg2 !== undefined && arg2 !== null)
            {
                if(arg2 instanceof Ice.InitializationData && initData === null)
                {
                    initData = arg2;
                }
                else
                {
                    throw new Ice.InitializationException("invalid argument to initialize");
                }
            }
        
            if(initData === null)
            {
                initData = new Ice.InitializationData();
            }
            else
            {
                initData = initData.clone();
            }
            initData.properties = Ice.createProperties(args, initData.properties);
        
            var result = new Ice.Communicator(initData);
            result.finishSetup(null);
            return result;
        };
        
        //
        // Ice.createProperties()
        //
        Ice.createProperties = function(args, defaults)
        {
            return new Ice.Properties(args, defaults);
        };
        
        Ice.currentProtocol = function()
        {
            return Protocol.currentProtocol.clone();
        };
        
        Ice.currentEncoding = function()
        {
            return Protocol.currentEncoding.clone();
        };
        
        
    }());

    __root.Ice = Ice;
    __root.IceMX = IceMX;
    __root.IceSSL = IceSSL;
}());


(function()
{
    var __root = typeof(window) !== "undefined" ? window : self;
    __root.Glacier2 = __root.Glacier2 || {};
    var Slice = Ice.Slice;

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Metrics.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * Provides information on Glacier2 sessions.
             * 
             **/
            IceMX.SessionMetrics = Slice.defineObject(
                function(id, total, current, totalLifetime, failures, forwardedClient, forwardedServer, routingTableSize, queuedClient, queuedServer, overriddenClient, overriddenServer)
                {
                    IceMX.Metrics.call(this, id, total, current, totalLifetime, failures);
                    this.forwardedClient = forwardedClient !== undefined ? forwardedClient : 0;
                    this.forwardedServer = forwardedServer !== undefined ? forwardedServer : 0;
                    this.routingTableSize = routingTableSize !== undefined ? routingTableSize : 0;
                    this.queuedClient = queuedClient !== undefined ? queuedClient : 0;
                    this.queuedServer = queuedServer !== undefined ? queuedServer : 0;
                    this.overriddenClient = overriddenClient !== undefined ? overriddenClient : 0;
                    this.overriddenServer = overriddenServer !== undefined ? overriddenServer : 0;
                },
                IceMX.Metrics, undefined, 2,
                [
                    "::Ice::Object",
                    "::IceMX::Metrics",
                    "::IceMX::SessionMetrics"
                ],
                -1,
                function(__os)
                {
                    __os.writeInt(this.forwardedClient);
                    __os.writeInt(this.forwardedServer);
                    __os.writeInt(this.routingTableSize);
                    __os.writeInt(this.queuedClient);
                    __os.writeInt(this.queuedServer);
                    __os.writeInt(this.overriddenClient);
                    __os.writeInt(this.overriddenServer);
                },
                function(__is)
                {
                    this.forwardedClient = __is.readInt();
                    this.forwardedServer = __is.readInt();
                    this.routingTableSize = __is.readInt();
                    this.queuedClient = __is.readInt();
                    this.queuedServer = __is.readInt();
                    this.overriddenClient = __is.readInt();
                    this.overriddenServer = __is.readInt();
                },
                false);
        
            IceMX.SessionMetricsPrx = Slice.defineProxy(IceMX.MetricsPrx, IceMX.SessionMetrics.ice_staticId, undefined);
        
            Slice.defineOperations(IceMX.SessionMetrics, IceMX.SessionMetricsPrx);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `SSLInfo.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * Information taken from an SSL connection used for permissions
             * verification.
             * 
             * @see PermissionsVerifier
             * 
             **/
            Glacier2.SSLInfo = Slice.defineStruct(
                function(remoteHost, remotePort, localHost, localPort, cipher, certs)
                {
                    this.remoteHost = remoteHost !== undefined ? remoteHost : "";
                    this.remotePort = remotePort !== undefined ? remotePort : 0;
                    this.localHost = localHost !== undefined ? localHost : "";
                    this.localPort = localPort !== undefined ? localPort : 0;
                    this.cipher = cipher !== undefined ? cipher : "";
                    this.certs = certs !== undefined ? certs : null;
                },
                true,
                function(__os)
                {
                    __os.writeString(this.remoteHost);
                    __os.writeInt(this.remotePort);
                    __os.writeString(this.localHost);
                    __os.writeInt(this.localPort);
                    __os.writeString(this.cipher);
                    Ice.StringSeqHelper.write(__os, this.certs);
                },
                function(__is)
                {
                    this.remoteHost = __is.readString();
                    this.remotePort = __is.readInt();
                    this.localHost = __is.readString();
                    this.localPort = __is.readInt();
                    this.cipher = __is.readString();
                    this.certs = Ice.StringSeqHelper.read(__is);
                },
                12, 
                false);
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `PermissionsVerifierF.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Session.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * This exception is raised if an attempt to create a new session
             * failed.
             * 
             * @see Router#createSession
             * @see Router#createSessionFromSecureConnection
             * @see SessionManager#create
             * @see SSLSessionManager#create
             * 
             **/
            Glacier2.CannotCreateSessionException = Slice.defineUserException(
                function(reason, _cause)
                {
                    Ice.UserException.call(this, _cause);
                    this.reason = reason !== undefined ? reason : "";
                },
                Ice.UserException,
                "Glacier2::CannotCreateSessionException",
                function(__os)
                {
                    __os.writeString(this.reason);
                },
                function(__is)
                {
                    this.reason = __is.readString();
                },
                true,
                false);
        
            /**
             * A client-visible session object, which is tied to the lifecycle of
             * a {@link Router}.
             * 
             * @see Router
             * @see SessionManager
             * 
             **/
            Glacier2.Session = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Glacier2::Session",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.SessionPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.Session.ice_staticId, undefined);
        
            Slice.defineOperations(Glacier2.Session, Glacier2.SessionPrx,
            {
                "destroy": [, , , , , , , , , , ]
            });
        
            /**
             * An object for managing the set of identity constraints for specific
             * parts of object identity on a
             * {@link Session}.
             * 
             * @see Session
             * @see SessionControl
             * 
             **/
            Glacier2.StringSet = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Glacier2::StringSet",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.StringSetPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.StringSet.ice_staticId, undefined);
        
            Slice.defineOperations(Glacier2.StringSet, Glacier2.StringSetPrx,
            {
                "add": [, 2, 2, , , , [["Ice.StringSeqHelper"]], , , , ],
                "remove": [, 2, 2, , , , [["Ice.StringSeqHelper"]], , , , ],
                "get": [, 2, 2, , , ["Ice.StringSeqHelper"], , , , , ]
            });
        
            /**
             * An object for managing the set of object identity constraints on a
             * {@link Session}.
             * 
             * @see Session
             * @see SessionControl
             * 
             **/
            Glacier2.IdentitySet = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Glacier2::IdentitySet",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.IdentitySetPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.IdentitySet.ice_staticId, undefined);
        
            Slice.defineOperations(Glacier2.IdentitySet, Glacier2.IdentitySetPrx,
            {
                "add": [, 2, 2, , , , [["Ice.IdentitySeqHelper"]], , , , ],
                "remove": [, 2, 2, , , , [["Ice.IdentitySeqHelper"]], , , , ],
                "get": [, 2, 2, , , ["Ice.IdentitySeqHelper"], , , , , ]
            });
        
            /**
             * An administrative session control object, which is tied to the
             * lifecycle of a {@link Session}.
             * 
             * @see Session
             * 
             **/
            Glacier2.SessionControl = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Glacier2::SessionControl",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.SessionControlPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.SessionControl.ice_staticId, undefined);
        
            Slice.defineOperations(Glacier2.SessionControl, Glacier2.SessionControlPrx,
            {
                "categories": [, , , , , ["Glacier2.StringSetPrx"], , , , , ],
                "adapterIds": [, , , , , ["Glacier2.StringSetPrx"], , , , , ],
                "identities": [, , , , , ["Glacier2.IdentitySetPrx"], , , , , ],
                "getSessionTimeout": [, 2, 2, , , [3], , , , , ],
                "destroy": [, , , , , , , , , , ]
            });
        
            /**
             * The session manager for username/password authenticated users that
             * is responsible for managing {@link Session} objects. New session objects
             * are created by the {@link Router} object calling on an application-provided
             * session manager. If no session manager is provided by the application,
             * no client-visible sessions are passed to the client.
             * 
             * @see Router
             * @see Session
             * 
             **/
            Glacier2.SessionManager = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Glacier2::SessionManager",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.SessionManagerPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.SessionManager.ice_staticId, undefined);
        
            Slice.defineOperations(Glacier2.SessionManager, Glacier2.SessionManagerPrx,
            {
                "create": [, , , , 2, ["Glacier2.SessionPrx"], [[7], ["Glacier2.SessionControlPrx"]], , 
                [
                    Glacier2.CannotCreateSessionException
                ], , ]
            });
        
            /**
             * The session manager for SSL authenticated users that is
             * responsible for managing {@link Session} objects. New session objects are
             * created by the {@link Router} object calling on an application-provided
             * session manager. If no session manager is provided by the
             * application, no client-visible sessions are passed to the client.
             * 
             * @see Router
             * @see Session
             * 
             **/
            Glacier2.SSLSessionManager = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Glacier2::SSLSessionManager",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.SSLSessionManagerPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.SSLSessionManager.ice_staticId, undefined);
        
            Slice.defineOperations(Glacier2.SSLSessionManager, Glacier2.SSLSessionManagerPrx,
            {
                "create": [, , , , 2, ["Glacier2.SessionPrx"], [[Glacier2.SSLInfo], ["Glacier2.SessionControlPrx"]], , 
                [
                    Glacier2.CannotCreateSessionException
                ], , ]
            });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `RouterF.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `PermissionsVerifier.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * This exception is raised if a client is denied the ability to create
             * a session with the router.
             * 
             * @see Router#createSession
             * @see Router#createSessionFromSecureConnection
             * 
             **/
            Glacier2.PermissionDeniedException = Slice.defineUserException(
                function(reason, _cause)
                {
                    Ice.UserException.call(this, _cause);
                    this.reason = reason !== undefined ? reason : "";
                },
                Ice.UserException,
                "Glacier2::PermissionDeniedException",
                function(__os)
                {
                    __os.writeString(this.reason);
                },
                function(__is)
                {
                    this.reason = __is.readString();
                },
                true,
                false);
        
            /**
             * The Glacier2 permissions verifier. This is called through the
             * process of establishing a session.
             * 
             * @see Router
             * 
             **/
            Glacier2.PermissionsVerifier = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Glacier2::PermissionsVerifier",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.PermissionsVerifierPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.PermissionsVerifier.ice_staticId, undefined);
        
            Slice.defineOperations(Glacier2.PermissionsVerifier, Glacier2.PermissionsVerifierPrx,
            {
                "checkPermissions": [, 2, 1, , 2, [1], [[7], [7]], [[7]], 
                [
                    Glacier2.PermissionDeniedException
                ], , ]
            });
        
            /**
             * The SSL Glacier2 permissions verifier. This is called through the
             * process of establishing a session.
             * 
             * @see Router
             * 
             **/
            Glacier2.SSLPermissionsVerifier = Slice.defineObject(
                undefined,
                Ice.Object, undefined, 0,
                [
                    "::Glacier2::SSLPermissionsVerifier",
                    "::Ice::Object"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.SSLPermissionsVerifierPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.SSLPermissionsVerifier.ice_staticId, undefined);
        
            Slice.defineOperations(Glacier2.SSLPermissionsVerifier, Glacier2.SSLPermissionsVerifierPrx,
            {
                "authorize": [, 2, 1, , 2, [1], [[Glacier2.SSLInfo]], [[7]], 
                [
                    Glacier2.PermissionDeniedException
                ], , ]
            });
        
    }());

    (function()
    {
        // **********************************************************************
        //
        // Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
        //
        // This copy of Ice is licensed to you under the terms described in the
        // ICE_LICENSE file included in this distribution.
        //
        // **********************************************************************
        //
        // Ice version 3.6.2
        //
        // <auto-generated>
        //
        // Generated from file `Router.ice'
        //
        // Warning: do not edit this file.
        //
        // </auto-generated>
        //
        
        
            /**
             * This exception is raised if a client tries to destroy a session
             * with a router, but no session exists for the client.
             * 
             * @see Router#destroySession
             * 
             **/
            Glacier2.SessionNotExistException = Slice.defineUserException(
                function(_cause)
                {
                    Ice.UserException.call(this, _cause);
                },
                Ice.UserException,
                "Glacier2::SessionNotExistException",
                undefined, undefined,
                false,
                false);
        
            /**
             * The Glacier2 specialization of the {@link Ice.Router}
             * interface.
             * 
             **/
            Glacier2.Router = Slice.defineObject(
                undefined,
                Ice.Object,
                [
                    Ice.Router
                ], 0,
                [
                    "::Glacier2::Router",
                    "::Ice::Object",
                    "::Ice::Router"
                ],
                -1, undefined, undefined, false);
        
            Glacier2.RouterPrx = Slice.defineProxy(Ice.ObjectPrx, Glacier2.Router.ice_staticId, [
                Ice.RouterPrx]);
        
            Slice.defineOperations(Glacier2.Router, Glacier2.RouterPrx,
            {
                "getCategoryForClient": [, 2, 1, , , [7], , , , , ],
                "createSession": [, , , 1, 2, ["Glacier2.SessionPrx"], [[7], [7]], , 
                [
                    Glacier2.CannotCreateSessionException,
                    Glacier2.PermissionDeniedException
                ], , ],
                "createSessionFromSecureConnection": [, , , 1, 2, ["Glacier2.SessionPrx"], , , 
                [
                    Glacier2.CannotCreateSessionException,
                    Glacier2.PermissionDeniedException
                ], , ],
                "refreshSession": [, , , 1, , , , , 
                [
                    Glacier2.SessionNotExistException
                ], , ],
                "destroySession": [, , , , , , , , 
                [
                    Glacier2.SessionNotExistException
                ], , ],
                "getSessionTimeout": [, 2, 1, , , [4], , , , , ],
                "getACMTimeout": [, 2, 1, , , [3], , , , , ]
            });
        
    }());

    __root.Glacier2 = Glacier2;
}());


// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `Exception.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Slice = Ice.Slice;

    var Common = __M.module("Common");

    Common.ConferenceError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Ice.UserException.call(this, _cause);
            this.error = error !== undefined ? error : 0;
            this.reason = reason !== undefined ? reason : "";
        },
        Ice.UserException,
        "Common::ConferenceError",
        function(__os)
        {
            __os.writeInt(this.error);
            __os.writeString(this.reason);
        },
        function(__is)
        {
            this.error = __is.readInt();
            this.reason = __is.readString();
        },
        false,
        false);
    exports.Common = Common;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `MSPub.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Slice = Ice.Slice;

    var MS = __M.module("MS");

    MS.AudioTransType = Slice.defineEnum([
        ['ATT_CORP_PRIV', 0], ['ATT_EIS_ENCRYPT', 1], ['ATT_RTP_STD', 2], ['ATT_RTMP', 3]]);

    MS.AudioCodecType = Slice.defineEnum([
        ['ACT_PCMU', 0], ['ACT_PCMA', 1], ['ACT_G723', 2], ['ACT_G729', 3], ['ACT_AMRWB', 4],
        ['ACT_SPEEX', 5], ['ACT_AAC', 6], ['ACT_ISAC', 7], ['ACT_RESERV08', 8], ['ACT_RESERV09', 9],
        ['ACT_RESERV10', 10], ['ACT_RESERV11', 11], ['ACT_RESERV12', 12], ['ACT_RESERV13', 13], ['ACT_RESERV14', 14],
        ['ACT_NULL', 15]]);

    MS.MediaStreamIOMode = Slice.defineEnum([
        ['MSIO_INACTIVE', 0], ['MSIO_SEND', 1], ['MSIO_RECV', 2], ['MSIO_SEND_RECV', 3]]);

    MS.AudioStreamParam = Slice.defineStruct(
        function(codecType, transType, ioMode, mixerID, shareListen)
        {
            this.codecType = codecType !== undefined ? codecType : MS.AudioCodecType.ACT_PCMU;
            this.transType = transType !== undefined ? transType : MS.AudioTransType.ATT_CORP_PRIV;
            this.ioMode = ioMode !== undefined ? ioMode : MS.MediaStreamIOMode.MSIO_INACTIVE;
            this.mixerID = mixerID !== undefined ? mixerID : 0;
            this.shareListen = shareListen !== undefined ? shareListen : false;
        },
        true,
        function(__os)
        {
            MS.AudioCodecType.__write(__os, this.codecType);
            MS.AudioTransType.__write(__os, this.transType);
            MS.MediaStreamIOMode.__write(__os, this.ioMode);
            __os.writeInt(this.mixerID);
            __os.writeBool(this.shareListen);
        },
        function(__is)
        {
            this.codecType = MS.AudioCodecType.__read(__is);
            this.transType = MS.AudioTransType.__read(__is);
            this.ioMode = MS.MediaStreamIOMode.__read(__is);
            this.mixerID = __is.readInt();
            this.shareListen = __is.readBool();
        },
        8, 
        false);

    MS.VideoContentType = Slice.defineEnum([
        ['VCT_CAMERA', 0], ['VCT_SCREEN', 1], ['VCT_FILM', 2], ['VCT_LIVE', 3]]);

    MS.VideoStreamParam = Slice.defineStruct(
        function(contentType, srcTermID, cameraID, ioMode, attachToMSID, subscribeFlag, isPeerSourceTerm, screenAuthKey)
        {
            this.contentType = contentType !== undefined ? contentType : MS.VideoContentType.VCT_CAMERA;
            this.srcTermID = srcTermID !== undefined ? srcTermID : 0;
            this.cameraID = cameraID !== undefined ? cameraID : 0;
            this.ioMode = ioMode !== undefined ? ioMode : MS.MediaStreamIOMode.MSIO_INACTIVE;
            this.attachToMSID = attachToMSID !== undefined ? attachToMSID : 0;
            this.subscribeFlag = subscribeFlag !== undefined ? subscribeFlag : false;
            this.isPeerSourceTerm = isPeerSourceTerm !== undefined ? isPeerSourceTerm : false;
            this.screenAuthKey = screenAuthKey !== undefined ? screenAuthKey : "";
        },
        true,
        function(__os)
        {
            MS.VideoContentType.__write(__os, this.contentType);
            __os.writeShort(this.srcTermID);
            __os.writeShort(this.cameraID);
            MS.MediaStreamIOMode.__write(__os, this.ioMode);
            __os.writeInt(this.attachToMSID);
            __os.writeBool(this.subscribeFlag);
            __os.writeBool(this.isPeerSourceTerm);
            __os.writeString(this.screenAuthKey);
        },
        function(__is)
        {
            this.contentType = MS.VideoContentType.__read(__is);
            this.srcTermID = __is.readShort();
            this.cameraID = __is.readShort();
            this.ioMode = MS.MediaStreamIOMode.__read(__is);
            this.attachToMSID = __is.readInt();
            this.subscribeFlag = __is.readBool();
            this.isPeerSourceTerm = __is.readBool();
            this.screenAuthKey = __is.readString();
        },
        13, 
        false);

    MS.NetworkAddress = Slice.defineStruct(
        function(ip, port)
        {
            this.ip = ip !== undefined ? ip : "";
            this.port = port !== undefined ? port : 0;
        },
        true,
        function(__os)
        {
            __os.writeString(this.ip);
            __os.writeShort(this.port);
        },
        function(__is)
        {
            this.ip = __is.readString();
            this.port = __is.readShort();
        },
        3, 
        false);

    MS.MediaStreamAddr = Slice.defineStruct(
        function(netAddr, MSID)
        {
            this.netAddr = netAddr !== undefined ? netAddr : new MS.NetworkAddress();
            this.MSID = MSID !== undefined ? MSID : 0;
        },
        true,
        function(__os)
        {
            MS.NetworkAddress.write(__os, this.netAddr);
            __os.writeInt(this.MSID);
        },
        function(__is)
        {
            this.netAddr = MS.NetworkAddress.read(__is, this.netAddr);
            this.MSID = __is.readInt();
        },
        7, 
        false);

    MS.ConferenceInfo = Slice.defineStruct(
        function(confId, isPeerTerminal, peerTermId, peerTermName)
        {
            this.confId = confId !== undefined ? confId : 0;
            this.isPeerTerminal = isPeerTerminal !== undefined ? isPeerTerminal : false;
            this.peerTermId = peerTermId !== undefined ? peerTermId : 0;
            this.peerTermName = peerTermName !== undefined ? peerTermName : "";
        },
        true,
        function(__os)
        {
            __os.writeInt(this.confId);
            __os.writeBool(this.isPeerTerminal);
            __os.writeShort(this.peerTermId);
            __os.writeString(this.peerTermName);
        },
        function(__is)
        {
            this.confId = __is.readInt();
            this.isPeerTerminal = __is.readBool();
            this.peerTermId = __is.readShort();
            this.peerTermName = __is.readString();
        },
        8, 
        false);
    Slice.defineDictionary(MS, "DictStrParams", "DictStrParamsHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);
    exports.MS = MS;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `MSClient.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var MS = require("Trans/MSPub").MS;
    var Slice = Ice.Slice;

    MS.LanTerm = Slice.defineStruct(
        function(hostIP, termID)
        {
            this.hostIP = hostIP !== undefined ? hostIP : "";
            this.termID = termID !== undefined ? termID : 0;
        },
        true,
        function(__os)
        {
            __os.writeString(this.hostIP);
            __os.writeShort(this.termID);
        },
        function(__is)
        {
            this.hostIP = __is.readString();
            this.termID = __is.readShort();
        },
        3, 
        false);
    Slice.defineSequence(MS, "TermSeqHelper", "MS.LanTerm", false);

    MS.MSClient = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::MS::MSClient"
        ],
        -1, undefined, undefined, false);

    MS.MSClientPrx = Slice.defineProxy(Ice.ObjectPrx, MS.MSClient.ice_staticId, undefined);

    Slice.defineOperations(MS.MSClient, MS.MSClientPrx,
    {
        "AudioAllocRaw": [, , , 1, , [3], [[MS.AudioStreamParam]], , , , ],
        "AudioAlloc": [, , , 1, , [3], [[MS.AudioStreamParam], [MS.MediaStreamAddr]], , , , ],
        "VideoAllocRaw": [, , , 1, , [3], [[MS.VideoStreamParam], [1]], , , , ],
        "VideoAlloc": [, , , 1, , [3], [[MS.VideoStreamParam], [1], [MS.MediaStreamAddr]], , , , ],
        "AudioAllocRawExt": [, , , 1, , [3], [[MS.AudioStreamParam], ["MS.DictStrParamsHelper"]], , , , ],
        "AudioAllocRawExt2": [, , , 1, , [3], [[MS.AudioStreamParam], ["MS.DictStrParamsHelper"]], [["MS.DictStrParamsHelper"]], , , ],
        "AudioAllocExt": [, , , 1, , [3], [[MS.AudioStreamParam], [MS.MediaStreamAddr], ["MS.DictStrParamsHelper"]], , , , ],
        "VideoAllocRawExt": [, , , 1, , [3], [[MS.VideoStreamParam], [1], ["MS.DictStrParamsHelper"]], , , , ],
        "VideoAllocRawExt2": [, , , 1, , [3], [[MS.VideoStreamParam], [1], ["MS.DictStrParamsHelper"]], [["MS.DictStrParamsHelper"]], , , ],
        "VideoAllocExt": [, , , 1, , [3], [[MS.VideoStreamParam], [1], [MS.MediaStreamAddr], ["MS.DictStrParamsHelper"]], , , , ],
        "Free": [, , , 1, , , [[3]], , , , ],
        "ModifyPeerAddr": [, , , 1, , , [[3], [MS.MediaStreamAddr]], , , , ],
        "ModifyPeerAddrExt": [, , , 1, , , [[3], ["MS.DictStrParamsHelper"]], , , , ],
        "ModifyIOMode": [, , , 1, , , [[3], [MS.MediaStreamIOMode.__helper]], , , , ],
        "NotifyRTMPStreamPublishFinished": [, , , 1, , , [[3]], , , , ],
        "StartLanThrough": [, , , 1, , , [[3], [3], [7]], , , , ],
        "StopLanThrough": [, , , 1, , , [[3]], , , , ],
        "LanDetect": [, , , 1, , , [["MS.TermSeqHelper"]], , , , ],
        "EnableSendVideo2Internet": [, , , 1, , , [[2]], , , , ],
        "DisableSendVideo2Internet": [, , , 1, , , [[2]], , , , ],
        "EnableSendScreen2Internet": [, , , 1, , , , , , , ],
        "DisableSendScreen2Internet": [, , , 1, , , , , , , ],
        "EnableSendFilm2Internet": [, , , 1, , , , , , , ],
        "DisableSendFilm2Internet": [, , , 1, , , , , , , ],
        "EnableSendLive2Internet": [, , , 1, , , , , , , ],
        "DisableSendLive2Internet": [, , , 1, , , , , , , ]
    });

    MS.ClientReport = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::MS::ClientReport"
        ],
        -1, undefined, undefined, false);

    MS.ClientReportPrx = Slice.defineProxy(Ice.ObjectPrx, MS.ClientReport.ice_staticId, undefined);

    Slice.defineOperations(MS.ClientReport, MS.ClientReportPrx,
    {
        "UpdateClientIP": [, , , 1, , , [[7], [3], [7]], , , , ],
        "ReportLanNeighbor": [, , , 1, , , [["MS.TermSeqHelper"]], , , , ],
        "LanMediaStreamFail": [, , , 1, , , [[3], [3], [7]], , , , ]
    });
    exports.MS = MS;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `sendcmd.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Slice = Ice.Slice;

    var SendCmd = __M.module("SendCmd");

    SendCmd.CmdError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Ice.UserException.call(this, _cause);
            this.error = error !== undefined ? error : 0;
            this.reason = reason !== undefined ? reason : "";
        },
        Ice.UserException,
        "SendCmd::CmdError",
        function(__os)
        {
            __os.writeInt(this.error);
            __os.writeString(this.reason);
        },
        function(__is)
        {
            this.error = __is.readInt();
            this.reason = __is.readString();
        },
        false,
        false);

    SendCmd.UnknowErr = Slice.defineUserException(
        function(error, reason, _cause)
        {
            SendCmd.CmdError.call(this, error, reason, _cause);
        },
        SendCmd.CmdError,
        "SendCmd::UnknowErr",
        undefined, undefined,
        false,
        false);

    SendCmd.CmdNotFound = Slice.defineUserException(
        function(error, reason, _cause)
        {
            SendCmd.CmdError.call(this, error, reason, _cause);
        },
        SendCmd.CmdError,
        "SendCmd::CmdNotFound",
        undefined, undefined,
        false,
        false);

    SendCmd.CmdNotImplement = Slice.defineUserException(
        function(error, reason, _cause)
        {
            SendCmd.CmdError.call(this, error, reason, _cause);
        },
        SendCmd.CmdError,
        "SendCmd::CmdNotImplement",
        undefined, undefined,
        false,
        false);

    SendCmd.AppException = Slice.defineUserException(
        function(error, reason, _cause)
        {
            SendCmd.CmdError.call(this, error, reason, _cause);
        },
        SendCmd.CmdError,
        "SendCmd::AppException",
        undefined, undefined,
        false,
        false);

    SendCmd.AppReturnInvalid = Slice.defineUserException(
        function(error, reason, _cause)
        {
            SendCmd.CmdError.call(this, error, reason, _cause);
        },
        SendCmd.CmdError,
        "SendCmd::AppReturnInvalid",
        undefined, undefined,
        false,
        false);

    SendCmd.SessionInvalid = Slice.defineUserException(
        function(error, reason, _cause)
        {
            SendCmd.CmdError.call(this, error, reason, _cause);
        },
        SendCmd.CmdError,
        "SendCmd::SessionInvalid",
        undefined, undefined,
        false,
        false);

    SendCmd.Cmd = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::SendCmd::Cmd"
        ],
        -1, undefined, undefined, false);

    SendCmd.CmdPrx = Slice.defineProxy(Ice.ObjectPrx, SendCmd.Cmd.ice_staticId, undefined);

    Slice.defineOperations(SendCmd.Cmd, SendCmd.CmdPrx,
    {
        "sendCmd": [, , , , , [7], [[7]], , 
        [
            SendCmd.CmdError
        ], , ],
        "sendBuffer": [, , , , , [7], [[7], ["Ice.ByteSeqHelper"]], , 
        [
            SendCmd.CmdError
        ], , ]
    });
    exports.SendCmd = SendCmd;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `Contact.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Slice = Ice.Slice;

    var Conference = __M.module("Conference");

    Object.defineProperty(Conference, 'CT_USER', {
        value: 1
    });

    Object.defineProperty(Conference, 'CT_CONTACT', {
        value: 2
    });

    Object.defineProperty(Conference, 'CT_TMP', {
        value: 3
    });

    Object.defineProperty(Conference, 'CT_CLIENT', {
        value: 6
    });

    Object.defineProperty(Conference, 'CT_VIRTUAL', {
        value: 7
    });

    Conference.Contact = Slice.defineStruct(
        function(id, type, nickname, email, mobile, confPhone)
        {
            this.id = id !== undefined ? id : 0;
            this.type = type !== undefined ? type : 0;
            this.nickname = nickname !== undefined ? nickname : "";
            this.email = email !== undefined ? email : "";
            this.mobile = mobile !== undefined ? mobile : "";
            this.confPhone = confPhone !== undefined ? confPhone : "";
        },
        true,
        function(__os)
        {
            __os.writeInt(this.id);
            __os.writeByte(this.type);
            __os.writeString(this.nickname);
            __os.writeString(this.email);
            __os.writeString(this.mobile);
            __os.writeString(this.confPhone);
        },
        function(__is)
        {
            this.id = __is.readInt();
            this.type = __is.readByte();
            this.nickname = __is.readString();
            this.email = __is.readString();
            this.mobile = __is.readString();
            this.confPhone = __is.readString();
        },
        9, 
        false);

    Conference.ContactIdType = Slice.defineStruct(
        function(id, type)
        {
            this.id = id !== undefined ? id : 0;
            this.type = type !== undefined ? type : 0;
        },
        true,
        function(__os)
        {
            __os.writeInt(this.id);
            __os.writeByte(this.type);
        },
        function(__is)
        {
            this.id = __is.readInt();
            this.type = __is.readByte();
        },
        5, 
        true);
    Slice.defineSequence(Conference, "ContactSeqHelper", "Conference.Contact", false);
    Slice.defineSequence(Conference, "ContactIdSeqHelper", "Conference.ContactIdType", true);
    Slice.defineDictionary(Conference, "ContactTree", "ContactTreeHelper", "Ice.StringHelper", "Conference.ContactSeqHelper", false, undefined, undefined, Ice.ArrayUtil.equals);
    exports.Conference = Conference;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `PublicTypes.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Common = require("Common/Exception").Common;
    var Slice = Ice.Slice;

    var Conference = __M.module("Conference");

    Object.defineProperty(Conference, 'SLICE_VER', {
        value: "1.6"
    });

    Object.defineProperty(Conference, 'ANON_TERMID', {
        value: 0
    });

    Object.defineProperty(Conference, 'ALL_TERMID', {
        value: 32767
    });

    Object.defineProperty(Conference, 'ANON_MEMBER_ID', {
        value: 0
    });

    Object.defineProperty(Conference, 'TERM_PC', {
        value: 1
    });

    Object.defineProperty(Conference, 'TERM_PHONE', {
        value: 2
    });

    Object.defineProperty(Conference, 'NORMAL_AT', {
        value: 0
    });

    Object.defineProperty(Conference, 'DEMO_AT', {
        value: 1
    });

    Object.defineProperty(Conference, 'HOST_AT', {
        value: 2
    });

    Object.defineProperty(Conference, 'PSTN_HOST_AT', {
        value: 4
    });

    Object.defineProperty(Conference, 'ASSISTANT_AT', {
        value: 8
    });

    Object.defineProperty(Conference, 'OPT_VIDEO', {
        value: 1
    });

    Object.defineProperty(Conference, 'OPT_AUTO_MUTE', {
        value: 2
    });

    Object.defineProperty(Conference, 'OPT_AUTO_AUDIO', {
        value: 4
    });

    Object.defineProperty(Conference, 'OPT_PSTN_CALL', {
        value: 8
    });

    Object.defineProperty(Conference, 'OPT_END_WHEN_HOST_EXIT', {
        value: 16
    });

    Object.defineProperty(Conference, 'OPT_ONLY_INVITE_CAN_LOGIN', {
        value: 32
    });

    Object.defineProperty(Conference, 'OPT_ALLOW_PLAY_APPLAUSE', {
        value: 64
    });

    Object.defineProperty(Conference, 'OPT_PLAY_ENTRANCEANDEXITTONE', {
        value: 128
    });

    Object.defineProperty(Conference, 'OPT_ALLOW_MODIFY_NICKNAME', {
        value: 256
    });

    Object.defineProperty(Conference, 'OPT_NOT_SEE_EACH_OTHER', {
        value: 512
    });

    Object.defineProperty(Conference, 'OPT_IM_FORBID_PIC', {
        value: 1024
    });

    Object.defineProperty(Conference, 'OPT_IM_FORBID_URL', {
        value: 2048
    });

    Object.defineProperty(Conference, 'OPT_FORBID_OPEN_CAMERA', {
        value: 4096
    });

    Object.defineProperty(Conference, 'OPT_AUTO_MUTE_HOST', {
        value: 8192
    });

    Object.defineProperty(Conference, 'OPT_REVIEW_CHAT', {
        value: 16384
    });
    Slice.defineSequence(Conference, "ByteListHelper", "Ice.ByteHelper", true);
    Slice.defineDictionary(Conference, "StringStringMap", "StringStringMapHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);

    Conference.ASTATUS = Slice.defineEnum([
        ['AUNKNOWN', 0], ['ANULL', 1], ['ACLOSE', 2], ['AOPEN', 3], ['AOPENING', 4]]);

    Conference.WINDOW_MODE = Slice.defineEnum([
        ['VMANAGER_LOCK', 0], ['VSPEAKER_TRACK', 1], ['VPRESENTER_LOCK', 2]]);

    Conference.VSTATUS = Slice.defineEnum([
        ['VUNKNOWN', 0], ['VNULL', 1], ['VCLOSE', 2], ['VOPEN', 3], ['VOPENING', 4]]);

    Conference.VIDEOLEVEL = Slice.defineEnum([
        ['VL_HIGH_HD', 0], ['VL_HIGH_HDL', 1], ['VL_HIGH_H', 2], ['VL_HIGH_M', 3], ['VL_HIGH_L', 4],
        ['VL_MID', 5], ['VL_LOW', 6]]);

    Conference.VideoSize = Slice.defineStruct(
        function(w, h)
        {
            this.w = w !== undefined ? w : 0;
            this.h = h !== undefined ? h : 0;
        },
        true,
        function(__os)
        {
            __os.writeShort(this.w);
            __os.writeShort(this.h);
        },
        function(__is)
        {
            this.w = __is.readShort();
            this.h = __is.readShort();
        },
        4, 
        true);

    Conference.VideoQuality = Slice.defineStruct(
        function(vl, vs, isec, fps, crf, cost)
        {
            this.vl = vl !== undefined ? vl : Conference.VIDEOLEVEL.VL_HIGH_HD;
            this.vs = vs !== undefined ? vs : new Conference.VideoSize();
            this.isec = isec !== undefined ? isec : 0;
            this.fps = fps !== undefined ? fps : null;
            this.crf = crf !== undefined ? crf : null;
            this.cost = cost !== undefined ? cost : "";
        },
        true,
        function(__os)
        {
            Conference.VIDEOLEVEL.__write(__os, this.vl);
            Conference.VideoSize.write(__os, this.vs);
            __os.writeByte(this.isec);
            Ice.ByteSeqHelper.write(__os, this.fps);
            Ice.ByteSeqHelper.write(__os, this.crf);
            __os.writeString(this.cost);
        },
        function(__is)
        {
            this.vl = Conference.VIDEOLEVEL.__read(__is);
            this.vs = Conference.VideoSize.read(__is, this.vs);
            this.isec = __is.readByte();
            this.fps = Ice.ByteSeqHelper.read(__is);
            this.crf = Ice.ByteSeqHelper.read(__is);
            this.cost = __is.readString();
        },
        9, 
        false);

    Conference.VIDEOLAYOUTMODE = Slice.defineEnum([
        ['VLO_1v1_M', 0], ['VLO_WALL1_M', 1], ['VLO_WALL2', 2], ['VLO_WALL4', 3], ['VLO_WALL5_M', 4],
        ['VLO_WALL6_M', 5], ['VLO_WALL9', 6], ['VLO_WALL13_M', 7], ['VLO_WALL16', 8], ['VLO_WALL25', 9]]);

    Object.defineProperty(Conference, 'MVM_1MAIN', {
        value: 0
    });

    Object.defineProperty(Conference, 'MVM_1v1', {
        value: 1
    });

    Object.defineProperty(Conference, 'MVM_2VIDEO', {
        value: 2
    });

    Object.defineProperty(Conference, 'MVM_4VIDEO', {
        value: 3
    });

    Object.defineProperty(Conference, 'MVM_6VIDEO', {
        value: 4
    });

    Object.defineProperty(Conference, 'VIDEO_SS_1M', {
        value: 0
    });

    Object.defineProperty(Conference, 'VIDEO_SS_5M', {
        value: 1
    });

    Object.defineProperty(Conference, 'VIDEO_SS_13M', {
        value: 2
    });

    Object.defineProperty(Conference, 'VIDEO_SS_2', {
        value: 3
    });

    Object.defineProperty(Conference, 'VIDEO_SS_4', {
        value: 4
    });

    Object.defineProperty(Conference, 'VIDEO_SS_9', {
        value: 5
    });

    Object.defineProperty(Conference, 'VIDEO_SS_16', {
        value: 6
    });

    Object.defineProperty(Conference, 'VIDEO_SS_25', {
        value: 7
    });

    Object.defineProperty(Conference, 'VIDEO_SS_NULL', {
        value: 255
    });
    Slice.defineSequence(Conference, "VideoQualitySeqHelper", "Conference.VideoQuality", false);

    Conference.SYNCMODE = Slice.defineEnum([
        ['SYNC_FORCE', 0], ['SYNC_FREE', 1]]);

    Conference.TabID = Slice.defineStruct(
        function(termID, localID)
        {
            this.termID = termID !== undefined ? termID : 0;
            this.localID = localID !== undefined ? localID : 0;
        },
        true,
        function(__os)
        {
            __os.writeShort(this.termID);
            __os.writeShort(this.localID);
        },
        function(__is)
        {
            this.termID = __is.readShort();
            this.localID = __is.readShort();
        },
        4, 
        true);
    Slice.defineSequence(Conference, "TabIDSeqHelper", "Conference.TabID", true);

    Conference.WBBOARD_TYPE = Slice.defineEnum([
        ['WB_WHITE', 0], ['WB_DOC', 1]]);

    Conference.WBBOARD_DOCTYPE = Slice.defineEnum([
        ['WD_IMG', 0], ['WD_PPTANIM', 1], ['WD_PPT', 2]]);

    Conference.WB_SCALE_TYPE = Slice.defineEnum([
        ['WB_SCALE_50', 0], ['WB_SCALE_100', 1], ['WB_SCALE_150', 2], ['WB_SCALE_200', 3], ['WB_SCALE_SADP', 4],
        ['WB_SCALE_WIDTH', 5]]);

    Conference.WB_ROTATE_TYPE = Slice.defineEnum([
        ['WB_ROTATE_0', 0], ['WB_ROTATE_90', 1], ['WB_ROTATE_180', 2], ['WB_ROTATE_270', 3]]);

    Conference.WhiteBoardDescribe = Slice.defineStruct(
        function(wID, wType, docType, name, docName, width, height, scaleType, rotation, pageCount, curPage, animID, animFrames, showThum, bAll, allowTerms)
        {
            this.wID = wID !== undefined ? wID : new Conference.TabID();
            this.wType = wType !== undefined ? wType : Conference.WBBOARD_TYPE.WB_WHITE;
            this.docType = docType !== undefined ? docType : Conference.WBBOARD_DOCTYPE.WD_IMG;
            this.name = name !== undefined ? name : "";
            this.docName = docName !== undefined ? docName : "";
            this.width = width !== undefined ? width : 0;
            this.height = height !== undefined ? height : 0;
            this.scaleType = scaleType !== undefined ? scaleType : Conference.WB_SCALE_TYPE.WB_SCALE_50;
            this.rotation = rotation !== undefined ? rotation : Conference.WB_ROTATE_TYPE.WB_ROTATE_0;
            this.pageCount = pageCount !== undefined ? pageCount : 0;
            this.curPage = curPage !== undefined ? curPage : 0;
            this.animID = animID !== undefined ? animID : 0;
            this.animFrames = animFrames !== undefined ? animFrames : 0;
            this.showThum = showThum !== undefined ? showThum : false;
            this.bAll = bAll !== undefined ? bAll : false;
            this.allowTerms = allowTerms !== undefined ? allowTerms : null;
        },
        true,
        function(__os)
        {
            Conference.TabID.write(__os, this.wID);
            Conference.WBBOARD_TYPE.__write(__os, this.wType);
            Conference.WBBOARD_DOCTYPE.__write(__os, this.docType);
            __os.writeString(this.name);
            __os.writeString(this.docName);
            __os.writeInt(this.width);
            __os.writeInt(this.height);
            Conference.WB_SCALE_TYPE.__write(__os, this.scaleType);
            Conference.WB_ROTATE_TYPE.__write(__os, this.rotation);
            __os.writeInt(this.pageCount);
            __os.writeInt(this.curPage);
            __os.writeInt(this.animID);
            __os.writeInt(this.animFrames);
            __os.writeBool(this.showThum);
            __os.writeBool(this.bAll);
            Ice.ShortSeqHelper.write(__os, this.allowTerms);
        },
        function(__is)
        {
            this.wID = Conference.TabID.read(__is, this.wID);
            this.wType = Conference.WBBOARD_TYPE.__read(__is);
            this.docType = Conference.WBBOARD_DOCTYPE.__read(__is);
            this.name = __is.readString();
            this.docName = __is.readString();
            this.width = __is.readInt();
            this.height = __is.readInt();
            this.scaleType = Conference.WB_SCALE_TYPE.__read(__is);
            this.rotation = Conference.WB_ROTATE_TYPE.__read(__is);
            this.pageCount = __is.readInt();
            this.curPage = __is.readInt();
            this.animID = __is.readInt();
            this.animFrames = __is.readInt();
            this.showThum = __is.readBool();
            this.bAll = __is.readBool();
            this.allowTerms = Ice.ShortSeqHelper.read(__is);
        },
        37, 
        false);
    Slice.defineSequence(Conference, "WhiteBoardDescribeSeqHelper", "Conference.WhiteBoardDescribe", false);
    exports.Conference = Conference;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `Member.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Common = require("Common/Exception").Common;
    var Conference = __M.require(module, 
    [
        "Control/PublicTypes",
        "Control/Contact"
    ]).Conference;
    
    var Slice = Ice.Slice;

    Object.defineProperty(Conference, 'ACNT_ADMIN', {
        value: 0
    });

    Object.defineProperty(Conference, 'ACNT_MEETCREATOR', {
        value: 1
    });

    Object.defineProperty(Conference, 'ACNT_PARTICIPANTS', {
        value: 2
    });

    Object.defineProperty(Conference, 'MINFO_ALLCAMS', {
        value: "allCams"
    });

    Object.defineProperty(Conference, 'MINFO_OPENEDCAMIDS', {
        value: "openedCamIDs"
    });

    Object.defineProperty(Conference, 'MINFO_ACNTTYPE', {
        value: "anctType"
    });

    Object.defineProperty(Conference, 'MINFO_WDTXDTYPE', {
        value: "WDTXDType"
    });

    Object.defineProperty(Conference, 'WDTXDTYPE_ADMIN', {
        value: "1"
    });

    Object.defineProperty(Conference, 'WDTXDTYPE_USER', {
        value: "2"
    });

    Object.defineProperty(Conference, 'MINFO_PSTNIVR', {
        value: "ivr"
    });

    Object.defineProperty(Conference, 'PSTNIVR_YES', {
        value: "1"
    });

    Object.defineProperty(Conference, 'MINFO_YDYUSERID', {
        value: "ydyuserid"
    });

    Conference.Member = Slice.defineStruct(
        function(termId, bindId, termType, nickname, actor, audioStatus, videoStatus, bEnableVideo, rights, contactId, phone, extProperty)
        {
            this.termId = termId !== undefined ? termId : 0;
            this.bindId = bindId !== undefined ? bindId : 0;
            this.termType = termType !== undefined ? termType : 0;
            this.nickname = nickname !== undefined ? nickname : "";
            this.actor = actor !== undefined ? actor : 0;
            this.audioStatus = audioStatus !== undefined ? audioStatus : Conference.ASTATUS.AUNKNOWN;
            this.videoStatus = videoStatus !== undefined ? videoStatus : Conference.VSTATUS.VUNKNOWN;
            this.bEnableVideo = bEnableVideo !== undefined ? bEnableVideo : false;
            this.rights = rights !== undefined ? rights : null;
            this.contactId = contactId !== undefined ? contactId : new Conference.ContactIdType();
            this.phone = phone !== undefined ? phone : "";
            this.extProperty = extProperty !== undefined ? extProperty : null;
        },
        false,
        function(__os)
        {
            __os.writeShort(this.termId);
            __os.writeShort(this.bindId);
            __os.writeByte(this.termType);
            __os.writeString(this.nickname);
            __os.writeByte(this.actor);
            Conference.ASTATUS.__write(__os, this.audioStatus);
            Conference.VSTATUS.__write(__os, this.videoStatus);
            __os.writeBool(this.bEnableVideo);
            Conference.ByteListHelper.write(__os, this.rights);
            Conference.ContactIdType.write(__os, this.contactId);
            __os.writeString(this.phone);
            Conference.StringStringMapHelper.write(__os, this.extProperty);
        },
        function(__is)
        {
            this.termId = __is.readShort();
            this.bindId = __is.readShort();
            this.termType = __is.readByte();
            this.nickname = __is.readString();
            this.actor = __is.readByte();
            this.audioStatus = Conference.ASTATUS.__read(__is);
            this.videoStatus = Conference.VSTATUS.__read(__is);
            this.bEnableVideo = __is.readBool();
            this.rights = Conference.ByteListHelper.read(__is);
            this.contactId = Conference.ContactIdType.read(__is, this.contactId);
            this.phone = __is.readString();
            this.extProperty = Conference.StringStringMapHelper.read(__is);
        },
        18, 
        false);
    Slice.defineSequence(Conference, "MemberSeqHelper", "Conference.Member", false);
    exports.Conference = Conference;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `Conference.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Common = require("Common/Exception").Common;
    var Conference = __M.require(module, 
    [
        "Control/Member",
        "Control/Contact",
        "Control/PublicTypes"
    ]).Conference;
    
    var Slice = Ice.Slice;

    Conference.ConfIdError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ConfIdError",
        undefined, undefined,
        false,
        false);

    Conference.AuthError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::AuthError",
        undefined, undefined,
        false,
        false);

    Conference.ReenterError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ReenterError",
        undefined, undefined,
        false,
        false);

    Conference.RoomLockedError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::RoomLockedError",
        undefined, undefined,
        false,
        false);

    Conference.NicknameError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::NicknameError",
        undefined, undefined,
        false,
        false);

    Conference.NicknameDuplicatedError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::NicknameDuplicatedError",
        undefined, undefined,
        false,
        false);

    Conference.NotPermitError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::NotPermitError",
        undefined, undefined,
        false,
        false);

    Conference.MemberDeactivedError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::MemberDeactivedError",
        undefined, undefined,
        false,
        false);

    Conference.MemberOverflowError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::MemberOverflowError",
        undefined, undefined,
        false,
        false);

    Conference.ConfMemberOverflowError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ConfMemberOverflowError",
        undefined, undefined,
        false,
        false);

    Conference.BalanceLessError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::BalanceLessError",
        undefined, undefined,
        false,
        false);

    Conference.KickoutSelfError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::KickoutSelfError",
        undefined, undefined,
        false,
        false);

    Conference.ConferenceEndError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ConferenceEndError",
        undefined, undefined,
        false,
        false);

    Conference.ConferenceBeginError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ConferenceBeginError",
        undefined, undefined,
        false,
        false);

    Conference.PINError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::PINError",
        undefined, undefined,
        false,
        false);

    Conference.FieldDuplicatedError = Slice.defineUserException(
        function(error, reason, name, value, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
            this.name = name !== undefined ? name : "";
            this.value = value !== undefined ? value : "";
        },
        Common.ConferenceError,
        "Conference::FieldDuplicatedError",
        function(__os)
        {
            __os.writeString(this.name);
            __os.writeString(this.value);
        },
        function(__is)
        {
            this.name = __is.readString();
            this.value = __is.readString();
        },
        false,
        false);

    Conference.InviteeNotFoundError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::InviteeNotFoundError",
        undefined, undefined,
        false,
        false);

    Conference.InviteeDuplicatedError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::InviteeDuplicatedError",
        undefined, undefined,
        false,
        false);

    Conference.InvalidTermTypeError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::InvalidTermTypeError",
        undefined, undefined,
        false,
        false);

    Conference.NoPSTNHostError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::NoPSTNHostError",
        undefined, undefined,
        false,
        false);

    Conference.ConferencePrepareError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ConferencePrepareError",
        undefined, undefined,
        false,
        false);

    Conference.ResourceAllocateError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ResourceAllocateError",
        undefined, undefined,
        false,
        false);

    Conference.OnlyInviteeCanLogin = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::OnlyInviteeCanLogin",
        undefined, undefined,
        false,
        false);

    Conference.MemberAlreadyInMeet = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::MemberAlreadyInMeet",
        undefined, undefined,
        false,
        false);

    Conference.MemberAlreadyInCanTryVisitor = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::MemberAlreadyInCanTryVisitor",
        undefined, undefined,
        false,
        false);

    Conference.MismatchClientVersion = Slice.defineUserException(
        function(error, reason, newVer, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
            this.newVer = newVer !== undefined ? newVer : "";
        },
        Common.ConferenceError,
        "Conference::MismatchClientVersion",
        function(__os)
        {
            __os.writeString(this.newVer);
        },
        function(__is)
        {
            this.newVer = __is.readString();
        },
        false,
        false);

    Conference.PeerHasBeen1v1SubMeeting = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::PeerHasBeen1v1SubMeeting",
        undefined, undefined,
        false,
        false);

    Conference.LiveStreamNotStart = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::LiveStreamNotStart",
        undefined, undefined,
        false,
        false);

    Conference.PstnHostCantLoginInWeb = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::PstnHostCantLoginInWeb",
        undefined, undefined,
        false,
        false);

    Conference.CannotBoradcast = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::CannotBoradcast",
        undefined, undefined,
        false,
        false);

    Conference.CannotInteractBoradcast = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::CannotInteractBoradcast",
        undefined, undefined,
        false,
        false);

    Conference.ConfCannotInteractBoradcast = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ConfCannotInteractBoradcast",
        undefined, undefined,
        false,
        false);

    Conference.ContainsSensitiveWords = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ContainsSensitiveWords",
        undefined, undefined,
        false,
        false);

    Conference.ThirdPartyLiveIsOn = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ThirdPartyLiveIsOn",
        undefined, undefined,
        false,
        false);

    Conference.ListLiveIsOn = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ListLiveIsOn",
        undefined, undefined,
        false,
        false);

    Conference.ClientLiveIsOn = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::ClientLiveIsOn",
        undefined, undefined,
        false,
        false);

    Conference.LuckyDrawNotExists = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::LuckyDrawNotExists",
        undefined, undefined,
        false,
        false);

    Conference.LuckyDrawCfgFails = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::LuckyDrawCfgFails",
        undefined, undefined,
        false,
        false);

    Conference.JoinLuckyDrawFails = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::JoinLuckyDrawFails",
        undefined, undefined,
        false,
        false);

    Conference.AnnouceLuckyDrawFails = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::AnnouceLuckyDrawFails",
        undefined, undefined,
        false,
        false);

    Conference.AnnouceLuckyDrawNoMember = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::AnnouceLuckyDrawNoMember",
        undefined, undefined,
        false,
        false);

    Conference.SeviceNotEnabled = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::SeviceNotEnabled",
        undefined, undefined,
        false,
        false);

    Object.defineProperty(Conference, 'SET_PSTN_NUM', {
        value: 1
    });

    Object.defineProperty(Conference, 'CALLED_PSTN_NUM', {
        value: 2
    });

    Object.defineProperty(Conference, 'BIND_PSTN_NUM', {
        value: 4
    });
    Slice.defineDictionary(Conference, "ModuleDict", "ModuleDictHelper", "Ice.StringHelper", "Ice.ObjectPrx", false, undefined, undefined);

    Object.defineProperty(Conference, 'CLIENT_SLICE_VER', {
        value: "slice_ver"
    });

    Object.defineProperty(Conference, 'CLINET_PCID', {
        value: "client_pcid"
    });

    Object.defineProperty(Conference, 'CLINET_MACADDR', {
        value: "client_macaddr"
    });

    Object.defineProperty(Conference, 'CLINET_LANGUAGE', {
        value: "client_lang"
    });

    Object.defineProperty(Conference, 'CLINET_VER', {
        value: "client_ver"
    });

    Object.defineProperty(Conference, 'CLINET_SDK_VER', {
        value: "sdk_ver"
    });

    Object.defineProperty(Conference, 'CLINET_ISWIFI', {
        value: "client_iswifi"
    });

    Object.defineProperty(Conference, 'CLINET_PLATFORM', {
        value: "client_platform"
    });

    Object.defineProperty(Conference, 'CLINET_PRODUCTTYPE', {
        value: "client_pdType"
    });

    Object.defineProperty(Conference, 'CLINET_DEVICETYPE', {
        value: "client_device"
    });

    Object.defineProperty(Conference, 'CLIENT_BRIDGETYPE', {
        value: "bridgeType"
    });

    Object.defineProperty(Conference, 'CLIENT_INVITECODE', {
        value: "invite_code"
    });

    Object.defineProperty(Conference, 'CLIENT_PHONENUM', {
        value: "phone_num"
    });

    Object.defineProperty(Conference, 'CLIENT_ISCUSTOMERSERVICE', {
        value: "is_cs"
    });

    Object.defineProperty(Conference, 'CLIENT_PRIV_ID', {
        value: "priv_id"
    });

    Object.defineProperty(Conference, 'CLIETN_PRIV_DAT', {
        value: "priv_dat"
    });

    Object.defineProperty(Conference, 'CLINET_LOGIN_TIMESTAMP', {
        value: "client_time"
    });

    Object.defineProperty(Conference, 'CLINET_IS_WEB_VIEWER', {
        value: "webview"
    });

    Object.defineProperty(Conference, 'CLINET_LIVEAUDIO', {
        value: "liveAudio"
    });

    Object.defineProperty(Conference, 'CLINET_OPENID', {
        value: "openId"
    });

    Object.defineProperty(Conference, 'CLIENT_ACODEC', {
        value: "acodec"
    });

    Object.defineProperty(Conference, 'CLIENT_LIVE_TYPE', {
        value: "livetype"
    });

    Object.defineProperty(Conference, 'CLIENT_LIVE_MOBILE', {
        value: "livemobile"
    });

    Object.defineProperty(Conference, 'CLINET_BROWSER_INFO', {
        value: "browser"
    });

    Object.defineProperty(Conference, 'CLINET_VP8_SUPPORT', {
        value: "vp8"
    });

    Object.defineProperty(Conference, 'CLINET_WEBRTC_CODECS', {
        value: "rtc_codecs"
    });

    Object.defineProperty(Conference, 'PLATFORMTYPE_WIN32', {
        value: "win32"
    });

    Object.defineProperty(Conference, 'PLATFORMTYPE_IOS', {
        value: "ios"
    });

    Object.defineProperty(Conference, 'PLATFORMTYPE_ANDROID', {
        value: "android"
    });

    Object.defineProperty(Conference, 'PLATFORMTYPE_LINUX', {
        value: "linux"
    });

    Object.defineProperty(Conference, 'PLATFORMTYPE_MAC', {
        value: "mac"
    });

    Object.defineProperty(Conference, 'PDTYPE_TVNETMEETING', {
        value: "net_tv"
    });

    Object.defineProperty(Conference, 'PDTYPE_NETMEETING', {
        value: "net"
    });

    Object.defineProperty(Conference, 'PDTYPE_PSTNMEETING', {
        value: "pstn"
    });

    Object.defineProperty(Conference, 'PDTYPE_LIVE', {
        value: "live"
    });

    Object.defineProperty(Conference, 'PDTYPE_MCU', {
        value: "mcu"
    });

    Object.defineProperty(Conference, 'DEVICETYPE_PC', {
        value: "pc"
    });

    Object.defineProperty(Conference, 'DEVICETYPE_PAD', {
        value: "pad"
    });

    Object.defineProperty(Conference, 'DEVICETYPE_PHONE', {
        value: "phone"
    });

    Object.defineProperty(Conference, 'DEVICETYPE_FLASH', {
        value: "flash"
    });

    Object.defineProperty(Conference, 'DEVICETYPE_MCU', {
        value: "mcu"
    });

    Object.defineProperty(Conference, 'DEVICETYPE_BOX', {
        value: "box"
    });

    Object.defineProperty(Conference, 'DEVICETYPE_SIPGATEWAY', {
        value: "sipgateway"
    });

    Object.defineProperty(Conference, 'DEVICETYPE_WEBRTC', {
        value: "webrtc"
    });

    Object.defineProperty(Conference, 'BRIDGETYPE_MONITOR', {
        value: "monitor"
    });

    Object.defineProperty(Conference, 'BRIDGETYPE_MEETING', {
        value: "meeting"
    });

    Object.defineProperty(Conference, 'MEETINGMODE_NORMAL', {
        value: "normal"
    });

    Object.defineProperty(Conference, 'MEETINGMODE_CONSULTATION', {
        value: "consultation"
    });

    Object.defineProperty(Conference, 'ACODEC_ISAC', {
        value: "isac"
    });

    Object.defineProperty(Conference, 'LIVETYPE_WEIXIN', {
        value: "0"
    });

    Object.defineProperty(Conference, 'LIVETYPE_USER', {
        value: "1"
    });

    Object.defineProperty(Conference, 'LIVETYPE_OTHER', {
        value: "2"
    });

    Conference.LoginRequest = Slice.defineStruct(
        function(confId, confKey, termId, memberId, memberType, nickname, callbacks, accessNo, publicIP, localIP, localMask, extProperty)
        {
            this.confId = confId !== undefined ? confId : 0;
            this.confKey = confKey !== undefined ? confKey : "";
            this.termId = termId !== undefined ? termId : 0;
            this.memberId = memberId !== undefined ? memberId : 0;
            this.memberType = memberType !== undefined ? memberType : 0;
            this.nickname = nickname !== undefined ? nickname : "";
            this.callbacks = callbacks !== undefined ? callbacks : null;
            this.accessNo = accessNo !== undefined ? accessNo : 0;
            this.publicIP = publicIP !== undefined ? publicIP : "";
            this.localIP = localIP !== undefined ? localIP : "";
            this.localMask = localMask !== undefined ? localMask : "";
            this.extProperty = extProperty !== undefined ? extProperty : null;
        },
        false,
        function(__os)
        {
            __os.writeInt(this.confId);
            __os.writeString(this.confKey);
            __os.writeShort(this.termId);
            __os.writeInt(this.memberId);
            __os.writeByte(this.memberType);
            __os.writeString(this.nickname);
            Conference.ModuleDictHelper.write(__os, this.callbacks);
            __os.writeInt(this.accessNo);
            __os.writeString(this.publicIP);
            __os.writeString(this.localIP);
            __os.writeString(this.localMask);
            Conference.StringStringMapHelper.write(__os, this.extProperty);
        },
        function(__is)
        {
            this.confId = __is.readInt();
            this.confKey = __is.readString();
            this.termId = __is.readShort();
            this.memberId = __is.readInt();
            this.memberType = __is.readByte();
            this.nickname = __is.readString();
            this.callbacks = Conference.ModuleDictHelper.read(__is);
            this.accessNo = __is.readInt();
            this.publicIP = __is.readString();
            this.localIP = __is.readString();
            this.localMask = __is.readString();
            this.extProperty = Conference.StringStringMapHelper.read(__is);
        },
        22, 
        false);

    Conference.FileServerInfo = Slice.defineStruct(
        function(fsProxy, key)
        {
            this.fsProxy = fsProxy !== undefined ? fsProxy : "";
            this.key = key !== undefined ? key : "";
        },
        true,
        function(__os)
        {
            __os.writeString(this.fsProxy);
            __os.writeString(this.key);
        },
        function(__is)
        {
            this.fsProxy = __is.readString();
            this.key = __is.readString();
        },
        2, 
        false);

    Conference.REC_STATE = Slice.defineEnum([
        ['NO_RECORD', 0], ['STARTING', 1], ['RECORDING', 2], ['PAUSED', 3], ['STOPPING', 4]]);
    Slice.defineSequence(Conference, "FileServerSeqHelper", "Conference.FileServerInfo", false);

    Object.defineProperty(Conference, 'INVALID_COUNTDOWN', {
        value: -1
    });

    Object.defineProperty(Conference, 'CONFINFO_HOSTPWD', {
        value: "hostpwd"
    });

    Object.defineProperty(Conference, 'CONFINFO_CONFPWD', {
        value: "confpwd"
    });

    Object.defineProperty(Conference, 'CONFINFO_SCHEDULETIME', {
        value: "scheduletime"
    });

    Object.defineProperty(Conference, 'CONFINFO_SUBJECT', {
        value: "subject"
    });

    Object.defineProperty(Conference, 'CONFINFO_URL', {
        value: "url"
    });

    Object.defineProperty(Conference, 'CONFINFO_URLPIC', {
        value: "urlpic"
    });

    Object.defineProperty(Conference, 'CONFINFO_PSTNNUM', {
        value: "pstnnum"
    });

    Object.defineProperty(Conference, 'CONFINFO_PSTNPWD', {
        value: "pstnpwd"
    });

    Object.defineProperty(Conference, 'CONFINFO_AGENDA', {
        value: "agenda"
    });

    Object.defineProperty(Conference, 'CONFINFO_SUPPORT_VLIST', {
        value: "vlist"
    });

    Object.defineProperty(Conference, 'CONFINFO_ROOM_SIZETYPE', {
        value: "roomsizetype"
    });

    Object.defineProperty(Conference, 'CONFINFO_ISTEST', {
        value: "istest"
    });

    Object.defineProperty(Conference, 'CONFINFO_ISDEMO', {
        value: "isdemo"
    });

    Object.defineProperty(Conference, 'CONFINFO_HOTLINE', {
        value: "hotline"
    });

    Object.defineProperty(Conference, 'CONFINFO_ISFIX', {
        value: "isfixed"
    });

    Object.defineProperty(Conference, 'CONFINFO_HD', {
        value: "hd"
    });

    Object.defineProperty(Conference, 'CONFINFO_PSTNNOTICE', {
        value: "pstnnotice"
    });

    Object.defineProperty(Conference, 'CONFINFO_FUNC_VIDEOWALL', {
        value: "videowall"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEO_ENABLE', {
        value: "video"
    });

    Object.defineProperty(Conference, 'CONFINFO_SHOW_MAIN_AD', {
        value: "main_ad"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEO_MONITOR', {
        value: "vmonitor"
    });

    Object.defineProperty(Conference, 'CONFINFO_USE_PHONE', {
        value: "use_phone"
    });

    Object.defineProperty(Conference, 'CONFINFO_INVITE', {
        value: "invite"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEO_LUBO', {
        value: "lubo"
    });

    Object.defineProperty(Conference, 'CONFINFO_MEDIA_PLAY', {
        value: "media_play"
    });

    Object.defineProperty(Conference, 'CONFINFO_MULTI_CAMERAS', {
        value: "multiple_cameras"
    });

    Object.defineProperty(Conference, 'CONFINFO_SUPPORT_BRIDGE', {
        value: "bridge"
    });

    Object.defineProperty(Conference, 'CONFINFO_SCREEN_SHARE', {
        value: "screen_share"
    });

    Object.defineProperty(Conference, 'CONFINFO_DOCUMENT_SHOW', {
        value: "document_show"
    });

    Object.defineProperty(Conference, 'CONFINFO_WHITE_BOARD', {
        value: "whiteboard"
    });

    Object.defineProperty(Conference, 'CONFINFO_ANSWER_QUESTION', {
        value: "answer_question"
    });

    Object.defineProperty(Conference, 'CONFINFO_FILE_SHARE', {
        value: "file_share"
    });

    Object.defineProperty(Conference, 'CONFINFO_MEETING_INFO', {
        value: "meeting_info"
    });

    Object.defineProperty(Conference, 'CONFINFO_OMNIDIRECTIONAL_MIC', {
        value: "omnidirectional_mic"
    });

    Object.defineProperty(Conference, 'CONFINFO_MEET_MODE', {
        value: "meeting_mode"
    });

    Object.defineProperty(Conference, 'CONFINFO_USER_ROLE', {
        value: "user_role"
    });

    Object.defineProperty(Conference, 'CONFINFO_COMPANY_ID', {
        value: "compid"
    });

    Object.defineProperty(Conference, 'CONFINFO_USER_NETDISK_ENABLE', {
        value: "user_net_disk"
    });

    Object.defineProperty(Conference, 'CONFINFO_COMP_NETDISK_ENABLE', {
        value: "comp_net_disk"
    });

    Object.defineProperty(Conference, 'CONFINFO_FREECONF', {
        value: "freeconf"
    });

    Object.defineProperty(Conference, 'CONFINFO_MAINVIDEO_SHOWMODE', {
        value: "main_svm"
    });

    Object.defineProperty(Conference, 'CONFINFO_IS_BROADCATING', {
        value: "rtmpliveon"
    });

    Object.defineProperty(Conference, 'CONFINFO_WEBVIEWER_NUM', {
        value: "webviewer_num"
    });

    Object.defineProperty(Conference, 'CONFINFO_WEBVIEWER_RIGHTS', {
        value: "webviewer_rights"
    });

    Object.defineProperty(Conference, 'CONFINFO_WEBVIEWER_QUES', {
        value: "webviewer_ques"
    });

    Object.defineProperty(Conference, 'CONFINFO_BROADCAST_DURATION', {
        value: "rtmplivetm"
    });

    Object.defineProperty(Conference, 'CONFINFO_WB_CONTAINERSIZE', {
        value: "wb_container"
    });

    Object.defineProperty(Conference, 'CONFINFO_H264_PROFILE', {
        value: "h264profile"
    });

    Object.defineProperty(Conference, 'CONFINFO_H264_NOCABAC', {
        value: "h264nocabac"
    });

    Object.defineProperty(Conference, 'CONFINFO_H264_SLICEMAXSZ', {
        value: "h264slicemaxsz"
    });

    Object.defineProperty(Conference, 'CONFINFO_H264_IFRAME', {
        value: "h264iframe"
    });

    Object.defineProperty(Conference, 'CONFINFO_H264_NOHARDCODING', {
        value: "h264nohardcoding"
    });

    Object.defineProperty(Conference, 'CONFINFO_SCREEN_ENCTYPE', {
        value: "screenenctype"
    });

    Object.defineProperty(Conference, 'CONFINFO_H264_PICMAXSIZE', {
        value: "h264picmaxsize"
    });

    Object.defineProperty(Conference, 'CONFINFO_SUPPORT_SIP', {
        value: "is_sip"
    });

    Object.defineProperty(Conference, 'CONFINFO_LIVE_CONFIG', {
        value: "livecfg"
    });

    Object.defineProperty(Conference, 'CONFINFO_SRV_RECORDSTATE', {
        value: "srv_record_state"
    });

    Object.defineProperty(Conference, 'CONFINFO_SRV_RECORDCFG', {
        value: "srv_record_cfg"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEO_VPU_SUPPORT_ENC', {
        value: "vpu_support_enc"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEO_VPU_SUPPORT_DEC', {
        value: "vpu_supportd_dec"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEO_VPU_UNSUPPORT_ENC_DEV', {
        value: "vpu_unsupport_enc_dev"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEO_VPU_UNSUPPORT_DEC_DEV', {
        value: "vpu_unsupport_dec_dev"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEOLIST_MODE', {
        value: "vlistmode"
    });

    Object.defineProperty(Conference, 'CONFINFO_VIDEOLIST_CAMS', {
        value: "vlistcams"
    });

    Object.defineProperty(Conference, 'CONFINFO_MAX_VIDEOUIS', {
        value: "maxvuis"
    });

    Object.defineProperty(Conference, 'CONFINFO_UI_LOCKSTATUS', {
        value: "uilock"
    });

    Object.defineProperty(Conference, 'CONFINFO_SRV_RECORD', {
        value: "srv_record"
    });

    Object.defineProperty(Conference, 'CONFINFO_SHOW_LIVE', {
        value: "show_live"
    });

    Object.defineProperty(Conference, 'CONFINFO_SIGNIN', {
        value: "signinurl"
    });

    Object.defineProperty(Conference, 'CONFINFO_EXTTAB_URL', {
        value: "exttaburl"
    });

    Object.defineProperty(Conference, 'CONFINFO_PRIVTAB_INFO', {
        value: "privtabinfo"
    });

    Object.defineProperty(Conference, 'CONFINFO_PRIVATE_FILE_SERVER', {
        value: "privfs"
    });

    Object.defineProperty(Conference, 'CONFINFO_DOC_BACKUP_COMP_NDD', {
        value: "doc_backup_comp_ndd"
    });

    Object.defineProperty(Conference, 'CONFINFO_OEMKEY', {
        value: "oem_key"
    });

    Conference.LoginResponse = Slice.defineStruct(
        function(termId, option, myDetail, modules, activeMembers, ServerUTCTime, bRoomLocked, confInfo, isBegan, countdown, fileServers, vqs, windowMode, mainVideoTermID, vlo, bAllowWall, curMainTab, curSubTab, bFull, sm, lastTabValue, lastElemValue, wbDescibes)
        {
            this.termId = termId !== undefined ? termId : 0;
            this.option = option !== undefined ? option : 0;
            this.myDetail = myDetail !== undefined ? myDetail : new Conference.Contact();
            this.modules = modules !== undefined ? modules : null;
            this.activeMembers = activeMembers !== undefined ? activeMembers : null;
            this.ServerUTCTime = ServerUTCTime !== undefined ? ServerUTCTime : 0;
            this.bRoomLocked = bRoomLocked !== undefined ? bRoomLocked : false;
            this.confInfo = confInfo !== undefined ? confInfo : null;
            this.isBegan = isBegan !== undefined ? isBegan : false;
            this.countdown = countdown !== undefined ? countdown : 0;
            this.fileServers = fileServers !== undefined ? fileServers : null;
            this.vqs = vqs !== undefined ? vqs : null;
            this.windowMode = windowMode !== undefined ? windowMode : Conference.WINDOW_MODE.VMANAGER_LOCK;
            this.mainVideoTermID = mainVideoTermID !== undefined ? mainVideoTermID : 0;
            this.vlo = vlo !== undefined ? vlo : Conference.VIDEOLAYOUTMODE.VLO_1v1_M;
            this.bAllowWall = bAllowWall !== undefined ? bAllowWall : false;
            this.curMainTab = curMainTab !== undefined ? curMainTab : new Conference.TabID();
            this.curSubTab = curSubTab !== undefined ? curSubTab : new Conference.TabID();
            this.bFull = bFull !== undefined ? bFull : false;
            this.sm = sm !== undefined ? sm : Conference.SYNCMODE.SYNC_FORCE;
            this.lastTabValue = lastTabValue !== undefined ? lastTabValue : 0;
            this.lastElemValue = lastElemValue !== undefined ? lastElemValue : 0;
            this.wbDescibes = wbDescibes !== undefined ? wbDescibes : null;
        },
        false,
        function(__os)
        {
            __os.writeShort(this.termId);
            __os.writeInt(this.option);
            Conference.Contact.write(__os, this.myDetail);
            Conference.ModuleDictHelper.write(__os, this.modules);
            Conference.MemberSeqHelper.write(__os, this.activeMembers);
            __os.writeInt(this.ServerUTCTime);
            __os.writeBool(this.bRoomLocked);
            Conference.StringStringMapHelper.write(__os, this.confInfo);
            __os.writeBool(this.isBegan);
            __os.writeInt(this.countdown);
            Conference.FileServerSeqHelper.write(__os, this.fileServers);
            Conference.VideoQualitySeqHelper.write(__os, this.vqs);
            Conference.WINDOW_MODE.__write(__os, this.windowMode);
            __os.writeShort(this.mainVideoTermID);
            Conference.VIDEOLAYOUTMODE.__write(__os, this.vlo);
            __os.writeBool(this.bAllowWall);
            Conference.TabID.write(__os, this.curMainTab);
            Conference.TabID.write(__os, this.curSubTab);
            __os.writeBool(this.bFull);
            Conference.SYNCMODE.__write(__os, this.sm);
            __os.writeShort(this.lastTabValue);
            __os.writeShort(this.lastElemValue);
            Conference.WhiteBoardDescribeSeqHelper.write(__os, this.wbDescibes);
        },
        function(__is)
        {
            this.termId = __is.readShort();
            this.option = __is.readInt();
            this.myDetail = Conference.Contact.read(__is, this.myDetail);
            this.modules = Conference.ModuleDictHelper.read(__is);
            this.activeMembers = Conference.MemberSeqHelper.read(__is);
            this.ServerUTCTime = __is.readInt();
            this.bRoomLocked = __is.readBool();
            this.confInfo = Conference.StringStringMapHelper.read(__is);
            this.isBegan = __is.readBool();
            this.countdown = __is.readInt();
            this.fileServers = Conference.FileServerSeqHelper.read(__is);
            this.vqs = Conference.VideoQualitySeqHelper.read(__is);
            this.windowMode = Conference.WINDOW_MODE.__read(__is);
            this.mainVideoTermID = __is.readShort();
            this.vlo = Conference.VIDEOLAYOUTMODE.__read(__is);
            this.bAllowWall = __is.readBool();
            this.curMainTab = Conference.TabID.read(__is, this.curMainTab);
            this.curSubTab = Conference.TabID.read(__is, this.curSubTab);
            this.bFull = __is.readBool();
            this.sm = Conference.SYNCMODE.__read(__is);
            this.lastTabValue = __is.readShort();
            this.lastElemValue = __is.readShort();
            this.wbDescibes = Conference.WhiteBoardDescribeSeqHelper.read(__is);
        },
        50, 
        false);

    Conference.ConferenceRoom = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::ConferenceRoom",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.ConferenceRoomPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.ConferenceRoom.ice_staticId, undefined);

    Slice.defineOperations(Conference.ConferenceRoom, Conference.ConferenceRoomPrx,
    {
        "login": [, , , 1, , [Conference.LoginResponse], [[Conference.LoginRequest]], , 
        [
            Common.ConferenceError
        ], , ]
    });

    Conference.SSLoginRequest = Slice.defineStruct(
        function(confKey, memberId, memberType, phoneNum, callbacks, accessNo, PIN, sessionId)
        {
            this.confKey = confKey !== undefined ? confKey : "";
            this.memberId = memberId !== undefined ? memberId : 0;
            this.memberType = memberType !== undefined ? memberType : 0;
            this.phoneNum = phoneNum !== undefined ? phoneNum : "";
            this.callbacks = callbacks !== undefined ? callbacks : null;
            this.accessNo = accessNo !== undefined ? accessNo : 0;
            this.PIN = PIN !== undefined ? PIN : "";
            this.sessionId = sessionId !== undefined ? sessionId : "";
        },
        false,
        function(__os)
        {
            __os.writeString(this.confKey);
            __os.writeInt(this.memberId);
            __os.writeByte(this.memberType);
            __os.writeString(this.phoneNum);
            Conference.ModuleDictHelper.write(__os, this.callbacks);
            __os.writeInt(this.accessNo);
            __os.writeString(this.PIN);
            __os.writeString(this.sessionId);
        },
        function(__is)
        {
            this.confKey = __is.readString();
            this.memberId = __is.readInt();
            this.memberType = __is.readByte();
            this.phoneNum = __is.readString();
            this.callbacks = Conference.ModuleDictHelper.read(__is);
            this.accessNo = __is.readInt();
            this.PIN = __is.readString();
            this.sessionId = __is.readString();
        },
        14, 
        false);

    Conference.SSLoginResponse = Slice.defineStruct(
        function(termId, modules, actor, needPIN, PINLen, currentTermNum, isBegan, audioStatus)
        {
            this.termId = termId !== undefined ? termId : 0;
            this.modules = modules !== undefined ? modules : null;
            this.actor = actor !== undefined ? actor : 0;
            this.needPIN = needPIN !== undefined ? needPIN : false;
            this.PINLen = PINLen !== undefined ? PINLen : 0;
            this.currentTermNum = currentTermNum !== undefined ? currentTermNum : 0;
            this.isBegan = isBegan !== undefined ? isBegan : false;
            this.audioStatus = audioStatus !== undefined ? audioStatus : Conference.ASTATUS.AUNKNOWN;
        },
        false,
        function(__os)
        {
            __os.writeShort(this.termId);
            Conference.ModuleDictHelper.write(__os, this.modules);
            __os.writeByte(this.actor);
            __os.writeBool(this.needPIN);
            __os.writeByte(this.PINLen);
            __os.writeInt(this.currentTermNum);
            __os.writeBool(this.isBegan);
            Conference.ASTATUS.__write(__os, this.audioStatus);
        },
        function(__is)
        {
            this.termId = __is.readShort();
            this.modules = Conference.ModuleDictHelper.read(__is);
            this.actor = __is.readByte();
            this.needPIN = __is.readBool();
            this.PINLen = __is.readByte();
            this.currentTermNum = __is.readInt();
            this.isBegan = __is.readBool();
            this.audioStatus = Conference.ASTATUS.__read(__is);
        },
        12, 
        false);

    Object.defineProperty(Conference, 'PHASE_ALERTING', {
        value: 0
    });

    Object.defineProperty(Conference, 'PHASE_CONNECT', {
        value: 1
    });

    Object.defineProperty(Conference, 'PHASE_END', {
        value: 2
    });

    Object.defineProperty(Conference, 'END_REASON_NORMAL', {
        value: 0
    });

    Object.defineProperty(Conference, 'END_REASON_NO_ANSWER', {
        value: 1
    });

    Object.defineProperty(Conference, 'END_REASON_REJECT', {
        value: 2
    });

    Object.defineProperty(Conference, 'END_REASON_CONNECT_ERR', {
        value: 3
    });

    Object.defineProperty(Conference, 'END_REASON_USER_BUSY', {
        value: 4
    });

    Object.defineProperty(Conference, 'END_REASON_BALANCE_LESS', {
        value: 5
    });

    Conference.SoftSwitchUser = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::SoftSwitchUser",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.SoftSwitchUserPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.SoftSwitchUser.ice_staticId, undefined);

    Slice.defineOperations(Conference.SoftSwitchUser, Conference.SoftSwitchUserPrx,
    {
        "login": [, , , 1, , [Conference.SSLoginResponse], [[Conference.SSLoginRequest]], , 
        [
            Common.ConferenceError
        ], , ],
        "callProgress": [, , , 1, , , [[3], [3], [7]], , , , ]
    });

    Conference.AAAReport = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::AAAReport",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.AAAReportPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.AAAReport.ice_staticId, undefined);

    Slice.defineOperations(Conference.AAAReport, Conference.AAAReportPrx,
    {
        "callBalanceLess": [, , , 1, , , [[7], [7]], , 
        [
            Common.ConferenceError
        ], , ]
    });

    Conference.WebAdmin = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::WebAdmin",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.WebAdminPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.WebAdmin.ice_staticId, undefined);

    Slice.defineOperations(Conference.WebAdmin, Conference.WebAdminPrx,
    {
        "refresInvitees": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "refreshOptions": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "getConfStatus": [, , , 1, , [7], , , , , ],
        "callInvite": [, , , 1, , , [[7], [7], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "getLiveStream": [, , , 1, , ["Conference.StringStringMapHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "requestThirdPartyLiveStreamUrl": [, , , 1, , [7], [[3]], , , , ],
        "notifyLiveStreamStatus": [, , , 1, , , [[3], [3]], , , , ],
        "refreshThirdPublishStatus": [, , , 1, , , , , , , ],
        "startListLive": [, , , 1, , [3], [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "stopListLive": [, , , 1, , [3], , , , , ],
        "notifyRedStatus": [, , , 1, , , [[3], [7], [3], [3], [7], [7], [7], [7]], , , , ],
        "notifyThumbUp": [, , , 1, , , [[3], [3], [3], [7]], , , , ],
        "notifypayback": [, , , 1, , , [[3], [7]], , , , ],
        "swtichLiveAppElements": [, , , 1, , , [[3], [2]], , , , ],
        "getActiveMembers": [, , , 1, , ["Conference.MemberSeqHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "startRtsp": [, , , 1, , [7], [[3], [3], [3], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "stopRtsp": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "getRtspInfo": [, , , 1, , ["Conference.StringStringMapHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "updateRtspContent": [, , , 1, , , [[3], [3]], , 
        [
            Common.ConferenceError
        ], , ]
    });
    Slice.defineDictionary(Conference, "MemberRights", "MemberRightsHelper", "Ice.ShortHelper", "Conference.ByteListHelper", false, undefined, undefined, Ice.ArrayUtil.equals);

    Conference.ChangedRights = Slice.defineStruct(
        function(termId, addedRights, reducedRights)
        {
            this.termId = termId !== undefined ? termId : 0;
            this.addedRights = addedRights !== undefined ? addedRights : null;
            this.reducedRights = reducedRights !== undefined ? reducedRights : null;
        },
        true,
        function(__os)
        {
            __os.writeShort(this.termId);
            Conference.ByteListHelper.write(__os, this.addedRights);
            Conference.ByteListHelper.write(__os, this.reducedRights);
        },
        function(__is)
        {
            this.termId = __is.readShort();
            this.addedRights = Conference.ByteListHelper.read(__is);
            this.reducedRights = Conference.ByteListHelper.read(__is);
        },
        4, 
        false);
    Slice.defineSequence(Conference, "ChangedRightsSeqHelper", "Conference.ChangedRights", false);

    Object.defineProperty(Conference, 'INVITE_PREPARE', {
        value: 0
    });

    Object.defineProperty(Conference, 'PSTN_CALLING', {
        value: 1
    });

    Object.defineProperty(Conference, 'PSTN_RING', {
        value: 2
    });

    Object.defineProperty(Conference, 'PSTN_CONNECTED', {
        value: 3
    });

    Object.defineProperty(Conference, 'PSTN_HUNG', {
        value: 4
    });

    Object.defineProperty(Conference, 'PSTN_NO_ANSWER', {
        value: 5
    });

    Object.defineProperty(Conference, 'PSTN_REJECT', {
        value: 6
    });

    Object.defineProperty(Conference, 'PSTN_CONNECT_ERR', {
        value: 7
    });

    Object.defineProperty(Conference, 'PSTN_BUSY', {
        value: 8
    });

    Object.defineProperty(Conference, 'AAA_ACCOUNT_NOT_EXIST', {
        value: 100
    });

    Object.defineProperty(Conference, 'AAA_NO_PERMIT', {
        value: 101
    });

    Object.defineProperty(Conference, 'AAA_BALANCE_NOT_ENOUGH', {
        value: 102
    });

    Object.defineProperty(Conference, 'INV_SMS_FAILED', {
        value: 2
    });

    Object.defineProperty(Conference, 'INV_SMS_SUCCESS', {
        value: 1
    });

    Object.defineProperty(Conference, 'INV_EMAIL_FAILED', {
        value: 2
    });

    Object.defineProperty(Conference, 'INV_EMAIL_SUCCESS', {
        value: 1
    });

    Object.defineProperty(Conference, 'INV_EMAIL_READED', {
        value: 3
    });

    Object.defineProperty(Conference, 'WDT_1V1SUBMT_MONITOR', {
        value: 0
    });

    Object.defineProperty(Conference, 'WDT_1v1SUBMT_CHAT', {
        value: 1
    });

    Conference.InvitedMember = Slice.defineStruct(
        function(member, pstnNotice, state)
        {
            this.member = member !== undefined ? member : new Conference.Contact();
            this.pstnNotice = pstnNotice !== undefined ? pstnNotice : false;
            this.state = state !== undefined ? state : 0;
        },
        true,
        function(__os)
        {
            Conference.Contact.write(__os, this.member);
            __os.writeBool(this.pstnNotice);
            __os.writeInt(this.state);
        },
        function(__is)
        {
            this.member = Conference.Contact.read(__is, this.member);
            this.pstnNotice = __is.readBool();
            this.state = __is.readInt();
        },
        14, 
        false);
    Slice.defineSequence(Conference, "InvitedMembersHelper", "Conference.InvitedMember", false);

    Conference.INVITE_TYPE = Slice.defineEnum([
        ['TP_CALL', 0], ['TP_SMS', 1], ['TP_EMAIL', 2]]);
    Slice.defineDictionary(Conference, "InvitedMembersDict", "InvitedMembersDictHelper", "Conference.INVITE_TYPE.__helper", "Conference.InvitedMembersHelper", false, undefined, undefined, Ice.ArrayUtil.equals);
    Slice.defineDictionary(Conference, "HistoryMembers", "HistoryMembersHelper", "Ice.ShortHelper", "Conference.Member", false, undefined, undefined, Ice.HashMap.compareEquals);
    Slice.defineDictionary(Conference, "HistoryMemberNames", "HistoryMemberNamesHelper", "Ice.ShortHelper", "Ice.StringHelper", false, undefined, undefined);
    Slice.defineDictionary(Conference, "StatusDict", "StatusDictHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);
    Slice.defineDictionary(Conference, "BroadCastDict", "BroadCastDictHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);

    Object.defineProperty(Conference, 'CONF_END_REASON_UNKOWN', {
        value: "unkown"
    });

    Object.defineProperty(Conference, 'CONF_END_REASON_TERM', {
        value: "term"
    });

    Object.defineProperty(Conference, 'CONF_END_REASON_AUTO', {
        value: "auto"
    });

    Object.defineProperty(Conference, 'CONF_END_REASON_WEB', {
        value: "web"
    });

    Object.defineProperty(Conference, 'CONF_END_REASON_AAA', {
        value: "aaa"
    });

    Object.defineProperty(Conference, 'CONF_END_REASON_HOST_OFFLINE', {
        value: "host_offline"
    });

    Object.defineProperty(Conference, 'LEFT_REASON_KICK', {
        value: "kick"
    });

    Object.defineProperty(Conference, 'LEFT_REASON_REFRESH', {
        value: "refresh"
    });

    Object.defineProperty(Conference, 'LEFT_REASON_EXTRUDE', {
        value: "extrude"
    });

    Object.defineProperty(Conference, 'LEFT_REASON_TIMEOUT', {
        value: "timeout"
    });

    Object.defineProperty(Conference, 'LEFT_REASON_SEAT', {
        value: "seat"
    });

    Object.defineProperty(Conference, 'LEFT_REASON_EXIT', {
        value: "exit"
    });

    Object.defineProperty(Conference, 'LEFT_REASON_BUSY', {
        value: "busy"
    });

    Object.defineProperty(Conference, 'LEFT_REASON_BALANCE_LESS', {
        value: "balance_less"
    });

    Object.defineProperty(Conference, 'KNOCKED_REASON_ROOMLOCKED', {
        value: "room_locked"
    });

    Object.defineProperty(Conference, 'KNOCKED_REASON_SEATLESS', {
        value: "seat_less"
    });

    Object.defineProperty(Conference, 'KNOCKED_REASON_BALANCELESS', {
        value: "balance_less"
    });

    Object.defineProperty(Conference, 'BOARDCAST_RTMP', {
        value: "rtmp"
    });

    Object.defineProperty(Conference, 'BOARDCAST_RTMP2', {
        value: "rtmp2"
    });

    Object.defineProperty(Conference, 'BOARDCAST_SCREEN_RTMP', {
        value: "rtmp_screen"
    });

    Object.defineProperty(Conference, 'BOARDCAST_HLS', {
        value: "hls"
    });

    Object.defineProperty(Conference, 'BOARDCAST_HLS2', {
        value: "hls2"
    });

    Object.defineProperty(Conference, 'BOARDCAST_SCREEN_HLS', {
        value: "hls_screen"
    });

    Object.defineProperty(Conference, 'LD_MEMBER_LOCAL', {
        value: 1
    });

    Object.defineProperty(Conference, 'LD_MEMBER_VIEWER', {
        value: 2
    });

    Object.defineProperty(Conference, 'LD_MEMBER_ALL', {
        value: 3
    });

    Conference.LDPrize = Slice.defineStruct(
        function(prizeName, prizeCnt)
        {
            this.prizeName = prizeName !== undefined ? prizeName : "";
            this.prizeCnt = prizeCnt !== undefined ? prizeCnt : 0;
        },
        true,
        function(__os)
        {
            __os.writeString(this.prizeName);
            __os.writeInt(this.prizeCnt);
        },
        function(__is)
        {
            this.prizeName = __is.readString();
            this.prizeCnt = __is.readInt();
        },
        5, 
        false);

    Conference.LuckyDrawCfg = Slice.defineStruct(
        function(memberType, cdTime, isAutoDraw, prizes)
        {
            this.memberType = memberType !== undefined ? memberType : 0;
            this.cdTime = cdTime !== undefined ? cdTime : 0;
            this.isAutoDraw = isAutoDraw !== undefined ? isAutoDraw : false;
            this.prizes = prizes !== undefined ? prizes : new Conference.LDPrize();
        },
        true,
        function(__os)
        {
            __os.writeInt(this.memberType);
            __os.writeInt(this.cdTime);
            __os.writeBool(this.isAutoDraw);
            Conference.LDPrize.write(__os, this.prizes);
        },
        function(__is)
        {
            this.memberType = __is.readInt();
            this.cdTime = __is.readInt();
            this.isAutoDraw = __is.readBool();
            this.prizes = Conference.LDPrize.read(__is, this.prizes);
        },
        14, 
        false);

    Conference.LuckyDrawMember = Slice.defineStruct(
        function(name, contact, memberType)
        {
            this.name = name !== undefined ? name : "";
            this.contact = contact !== undefined ? contact : "";
            this.memberType = memberType !== undefined ? memberType : 0;
        },
        true,
        function(__os)
        {
            __os.writeString(this.name);
            __os.writeString(this.contact);
            __os.writeInt(this.memberType);
        },
        function(__is)
        {
            this.name = __is.readString();
            this.contact = __is.readString();
            this.memberType = __is.readInt();
        },
        6, 
        false);
    Slice.defineSequence(Conference, "LuckyDrawMembersHelper", "Conference.LuckyDrawMember", false);

    Conference.LDMembersCNT = Slice.defineStruct(
        function(memberLocalCnt, memberViewerCnt)
        {
            this.memberLocalCnt = memberLocalCnt !== undefined ? memberLocalCnt : 0;
            this.memberViewerCnt = memberViewerCnt !== undefined ? memberViewerCnt : 0;
        },
        true,
        function(__os)
        {
            __os.writeInt(this.memberLocalCnt);
            __os.writeInt(this.memberViewerCnt);
        },
        function(__is)
        {
            this.memberLocalCnt = __is.readInt();
            this.memberViewerCnt = __is.readInt();
        },
        8, 
        true);

    Conference.LuckyResult = Slice.defineStruct(
        function(prize, annouceTime, res)
        {
            this.prize = prize !== undefined ? prize : new Conference.LDPrize();
            this.annouceTime = annouceTime !== undefined ? annouceTime : 0;
            this.res = res !== undefined ? res : null;
        },
        true,
        function(__os)
        {
            Conference.LDPrize.write(__os, this.prize);
            __os.writeInt(this.annouceTime);
            Conference.LuckyDrawMembersHelper.write(__os, this.res);
        },
        function(__is)
        {
            this.prize = Conference.LDPrize.read(__is, this.prize);
            this.annouceTime = __is.readInt();
            this.res = Conference.LuckyDrawMembersHelper.read(__is);
        },
        10, 
        false);

    Conference.VoteState = Slice.defineStruct(
        function(id, voteOwner, state, voteInfo, memberVotes)
        {
            this.id = id !== undefined ? id : "";
            this.voteOwner = voteOwner !== undefined ? voteOwner : 0;
            this.state = state !== undefined ? state : 0;
            this.voteInfo = voteInfo !== undefined ? voteInfo : "";
            this.memberVotes = memberVotes !== undefined ? memberVotes : null;
        },
        false,
        function(__os)
        {
            __os.writeString(this.id);
            __os.writeShort(this.voteOwner);
            __os.writeInt(this.state);
            __os.writeString(this.voteInfo);
            Conference.StringStringMapHelper.write(__os, this.memberVotes);
        },
        function(__is)
        {
            this.id = __is.readString();
            this.voteOwner = __is.readShort();
            this.state = __is.readInt();
            this.voteInfo = __is.readString();
            this.memberVotes = Conference.StringStringMapHelper.read(__is);
        },
        9, 
        false);

    Conference.ConferenceSession = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::ConferenceSession",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.ConferenceSessionPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.ConferenceSession.ice_staticId, undefined);

    Slice.defineOperations(Conference.ConferenceSession, Conference.ConferenceSessionPrx,
    {
        "keepAlive": [, , , 1, , , [["Conference.StatusDictHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "exit": [, , , 1, , , [[7]], , , , ],
        "setAppStatus": [, , , 1, , , [[1]], , 
        [
            Common.ConferenceError
        ], , ],
        "changeNickname": [, , , 1, , [7], [[2], [7]], , 
        [
            Common.ConferenceError
        ], , ],
        "getActiveMembers": [, , , 1, , ["Conference.MemberSeqHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "getContacts": [, , , 1, , ["Conference.ContactTreeHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "applyDemoActor": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "applyAssistantActor": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "getOption": [, , , 1, , [3], , , 
        [
            Common.ConferenceError
        ], , ],
        "getMyDetail": [, , , 1, , [Conference.Contact], , , 
        [
            Common.ConferenceError
        ], , ],
        "getInfo": [, , , 1, , ["Conference.StringStringMapHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "setAgenda": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "setSubject": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "getPSTNNumber": [, , , 1, , [7], , , 
        [
            Common.ConferenceError
        ], , ],
        "setPSTNNumber": [, , , 1, , , [[7], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "generatePIN": [, , , 1, , [7], , , , , ],
        "cancelPIN": [, , , 1, , , , , , , ],
        "changeMemberRights": [, , , 1, , , [["Conference.ChangedRightsSeqHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "getAllMemberRights": [, , , 1, , ["Conference.MemberRightsHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "changeOption": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "setDemoActor": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "setHostActor": [, , , 1, , , [[2], [7]], , 
        [
            Common.ConferenceError
        ], , ],
        "setPSTNHostActor": [, , , 1, , , [[Conference.ContactIdType]], , 
        [
            Common.ConferenceError
        ], , ],
        "getPSTNHostActor": [, , , 1, , [Conference.ContactIdType], , , 
        [
            Common.ConferenceError
        ], , ],
        "allowDemoActor": [, , , 1, , , [[2], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "setAssistantActor": [, , , 1, , , [[2], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "getInviteMembers": [, , , 1, , ["Conference.InvitedMembersDictHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "getSelfInviteInfo": [, , , 1, , [Conference.InvitedMember], , , 
        [
            Common.ConferenceError
        ], , ],
        "addPSTNInvite": [, , , 1, , ["Conference.ContactIdSeqHelper"], [["Conference.ContactSeqHelper"], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "modifyPSTNInvitee": [, , , 1, , , [[Conference.INVITE_TYPE.__helper], [Conference.Contact]], , , , ],
        "smsInvite": [, , , 1, , ["Conference.ContactIdSeqHelper"], [["Conference.ContactSeqHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "callInvite": [, , , 1, , ["Conference.ContactIdSeqHelper"], [["Conference.ContactSeqHelper"], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "emailInvite": [, , , 1, , ["Conference.ContactIdSeqHelper"], [["Conference.ContactSeqHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "removeInvitee": [, , , 1, , , [[Conference.INVITE_TYPE.__helper], [Conference.Contact]], , 
        [
            Common.ConferenceError
        ], , ],
        "cancelCall": [, , , 1, , , [[Conference.ContactIdType]], , , , ],
        "callCustomerService": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "sendFeedback": [, , , 1, , , [[7], [7]], , 
        [
            Common.ConferenceError
        ], , ],
        "kickout": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "lockRoom": [, , , 1, , , [[1]], , 
        [
            Common.ConferenceError
        ], , ],
        "beginConference": [, , , 1, , [Conference.ContactIdType], [[Conference.Contact]], , 
        [
            Common.ConferenceError
        ], , ],
        "endConference": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "toggleRoomLock": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "broadcastMemberCount": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "getMemberCount": [, , , 1, , [3], , , 
        [
            Common.ConferenceError
        ], , ],
        "getBalance": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "cancelCountdown": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "getHistoryMembers": [, , , 1, , ["Conference.HistoryMembersHelper"], [["Ice.ShortSeqHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "getHistoryMemberNames": [, , , 1, , ["Conference.HistoryMemberNamesHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "cancelAutoEnd": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "netDetectResults": [, , , 1, , , [[3], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "getUserStatus": [, , , 1, , ["Conference.StringStringMapHelper"], [[2], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "start1v1SubMeeting": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "stop1v1SubMeeting": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "setWDT1v1SubMeetingMode": [, , , 1, , , [[3]], , , , ],
        "reportIVRStatus": [, , , 1, , , [[1]], , , , ],
        "startSvrBroadcast": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "startBroadCast": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "stopBroadCast": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "getBroadCastCfg": [, , , 1, , [7], , , 
        [
            Common.ConferenceError
        ], , ],
        "getBroadCastUrl": [, , , 1, , ["Conference.BroadCastDictHelper"], , , , , ],
        "enableBroadCastPlayback": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "disableBroadCastPlayback": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "setLuckyDrawCfg": [, , , 1, , , [[Conference.LuckyDrawCfg]], , 
        [
            Common.ConferenceError
        ], , ],
        "joinLuckyDrawMembers": [, , , 1, , , [["Conference.LuckyDrawMembersHelper"], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "clearLuckyDrawMembers": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "queryLuckyDrawMembers": [, , , 1, , ["Conference.LuckyDrawMembersHelper"], [[3], [2], [3]], , , , ],
        "announceLuckyDrawResult": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "getLuckyDrawCfg": [, , , 1, , [Conference.LuckyDrawCfg], , , 
        [
            Common.ConferenceError
        ], , ],
        "getLuckyDrawMembersStatus": [, , , 1, , [Conference.LDMembersCNT], , , 
        [
            Common.ConferenceError
        ], , ],
        "startSvrRecord": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "updateSvrRecCfg": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "stopSvrRecord": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "setSvrRecordState": [, , , 1, , , [[Conference.REC_STATE.__helper], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "setAppUILocked": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "setMcuPrivTaskState": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "beginVote": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "endVote": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "publishVoteResult": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "commitVote": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "getVoteState": [, , , 1, , [Conference.VoteState], , , 
        [
            Common.ConferenceError
        ], , ]
    });

    Object.defineProperty(Conference, 'SVR_NOTIFY_BALANCE_LESS', {
        value: 1
    });

    Conference.ConferenceCallback = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::ConferenceCallback",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.ConferenceCallbackPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.ConferenceCallback.ice_staticId, undefined);

    Slice.defineOperations(Conference.ConferenceCallback, Conference.ConferenceCallbackPrx,
    {
        "entered": [, , , , , , [[Conference.Member]], , , , ],
        "left": [, , , , , , [[2], [2], [7], [7]], , , , ],
        "actorChanged": [, , , , , , [[2], [2], [0]], , , , ],
        "nicknameChanged": [, , , , , , [[2], [2], [7]], , , , ],
        "optionChanged": [, , , , , , [[3]], , , , ],
        "rightChanged": [, , , , , , [[Conference.ChangedRights]], , , , ],
        "roomStateChanged": [, , , , , , [[1]], , , , ],
        "inviteStateChanged": [, , , , , , [[Conference.INVITE_TYPE.__helper], [Conference.InvitedMember]], , , , ],
        "conferenceBegan": [, , , , , , , , , , ],
        "conferenceEnded": [, , , , , , [[Conference.Contact], [7]], , , , ],
        "memberCount": [, , , , , , [[3]], , , , ],
        "confirmAutoEnd": [, , , , , , [[3]], , , , ],
        "autoEndCancelled": [, , , , , , , , , , ],
        "roomKnocked": [, , , , , , [[Conference.Contact], [7]], , , , ],
        "agendaUpdated": [, , , , , , [[7]], , , , ],
        "subjectUpdated": [, , , , , , [[7]], , , , ],
        "notifyApplyDemo": [, , , , , , [[2]], , , , ],
        "notifyApplyRejected": [, , , , , , [[2], [2]], , , , ],
        "serverNotify": [, , , , , , [[3]], , , , ],
        "serverNotifyMsg": [, , , , , , [[7]], , , , ],
        "updateAppStatus": [, , , , , , [["Ice.ShortSeqHelper"], ["Ice.ShortSeqHelper"]], , , , ],
        "notifyAssistantChanged": [, , , , , , [[2], [2], [1]], , , , ],
        "notifyNetDetectResults": [, , , , , , [[2], [3], [1]], , , , ],
        "notifyReportStatus": [, , , 1, , ["Conference.StringStringMapHelper"], [[2], [3]], , , , ],
        "exeCmd": [, , , 1, , [7], [[7]], , , , ],
        "notifyStart1v1SubMeeting": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "notifyStop1v1SubMeeting": [, , , , , , [[2]], , , , ],
        "notifyStart1v1SubMeetingRslt": [, , , , , , [[2], [1]], , , , ],
        "setWDT1v1SubMeetingMode": [, , , , , , [[2], [3]], , , , ],
        "notifyIVRStatus": [, , , , , , [[2], [1]], , , , ],
        "notifyStartSvrBroadcast": [, , , , , , [[2], [7]], , , , ],
        "notifyStartBroadCast": [, , , , , , [[2]], , , , ],
        "notifyStopBroadCast": [, , , , , , [[2]], , , , ],
        "notifyWebViewerNum": [, , , , , , [[3]], , , , ],
        "notifyBroadCastStartPush": [, , , , , , [["Conference.BroadCastDictHelper"]], , , , ],
        "notifyBroadCastStopPush": [, , , , , , , , , , ],
        "notifyBroadCastPlayback": [, , , , , , [[7]], , , , ],
        "notifyBroadCastPlaybackStop": [, , , , , , [[7]], , , , ],
        "notifypayback": [, , , , , , , , , , ],
        "notifySwtichLiveAppElements": [, , , , , , [[3], [2]], , , , ],
        "notifyThumbUp": [, , , , , , [[3], [3], [7]], , , , ],
        "notifyLuckyDrawCfg": [, , , , , , [[Conference.LuckyDrawCfg]], , , , ],
        "notifyLDMembersStatus": [, , , , , , [[Conference.LDMembersCNT]], , , , ],
        "notifyLuckyDrawResult": [, , , , , , [[Conference.LuckyResult]], , , , ],
        "notifySvrRecordStateChanged": [, , , , , , [[2], [Conference.REC_STATE.__helper], [3]], , , , ],
        "notifySvrRecordCfgChanged": [, , , , , , [[2], [7]], , , , ],
        "notifySvrBroadcastCfgChanged": [, , , , , , [[2], [7]], , , , ],
        "notifyAppUILocked": [, , , , , , [[3]], , , , ],
        "notifyBeginVote": [, , , , , , [[2], [7], [7]], , , , ],
        "notifyEndVote": [, , , , , , [[2]], , , , ],
        "notifyPublishVoteResult": [, , , , , , [[2], [7]], , , , ],
        "notifyCommitVote": [, , , , , , [[2], [7]], , , , ]
    });
    exports.Conference = Conference;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `Question.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Common = require("Common/Exception").Common;
    var Conference = __M.require(module, 
    [
        "Control/Conference",
        "Control/PublicTypes"
    ]).Conference;
    
    var Slice = Ice.Slice;

    Conference.lockQuesError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::lockQuesError",
        undefined, undefined,
        false,
        false);

    Conference.delQuesError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::delQuesError",
        undefined, undefined,
        false,
        false);

    Conference.quesNotExistError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::quesNotExistError",
        undefined, undefined,
        false,
        false);

    Conference.modifyQuesTypeError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::modifyQuesTypeError",
        undefined, undefined,
        false,
        false);

    Conference.QuesType = Slice.defineStruct(
        function(typeID, name, deleted)
        {
            this.typeID = typeID !== undefined ? typeID : "";
            this.name = name !== undefined ? name : "";
            this.deleted = deleted !== undefined ? deleted : false;
        },
        true,
        function(__os)
        {
            __os.writeString(this.typeID);
            __os.writeString(this.name);
            __os.writeBool(this.deleted);
        },
        function(__is)
        {
            this.typeID = __is.readString();
            this.name = __is.readString();
            this.deleted = __is.readBool();
        },
        3, 
        false);

    Conference.QuesState = Slice.defineEnum([
        ['Question_NotReply', 0], ['Question_Replying', 1], ['Question_NotPublic', 2], ['Question_Publiced', 3], ['Question_Deleted', 4]]);

    Conference.QuesAsk = Slice.defineStruct(
        function(typeID, asktime, termID, content, nickname)
        {
            this.typeID = typeID !== undefined ? typeID : "";
            this.asktime = asktime !== undefined ? asktime : 0;
            this.termID = termID !== undefined ? termID : 0;
            this.content = content !== undefined ? content : "";
            this.nickname = nickname !== undefined ? nickname : "";
        },
        true,
        function(__os)
        {
            __os.writeString(this.typeID);
            __os.writeInt(this.asktime);
            __os.writeShort(this.termID);
            __os.writeString(this.content);
            __os.writeString(this.nickname);
        },
        function(__is)
        {
            this.typeID = __is.readString();
            this.asktime = __is.readInt();
            this.termID = __is.readShort();
            this.content = __is.readString();
            this.nickname = __is.readString();
        },
        9, 
        false);

    Conference.QuesDeal = Slice.defineStruct(
        function(state, replyCon, replyTermId, replyTime, publishTermID, publishTime, delTermID, delTime)
        {
            this.state = state !== undefined ? state : Conference.QuesState.Question_NotReply;
            this.replyCon = replyCon !== undefined ? replyCon : "";
            this.replyTermId = replyTermId !== undefined ? replyTermId : 0;
            this.replyTime = replyTime !== undefined ? replyTime : 0;
            this.publishTermID = publishTermID !== undefined ? publishTermID : 0;
            this.publishTime = publishTime !== undefined ? publishTime : 0;
            this.delTermID = delTermID !== undefined ? delTermID : 0;
            this.delTime = delTime !== undefined ? delTime : 0;
        },
        true,
        function(__os)
        {
            Conference.QuesState.__write(__os, this.state);
            __os.writeString(this.replyCon);
            __os.writeShort(this.replyTermId);
            __os.writeInt(this.replyTime);
            __os.writeShort(this.publishTermID);
            __os.writeInt(this.publishTime);
            __os.writeShort(this.delTermID);
            __os.writeInt(this.delTime);
        },
        function(__is)
        {
            this.state = Conference.QuesState.__read(__is);
            this.replyCon = __is.readString();
            this.replyTermId = __is.readShort();
            this.replyTime = __is.readInt();
            this.publishTermID = __is.readShort();
            this.publishTime = __is.readInt();
            this.delTermID = __is.readShort();
            this.delTime = __is.readInt();
        },
        20, 
        false);

    Conference.QuesInf = Slice.defineStruct(
        function(quesID, ask, deal)
        {
            this.quesID = quesID !== undefined ? quesID : 0;
            this.ask = ask !== undefined ? ask : new Conference.QuesAsk();
            this.deal = deal !== undefined ? deal : new Conference.QuesDeal();
        },
        true,
        function(__os)
        {
            __os.writeInt(this.quesID);
            Conference.QuesAsk.write(__os, this.ask);
            Conference.QuesDeal.write(__os, this.deal);
        },
        function(__is)
        {
            this.quesID = __is.readInt();
            this.ask = Conference.QuesAsk.read(__is, this.ask);
            this.deal = Conference.QuesDeal.read(__is, this.deal);
        },
        33, 
        false);
    Slice.defineSequence(Conference, "QuesListHelper", "Conference.QuesInf", false);
    Slice.defineSequence(Conference, "QuesTypeListHelper", "Conference.QuesType", false);

    Conference.AnsQueCallback = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::AnsQueCallback",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.AnsQueCallbackPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.AnsQueCallback.ice_staticId, undefined);

    Slice.defineOperations(Conference.AnsQueCallback, Conference.AnsQueCallbackPrx,
    {
        "askQuesNotify": [, , , , , , [[3], [Conference.QuesAsk]], , 
        [
            Common.ConferenceError
        ], , ],
        "lockQuesNotify": [, , , , , , [[3], [Conference.QuesDeal]], , 
        [
            Common.ConferenceError
        ], , ],
        "replyQuesNotify": [, , , , , , [[3], [Conference.QuesDeal]], , 
        [
            Common.ConferenceError
        ], , ],
        "modifyQuesNotify": [, , , , , , [[3], [Conference.QuesDeal]], , 
        [
            Common.ConferenceError
        ], , ],
        "delQuesNotify": [, , , , , , [[3], [2]], , 
        [
            Common.ConferenceError
        ], , ],
        "delAllQuesNotify": [, , , , , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "publicQuesNotify": [, , , , , , [[3], [1], [2]], , 
        [
            Common.ConferenceError
        ], , ],
        "quesTypeChangeNotify": [, , , , , , [[3], [7]], , 
        [
            Common.ConferenceError
        ], , ],
        "modifyQuesTypeNotify": [, , , , , , [[2], ["Conference.QuesTypeListHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "setBroadCastQuesNotify": [, , , , , , [[1]], , 
        [
            Common.ConferenceError
        ], , ]
    });

    Conference.AnsQuesCtrl = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::AnsQuesCtrl",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.AnsQuesCtrlPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.AnsQuesCtrl.ice_staticId, undefined);

    Slice.defineOperations(Conference.AnsQuesCtrl, Conference.AnsQuesCtrlPrx,
    {
        "askQues": [, , , 1, , [3], [[Conference.QuesAsk]], , 
        [
            Common.ConferenceError
        ], , ],
        "lockQues": [, , , 1, , , [[3], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "replyQues": [, , , 1, , , [[3], [Conference.QuesDeal]], , 
        [
            Common.ConferenceError
        ], , ],
        "publicQues": [, , , 1, , , [[3], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "modifyQues": [, , , 1, , , [[3], [Conference.QuesDeal]], , 
        [
            Common.ConferenceError
        ], , ],
        "delQues": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "delAllQues": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "quesTypeChange": [, , , 1, , , [[3], [7]], , 
        [
            Common.ConferenceError
        ], , ],
        "getQuesList": [, , , 1, , ["Conference.QuesListHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "getQuesType": [, , , 1, , ["Conference.QuesTypeListHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "modifyQuesType": [, , , 1, , , [["Conference.QuesTypeListHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "setBoradCastQues": [, , , 1, , , [[1]], , 
        [
            Common.ConferenceError
        ], , ]
    });
    exports.Conference = Conference;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `IM.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Common = require("Common/Exception").Common;
    var Conference = require("Control/Conference").Conference;
    var Slice = Ice.Slice;

    Conference.IMFont = Slice.defineStruct(
        function(color, size)
        {
            this.color = color !== undefined ? color : 0;
            this.size = size !== undefined ? size : 0;
        },
        true,
        function(__os)
        {
            __os.writeInt(this.color);
            __os.writeByte(this.size);
        },
        function(__is)
        {
            this.color = __is.readInt();
            this.size = __is.readByte();
        },
        5, 
        true);

    Conference.InIMMsgInfo = Slice.defineStruct(
        function(targetTermId, targetNickname, font, msg, sendTime)
        {
            this.targetTermId = targetTermId !== undefined ? targetTermId : 0;
            this.targetNickname = targetNickname !== undefined ? targetNickname : "";
            this.font = font !== undefined ? font : new Conference.IMFont();
            this.msg = msg !== undefined ? msg : "";
            this.sendTime = sendTime !== undefined ? sendTime : 0;
        },
        true,
        function(__os)
        {
            __os.writeShort(this.targetTermId);
            __os.writeString(this.targetNickname);
            Conference.IMFont.write(__os, this.font);
            __os.writeString(this.msg);
            __os.writeInt(this.sendTime);
        },
        function(__is)
        {
            this.targetTermId = __is.readShort();
            this.targetNickname = __is.readString();
            this.font = Conference.IMFont.read(__is, this.font);
            this.msg = __is.readString();
            this.sendTime = __is.readInt();
        },
        13, 
        false);

    Conference.OutIMMsgInfo = Slice.defineStruct(
        function(index, srcTermId, srcNickname, inMsg)
        {
            this.index = index !== undefined ? index : 0;
            this.srcTermId = srcTermId !== undefined ? srcTermId : 0;
            this.srcNickname = srcNickname !== undefined ? srcNickname : "";
            this.inMsg = inMsg !== undefined ? inMsg : new Conference.InIMMsgInfo();
        },
        true,
        function(__os)
        {
            __os.writeInt(this.index);
            __os.writeShort(this.srcTermId);
            __os.writeString(this.srcNickname);
            Conference.InIMMsgInfo.write(__os, this.inMsg);
        },
        function(__is)
        {
            this.index = __is.readInt();
            this.srcTermId = __is.readShort();
            this.srcNickname = __is.readString();
            this.inMsg = Conference.InIMMsgInfo.read(__is, this.inMsg);
        },
        20, 
        false);
    Slice.defineSequence(Conference, "outMsgListHelper", "Conference.OutIMMsgInfo", false);
    Slice.defineSequence(Conference, "termIDListHelper", "Ice.ShortHelper", true);

    Conference.IMCallback = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::IMCallback",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.IMCallbackPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.IMCallback.ice_staticId, undefined);

    Slice.defineOperations(Conference.IMCallback, Conference.IMCallbackPrx,
    {
        "receiveIMMsg": [, , , , , , [[Conference.OutIMMsgInfo]], , , , ],
        "receiveMultiIMMsg": [, , , , , , [["Conference.outMsgListHelper"]], , , , ],
        "notifyIMForbidStatus": [, , , , , , [[2], [2], [1]], , , , ],
        "notifyClearIMMsg": [, , , , , , [[2]], , , , ],
        "notifyDeleteIMMsg": [, , , , , , [[3]], , , , ]
    });

    Conference.IMSession = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::IMSession",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.IMSessionPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.IMSession.ice_staticId, undefined);

    Slice.defineOperations(Conference.IMSession, Conference.IMSessionPrx,
    {
        "getIMMsgCount": [, , , 1, , [3], , , , , ],
        "getLastMsg": [, , , 1, , ["Conference.outMsgListHelper"], [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "getLastNMsg": [, , , 1, , ["Conference.outMsgListHelper"], [[3], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "sendIMMsg": [, , , 1, , , [[Conference.InIMMsgInfo]], , 
        [
            Common.ConferenceError
        ], , ],
        "deleteIMMsg": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "getIMForbidList": [, , , 1, , ["Conference.termIDListHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "setIMForbidStatus": [, , , 1, , , [[2], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "clearIMMsg": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "passIMMsg": [, , , 1, , [1], [[3]], , 
        [
            Common.ConferenceError
        ], , ]
    });
    exports.Conference = Conference;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `Audio.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Common = require("Common/Exception").Common;
    var Conference = require("Control/PublicTypes").Conference;
    var Slice = Ice.Slice;

    Conference.NoResourceForMIC = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::NoResourceForMIC",
        undefined, undefined,
        false,
        false);

    Conference.StartRecordError = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::StartRecordError",
        undefined, undefined,
        false,
        false);

    Conference.PlayBackGroundMusicFail = Slice.defineUserException(
        function(error, reason, _cause)
        {
            Common.ConferenceError.call(this, error, reason, _cause);
        },
        Common.ConferenceError,
        "Conference::PlayBackGroundMusicFail",
        undefined, undefined,
        false,
        false);
    Slice.defineSequence(Conference, "MusicListHelper", "Ice.StringHelper", false);
    Slice.defineDictionary(Conference, "TerminalEnergy", "TerminalEnergyHelper", "Ice.ShortHelper", "Ice.IntHelper", true, undefined, undefined);
    Slice.defineSequence(Conference, "deviceLstHelper", "Ice.StringHelper", false);

    Conference.remoteAudio = Slice.defineStruct(
        function(inputDevice, outputDevice, bMicBoost, hiLevelEC, outputDType, echoDelay, outputVolume, inputVolume)
        {
            this.inputDevice = inputDevice !== undefined ? inputDevice : "";
            this.outputDevice = outputDevice !== undefined ? outputDevice : "";
            this.bMicBoost = bMicBoost !== undefined ? bMicBoost : false;
            this.hiLevelEC = hiLevelEC !== undefined ? hiLevelEC : 0;
            this.outputDType = outputDType !== undefined ? outputDType : 0;
            this.echoDelay = echoDelay !== undefined ? echoDelay : 0;
            this.outputVolume = outputVolume !== undefined ? outputVolume : 0;
            this.inputVolume = inputVolume !== undefined ? inputVolume : 0;
        },
        true,
        function(__os)
        {
            __os.writeString(this.inputDevice);
            __os.writeString(this.outputDevice);
            __os.writeBool(this.bMicBoost);
            __os.writeInt(this.hiLevelEC);
            __os.writeInt(this.outputDType);
            __os.writeInt(this.echoDelay);
            __os.writeInt(this.outputVolume);
            __os.writeInt(this.inputVolume);
        },
        function(__is)
        {
            this.inputDevice = __is.readString();
            this.outputDevice = __is.readString();
            this.bMicBoost = __is.readBool();
            this.hiLevelEC = __is.readInt();
            this.outputDType = __is.readInt();
            this.echoDelay = __is.readInt();
            this.outputVolume = __is.readInt();
            this.inputVolume = __is.readInt();
        },
        23, 
        false);

    Conference.remoteAudioInf = Slice.defineStruct(
        function(inputDLst, outputDLst, remoteInf)
        {
            this.inputDLst = inputDLst !== undefined ? inputDLst : null;
            this.outputDLst = outputDLst !== undefined ? outputDLst : null;
            this.remoteInf = remoteInf !== undefined ? remoteInf : new Conference.remoteAudio();
        },
        true,
        function(__os)
        {
            Conference.deviceLstHelper.write(__os, this.inputDLst);
            Conference.deviceLstHelper.write(__os, this.outputDLst);
            Conference.remoteAudio.write(__os, this.remoteInf);
        },
        function(__is)
        {
            this.inputDLst = Conference.deviceLstHelper.read(__is);
            this.outputDLst = Conference.deviceLstHelper.read(__is);
            this.remoteInf = Conference.remoteAudio.read(__is, this.remoteInf);
        },
        25, 
        false);

    Conference.AudioCallback = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::AudioCallback",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.AudioCallbackPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.AudioCallback.ice_staticId, undefined);

    Slice.defineOperations(Conference.AudioCallback, Conference.AudioCallbackPrx,
    {
        "updateStatus": [, , , , , , [[2], [2], [Conference.ASTATUS.__helper]], , , , ],
        "updateVoiceEnergy": [, , , , , , [["Conference.TerminalEnergyHelper"]], , , , ],
        "updateSpeaker": [, , , , , , [[2]], , , , ],
        "closeAll": [, , , , , , [[2]], , , , ],
        "playBackgroundMusic": [, , , , , , [[2], [1]], , , , ],
        "notifyVoiceHowling": [, , , , , , [[2], [1]], , , , ],
        "notifyVoiceNoise": [, , , , , , [[2], [1]], , , , ],
        "getRemoteAudioInfNotify": [, , , 1, , [Conference.remoteAudioInf], [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "remoteAudioSetNotify": [, , , , , , [[2], [Conference.remoteAudio]], , 
        [
            Common.ConferenceError
        ], , ],
        "notifyLanLessMicOpen": [, , , , , , , , , , ]
    });

    Conference.AudioCtrl = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::AudioCtrl",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.AudioCtrlPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.AudioCtrl.ice_staticId, undefined);

    Slice.defineOperations(Conference.AudioCtrl, Conference.AudioCtrlPrx,
    {
        "setDeviceStatus": [, , , 1, , , [[1]], , 
        [
            Common.ConferenceError
        ], , ],
        "askForMic": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "openMicEx": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "closeMicEx": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "closeAll": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "setVoiceEnergy": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "pstnSwitchMicStatus": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "startRecord": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "isRecording": [, , , 1, , [1], , , 
        [
            Common.ConferenceError
        ], , ],
        "stopRecord": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "playApplause": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "getMusicList": [, , , 1, , ["Conference.MusicListHelper"], , , 
        [
            Common.ConferenceError
        ], , ],
        "getPlayBGMusic": [, , , 1, , [7], , , 
        [
            Common.ConferenceError
        ], , ],
        "startBGMusic": [, , , 1, , , [[7], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "stopPlayBGMusic": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "setPlayBGMusicVolumn": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "getPlayBGMusicVolumn": [, , , 1, , [3], , , 
        [
            Common.ConferenceError
        ], , ],
        "voiceHowling": [, , , 1, , , [[1]], , , , ],
        "voiceNoise": [, , , 1, , , [[1]], , , , ],
        "remoteAudioSet": [, , , 1, , , [[2], [Conference.remoteAudio]], , 
        [
            Common.ConferenceError
        ], , ],
        "getRemoteAudioInf": [, , , 1, , [Conference.remoteAudioInf], [[2]], , 
        [
            Common.ConferenceError
        ], , ]
    });
    exports.Conference = Conference;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `Video.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Common = require("Common/Exception").Common;
    var Conference = require("Control/PublicTypes").Conference;
    var Slice = Ice.Slice;

    Object.defineProperty(Conference, 'FPS_LOW', {
        value: -1
    });

    Object.defineProperty(Conference, 'FPS_NOR', {
        value: 0
    });

    Object.defineProperty(Conference, 'FPS_HI', {
        value: 1
    });

    Object.defineProperty(Conference, 'VEDIO_LD', {
        value: -1
    });

    Object.defineProperty(Conference, 'VEDIO_SD', {
        value: 0
    });

    Object.defineProperty(Conference, 'VEDIO_HD', {
        value: 1
    });

    Object.defineProperty(Conference, 'VEDIO_UD', {
        value: 2
    });

    Conference.VideoSetting = Slice.defineStruct(
        function(mutiCam, openCamIDs, denoise, deinterlace, fpsType, videType)
        {
            this.mutiCam = mutiCam !== undefined ? mutiCam : false;
            this.openCamIDs = openCamIDs !== undefined ? openCamIDs : null;
            this.denoise = denoise !== undefined ? denoise : false;
            this.deinterlace = deinterlace !== undefined ? deinterlace : false;
            this.fpsType = fpsType !== undefined ? fpsType : 0;
            this.videType = videType !== undefined ? videType : 0;
        },
        true,
        function(__os)
        {
            __os.writeBool(this.mutiCam);
            Ice.ShortSeqHelper.write(__os, this.openCamIDs);
            __os.writeBool(this.denoise);
            __os.writeBool(this.deinterlace);
            __os.writeInt(this.fpsType);
            __os.writeInt(this.videType);
        },
        function(__is)
        {
            this.mutiCam = __is.readBool();
            this.openCamIDs = Ice.ShortSeqHelper.read(__is);
            this.denoise = __is.readBool();
            this.deinterlace = __is.readBool();
            this.fpsType = __is.readInt();
            this.videType = __is.readInt();
        },
        12, 
        false);

    Conference.UsrCamID = Slice.defineStruct(
        function(termID, camID)
        {
            this.termID = termID !== undefined ? termID : 0;
            this.camID = camID !== undefined ? camID : 0;
        },
        true,
        function(__os)
        {
            __os.writeShort(this.termID);
            __os.writeShort(this.camID);
        },
        function(__is)
        {
            this.termID = __is.readShort();
            this.camID = __is.readShort();
        },
        4, 
        true);
    Slice.defineSequence(Conference, "UsrCamIDListHelper", "Conference.UsrCamID", true);

    Conference.UsrCamSize = Slice.defineStruct(
        function(termID, camID, VIDEO_SS_value)
        {
            this.termID = termID !== undefined ? termID : 0;
            this.camID = camID !== undefined ? camID : 0;
            this.VIDEO_SS_value = VIDEO_SS_value !== undefined ? VIDEO_SS_value : 0;
        },
        true,
        function(__os)
        {
            __os.writeShort(this.termID);
            __os.writeShort(this.camID);
            __os.writeInt(this.VIDEO_SS_value);
        },
        function(__is)
        {
            this.termID = __is.readShort();
            this.camID = __is.readShort();
            this.VIDEO_SS_value = __is.readInt();
        },
        8, 
        true);
    Slice.defineSequence(Conference, "UsrCamSizeListHelper", "Conference.UsrCamSize", true);

    Object.defineProperty(Conference, 'ZOOM_TELE', {
        value: 2
    });

    Object.defineProperty(Conference, 'ZOOM_WIDE', {
        value: 3
    });

    Object.defineProperty(Conference, 'ZOOM_STOP', {
        value: 0
    });

    Object.defineProperty(Conference, 'PAN_TILT_DIR_UP', {
        value: 1
    });

    Object.defineProperty(Conference, 'PAN_TILT_DIR_DOWN', {
        value: 2
    });

    Object.defineProperty(Conference, 'PAN_TILT_DIR_LEFT', {
        value: 3
    });

    Object.defineProperty(Conference, 'PAN_TILT_DIR_RIGHT', {
        value: 4
    });

    Object.defineProperty(Conference, 'PAN_TILT_DIR_STOP', {
        value: 5
    });

    Conference.VideoCallback = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::VideoCallback",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.VideoCallbackPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.VideoCallback.ice_staticId, undefined);

    Slice.defineOperations(Conference.VideoCallback, Conference.VideoCallbackPrx,
    {
        "notifyAllowVideoWall": [, , , , , , [[1], [2]], , , , ],
        "updateStatus": [, , , , , , [[2], [Conference.VSTATUS.__helper], [2]], , , , ],
        "notifyOpenVideo": [, , , , , , [[2]], , , , ],
        "startVideoByManager": [, , , , , , , , 
        [
            Common.ConferenceError
        ], , ],
        "notifyEnableVideo": [, , , , , , [[2], [1], [2]], , , , ],
        "updateFocusWindow": [, , , , , , [[Conference.WINDOW_MODE.__helper], [2]], , , , ],
        "updateVLayout": [, , , , , , [[Conference.VIDEOLAYOUTMODE.__helper], [2]], , , , ],
        "updateMainVideoShowMode": [, , , , , , [[3], [2]], , , , ],
        "updateVideoListMode": [, , , , , , [[7], [2]], , , , ],
        "enableUpload": [, , , , , , [[2], [1]], , , , ],
        "enableUpload2": [, , , , , , [[2], [3]], , , , ],
        "generateIFrame": [, , , , , , [[2]], , , , ],
        "notifyRefuseOpenVideo": [, , , , , , [[2]], , , , ],
        "getVideoSetting": [, , , 1, , [Conference.VideoSetting], , , 
        [
            Common.ConferenceError
        ], , ],
        "setCamera": [, , , , , , [[Conference.VideoSetting], [2]], , 
        [
            Common.ConferenceError
        ], , ],
        "setCameraById": [, , , , , , [[Conference.UsrCamID], [2]], , 
        [
            Common.ConferenceError
        ], , ],
        "notifyVideoPolling": [, , , , , , [[2], [1], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "notifyPollingVideo": [, , , , , , [[2], ["Conference.UsrCamIDListHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "notifyVideoList": [, , , , , , [[2], [7]], , 
        [
            Common.ConferenceError
        ], , ],
        "notifyUpdateAllCameraInfos": [, , , , , , [[2], [7]], , 
        [
            Common.ConferenceError
        ], , ],
        "notifySetOpenedCameraNumber": [, , , , , , [[2], ["Ice.ShortSeqHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "notifyStartAdjustDirection": [, , , , , , [[Conference.UsrCamID], [3]], , , , ],
        "notifyStartAdjustZoom": [, , , , , , [[Conference.UsrCamID], [3]], , , , ],
        "notifyStopAdjustDirection": [, , , , , , [[Conference.UsrCamID]], , , , ],
        "notifyStopAdjustZoom": [, , , , , , [[Conference.UsrCamID]], , , , ]
    });

    Conference.VideoCtrl = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 0,
        [
            "::Conference::VideoCtrl",
            "::Ice::Object"
        ],
        -1, undefined, undefined, false);

    Conference.VideoCtrlPrx = Slice.defineProxy(Ice.ObjectPrx, Conference.VideoCtrl.ice_staticId, undefined);

    Slice.defineOperations(Conference.VideoCtrl, Conference.VideoCtrlPrx,
    {
        "setDeviceStatus": [, , , 1, , , [[1]], , 
        [
            Common.ConferenceError
        ], , ],
        "allowVideoWall": [, , , 1, , , [[1]], , 
        [
            Common.ConferenceError
        ], , ],
        "startVideo": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "stopVideo": [, , , 1, , , , , 
        [
            Common.ConferenceError
        ], , ],
        "reqOpenVideo": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "startVideoEx": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "stopVideoEx": [, , , 1, , , [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "enableVideo": [, , , 1, , , [[1]], , 
        [
            Common.ConferenceError
        ], , ],
        "setFocusWindow": [, , , 1, , , [[Conference.WINDOW_MODE.__helper], [2]], , 
        [
            Common.ConferenceError
        ], , ],
        "batchSubscribeVideo": [, , , 1, , , [["Conference.UsrCamIDListHelper"], [1]], , 
        [
            Common.ConferenceError
        ], , ],
        "batchSubscribeVideo2": [, , , 1, , , [["Conference.UsrCamSizeListHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "subscribeFocusWindow": [, , , 1, , , [[1]], , 
        [
            Common.ConferenceError
        ], , ],
        "subscribeFocusWindow2": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "setVLayout": [, , , 1, , , [[Conference.VIDEOLAYOUTMODE.__helper]], , 
        [
            Common.ConferenceError
        ], , ],
        "setMainVideoShowMode": [, , , 1, , , [[3]], , 
        [
            Common.ConferenceError
        ], , ],
        "setVideoListMode": [, , , 1, , , [[7]], , , , ],
        "refuseOpenVideo": [, , , 1, , , [[2]], , , , ],
        "getVideoSetting": [, , , 1, , [Conference.VideoSetting], [[2]], , 
        [
            Common.ConferenceError
        ], , ],
        "setCamera": [, , , 1, , , [[2], [Conference.VideoSetting]], , 
        [
            Common.ConferenceError
        ], , ],
        "setCameraById": [, , , 1, , , [[Conference.UsrCamID]], , 
        [
            Common.ConferenceError
        ], , ],
        "setVideoPolling": [, , , 1, , , [[1], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "updatePollingVideo": [, , , 1, , , [["Conference.UsrCamIDListHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "updateVideoList": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "getVideoPollingState": [, , , 1, , [1], , [["Conference.UsrCamIDListHelper"], [3]], 
        [
            Common.ConferenceError
        ], , ],
        "updateAllCameraInfos": [, , , 1, , , [[7]], , 
        [
            Common.ConferenceError
        ], , ],
        "setOpenedCameraNumber": [, , , 1, , , [["Ice.ShortSeqHelper"]], , 
        [
            Common.ConferenceError
        ], , ],
        "startAdjustDirection": [, , , 1, , , [[Conference.UsrCamID], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "startAdjustZoom": [, , , 1, , , [[Conference.UsrCamID], [3]], , 
        [
            Common.ConferenceError
        ], , ],
        "stopAdjustDirection": [, , , 1, , , [[Conference.UsrCamID]], , 
        [
            Common.ConferenceError
        ], , ],
        "stopAdjustZoom": [, , , 1, , , [[Conference.UsrCamID]], , 
        [
            Common.ConferenceError
        ], , ]
    });
    exports.Conference = Conference;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `client_log.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Slice = Ice.Slice;

    var LogSpace = __M.module("LogSpace");

    LogSpace.LogLevel = Slice.defineEnum([
        ['debug', 0], ['info', 1], ['warning', 2], ['error', 3]]);

    LogSpace.FatalLogInfo = Slice.defineStruct(
        function(version, conferenceID, userID, client, clientIP, logDate, content, dumpData)
        {
            this.version = version !== undefined ? version : "";
            this.conferenceID = conferenceID !== undefined ? conferenceID : 0;
            this.userID = userID !== undefined ? userID : 0;
            this.client = client !== undefined ? client : "";
            this.clientIP = clientIP !== undefined ? clientIP : "";
            this.logDate = logDate !== undefined ? logDate : "";
            this.content = content !== undefined ? content : "";
            this.dumpData = dumpData !== undefined ? dumpData : null;
        },
        true,
        function(__os)
        {
            __os.writeString(this.version);
            __os.writeInt(this.conferenceID);
            __os.writeInt(this.userID);
            __os.writeString(this.client);
            __os.writeString(this.clientIP);
            __os.writeString(this.logDate);
            __os.writeString(this.content);
            Ice.ByteSeqHelper.write(__os, this.dumpData);
        },
        function(__is)
        {
            this.version = __is.readString();
            this.conferenceID = __is.readInt();
            this.userID = __is.readInt();
            this.client = __is.readString();
            this.clientIP = __is.readString();
            this.logDate = __is.readString();
            this.content = __is.readString();
            this.dumpData = Ice.ByteSeqHelper.read(__is);
        },
        14, 
        false);

    LogSpace.AppendData = Slice.defineStruct(
        function(uuid, type, data)
        {
            this.uuid = uuid !== undefined ? uuid : "";
            this.type = type !== undefined ? type : "";
            this.data = data !== undefined ? data : null;
        },
        true,
        function(__os)
        {
            __os.writeString(this.uuid);
            __os.writeString(this.type);
            Ice.ByteSeqHelper.write(__os, this.data);
        },
        function(__is)
        {
            this.uuid = __is.readString();
            this.type = __is.readString();
            this.data = Ice.ByteSeqHelper.read(__is);
        },
        3, 
        false);
    Slice.defineSequence(LogSpace, "AppendDataSeqHelper", "LogSpace.AppendData", false);

    LogSpace.UsrReportInfo = Slice.defineStruct(
        function(version, conferenceID, userID, client, clientIP, reportDate, contact, content, appendDatas)
        {
            this.version = version !== undefined ? version : "";
            this.conferenceID = conferenceID !== undefined ? conferenceID : 0;
            this.userID = userID !== undefined ? userID : 0;
            this.client = client !== undefined ? client : "";
            this.clientIP = clientIP !== undefined ? clientIP : "";
            this.reportDate = reportDate !== undefined ? reportDate : "";
            this.contact = contact !== undefined ? contact : "";
            this.content = content !== undefined ? content : "";
            this.appendDatas = appendDatas !== undefined ? appendDatas : null;
        },
        true,
        function(__os)
        {
            __os.writeString(this.version);
            __os.writeInt(this.conferenceID);
            __os.writeInt(this.userID);
            __os.writeString(this.client);
            __os.writeString(this.clientIP);
            __os.writeString(this.reportDate);
            __os.writeString(this.contact);
            __os.writeString(this.content);
            LogSpace.AppendDataSeqHelper.write(__os, this.appendDatas);
        },
        function(__is)
        {
            this.version = __is.readString();
            this.conferenceID = __is.readInt();
            this.userID = __is.readInt();
            this.client = __is.readString();
            this.clientIP = __is.readString();
            this.reportDate = __is.readString();
            this.contact = __is.readString();
            this.content = __is.readString();
            this.appendDatas = LogSpace.AppendDataSeqHelper.read(__is);
        },
        15, 
        false);

    LogSpace.ClientLogServer = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::LogSpace::ClientLogServer"
        ],
        -1, undefined, undefined, false);

    LogSpace.ClientLogServerPrx = Slice.defineProxy(Ice.ObjectPrx, LogSpace.ClientLogServer.ice_staticId, undefined);

    Slice.defineOperations(LogSpace.ClientLogServer, LogSpace.ClientLogServerPrx,
    {
        "log": [, , , , , , [["Ice.ByteSeqHelper"]], , , , ],
        "logFatal": [, , , , , , [[LogSpace.FatalLogInfo]], , , , ],
        "usrReport": [, , , , , , [[LogSpace.UsrReportInfo]], , , , ],
        "logDetail": [, , , , , , [[3], [7], ["Ice.ByteSeqHelper"]], , , , ]
    });
    exports.LogSpace = LogSpace;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all fieldѕ are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this.localDescription = null;
    this.remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // ѕdpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete‥
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc.localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc.localDescription.sdp =
          SDPUtils.getDescription(pc.localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc.remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc.localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if ((kind === 'application' && protocol === 'DTLS/SCTP') || rejected) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc.remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
      states[transceiver.dtlsTransport.state]++;
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc.remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc.remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc.remoteDescription.sdp =
              SDPUtils.getDescription(pc.remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc.remoteDescription.sdp =
              SDPUtils.getDescription(pc.remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function() {
    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    var fixStatsType = function(stat) {
      return {
        inboundrtp: 'inbound-rtp',
        outboundrtp: 'outbound-rtp',
        candidatepair: 'candidate-pair',
        localcandidate: 'local-candidate',
        remotecandidate: 'remote-candidate'
      }[stat.type] || stat.type;
    };
    return new Promise(function(resolve) {
      // shim getStats with maplike support
      var results = new Map();
      Promise.all(promises).then(function(res) {
        res.forEach(function(result) {
          Object.keys(result).forEach(function(id) {
            result[id].type = fixStatsType(result[id]);
            results.set(id, result[id]);
          });
        });
        resolve(results);
      });
    });
  };

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};

},{"sdp":2}],2:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress); // was: relAddr
    sdp.push('rport');
    sdp.push(candidate.relatedPort); // was: relPort
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  // was: channels
  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      params.push(param + '=' + codec.parameters[param]);
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  caps.headerExtensions.forEach(function(extension) {
    sdp += SDPUtils.writeExtmap(extension);
  });
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.split(' ');
    parts.shift();
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
        rtx: {
          ssrc: secondarySsrc
        }
      };
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
}

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}],3:[function(require,module,exports){
(function (global){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var adapterFactory = require('./adapter_factory.js');
module.exports = adapterFactory({window: global.window});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapter_factory.js":4}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var utils = require('./utils');
// Shimming starts here.
module.exports = function(dependencies, opts) {
  var window = dependencies && dependencies.window;

  var options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true,
  };

  for (var key in opts) {
    if (hasOwnProperty.call(opts, key)) {
      options[key] = opts[key];
    }
  }

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;
  var commonShim = require('./common_shim') || null;

  // Export to the adapter global object visible in the browser.
  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;
      commonShim.shimCreateObjectURL(window);

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimSourceObject(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;
      commonShim.shimCreateObjectURL(window);

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimSourceObject(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;
      commonShim.shimCreateObjectURL(window);

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;
      commonShim.shimCreateObjectURL(window);

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);
      safariShim.shimCreateOfferLegacy(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
};

},{"./chrome/chrome_shim":5,"./common_shim":7,"./edge/edge_shim":8,"./firefox/firefox_shim":10,"./safari/safari_shim":12,"./utils":13}],5:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimMediaStream: function(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        }
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!pc._ontrackpoly) {
          pc._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = {track: te.track};
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = {track: track};
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
          };
          pc.addEventListener('addstream', pc._ontrackpoly);
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    } else if (!('RTCRtpTransceiver' in window)) {
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        if (!e.transceiver) {
          e.transceiver = {receiver: e.receiver};
        }
        return e;
      });
    }
  },

  shimGetSendersWithDtmf: function(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
          var pc = this;
          var sender = origAddTrack.apply(pc, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(pc, track);
            pc._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function(sender) {
          var pc = this;
          origRemoveTrack.apply(pc, arguments);
          var idx = pc._senders.indexOf(sender);
          if (idx !== -1) {
            pc._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origAddStream.apply(pc, [stream]);
        stream.getTracks().forEach(function(track) {
          pc._senders.push(shimSenderWithDtmf(pc, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origRemoveStream.apply(pc, [stream]);

        stream.getTracks().forEach(function(track) {
          var sender = pc._senders.find(function(s) {
            return s.track === track;
          });
          if (sender) {
            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
          }
        });
      };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  },

  shimSourceObject: function(window) {
    var URL = window && window.URL;

    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return undefined;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimAddTrackRemoveTrackWithNative: function(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {
        return pc._shimmedLocalStreams[streamId][0];
      });
    };

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      var sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      var existingSenders = pc.getSenders();
      origAddStream.apply(this, arguments);
      var newSenders = pc.getSenders().filter(function(newSender) {
        return existingSenders.indexOf(newSender) === -1;
      });
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {
          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            pc._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (pc._shimmedLocalStreams[streamId].length === 1) {
            delete pc._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  },

  shimAddTrackRemoveTrack: function(window) {
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 65) {
      return this.shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype
        .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      var nativeStreams = origGetLocalStreams.apply(this);
      pc._reverseStreams = pc._reverseStreams || {};
      return nativeStreams.map(function(stream) {
        return pc._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!pc._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(pc, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
      delete pc._reverseStreams[(pc._streams[stream.id] ?
          pc._streams[stream.id].id : stream.id)];
      delete pc._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(function(t) {
            return t === track;
          })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      var alreadyExists = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};
      var oldStream = pc._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function() {
          pc.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        pc.addStream(newStream);
      }
      return pc.getSenders().find(function(s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
            externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
            internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function() {
        var pc = this;
        var args = arguments;
        var isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(pc, [
            function(description) {
              var desc = replaceInternalStreamId(pc, description);
              args[0].apply(null, [desc]);
            },
            function(err) {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(pc, arguments)
        .then(function(description) {
          return replaceInternalStreamId(pc, description);
        });
      };
    });

    var origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function() {
      var pc = this;
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(pc, arguments);
      }
      arguments[0] = replaceExternalStreamId(pc, arguments[0]);
      return origSetLocalDescription.apply(pc, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(
        window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
        'localDescription', {
          get: function() {
            var pc = this;
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(pc, description);
          }
        });

    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === pc;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      pc._streams = pc._streams || {};
      var stream;
      Object.keys(pc._streams).forEach(function(streamid) {
        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = pc._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          pc.removeStream(pc._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        pc.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        // Translate iceTransportPolicy to iceTransports,
        // see https://code.google.com/p/webrtc/issues/detail?id=4869
        // this was fixed in M56 along with unprefixing RTCPeerConnection.
        logging('PeerConnection');
        if (pcConfig && pcConfig.iceTransportPolicy) {
          pcConfig.iceTransports = pcConfig.iceTransportPolicy;
        }

        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.webkitRTCPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if (window.webkitRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.webkitRTCPeerConnection.generateCertificate;
          }
        });
      }
    } else {
      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
      var OrigPeerConnection = window.RTCPeerConnection;
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (pcConfig && pcConfig.iceServers) {
          var newIceServers = [];
          for (var i = 0; i < pcConfig.iceServers.length; i++) {
            var server = pcConfig.iceServers[i];
            if (!server.hasOwnProperty('urls') &&
                server.hasOwnProperty('url')) {
              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
              server = JSON.parse(JSON.stringify(server));
              server.urls = server.url;
              newIceServers.push(server);
            } else {
              newIceServers.push(pcConfig.iceServers[i]);
            }
          }
          pcConfig.iceServers = newIceServers;
        }
        return new OrigPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(selector,
        successCallback, errorCallback) {
      var pc = this;
      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(function(key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
      }

      // promise-support
      return new Promise(function(resolve, reject) {
        origGetStats.apply(pc, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(successCallback, errorCallback);
    };

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            window.RTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var pc = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(pc, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // promise support for createOffer and createAnswer. Available (without
    // bugs) since M52: crbug/619289
    if (browserDetails.version < 52) {
      ['createOffer', 'createAnswer'].forEach(function(method) {
        var nativeMethod = window.RTCPeerConnection.prototype[method];
        window.RTCPeerConnection.prototype[method] = function() {
          var pc = this;
          if (arguments.length < 1 || (arguments.length === 1 &&
              typeof arguments[0] === 'object')) {
            var opts = arguments.length === 1 ? arguments[0] : undefined;
            return new Promise(function(resolve, reject) {
              nativeMethod.apply(pc, [resolve, reject, opts]);
            });
          }
          return nativeMethod.apply(this, arguments);
        };
      });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
};

},{"../utils.js":13,"./getusermedia":6}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;

  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      var remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().indexOf(match) !== -1;
              });
            });
            if (!dev && devices.length && matches.indexOf('back') !== -1) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return window.MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                kind: kinds[device.kind],
                deviceId: device.id,
                groupId: ''};
            }));
          });
        });
      },
      getSupportedConstraints: function() {
        return {
          deviceId: true, echoCancellation: true, facingMode: true,
          frameRate: true, height: true, width: true
        };
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":13}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var utils = require('./utils');

module.exports = {
  shimRTCIceCandidate: function(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype)) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        var nativeCandidate = new NativeRTCIceCandidate(args);
        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        var augmentedCandidate = Object.assign(nativeCandidate,
            parsedCandidate);

        // Add a serializer that does not serialize the extra attributes.
        augmentedCandidate.toJSON = function() {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment,
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  },

  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

  shimCreateObjectURL: function(window) {
    var URL = window && window.URL;

    if (!(typeof window === 'object' && window.HTMLMediaElement &&
          'srcObject' in window.HTMLMediaElement.prototype &&
        URL.createObjectURL && URL.revokeObjectURL)) {
      // Only shim CreateObjectURL using srcObject if srcObject exists.
      return undefined;
    }

    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
    var streams = new Map(), newId = 0;

    URL.createObjectURL = function(stream) {
      if ('getTracks' in stream) {
        var url = 'polyblob:' + (++newId);
        streams.set(url, stream);
        utils.deprecated('URL.createObjectURL(stream)',
            'elem.srcObject = stream');
        return url;
      }
      return nativeCreateObjectURL(stream);
    };
    URL.revokeObjectURL = function(url) {
      nativeRevokeObjectURL(url);
      streams.delete(url);
    };

    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                                              'src');
    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
      get: function() {
        return dsc.get.apply(this);
      },
      set: function(url) {
        this.srcObject = streams.get(url) || null;
        return dsc.set.apply(this, [url]);
      }
    });

    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
    window.HTMLMediaElement.prototype.setAttribute = function() {
      if (arguments.length === 2 &&
          ('' + arguments[0]).toLowerCase() === 'src') {
        this.srcObject = streams.get(arguments[1]) || null;
      }
      return nativeSetAttribute.apply(this, arguments);
    };
  },

  shimMaxMessageSize: function(window) {
    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get: function() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    var sctpInDescription = function(description) {
      var sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some(function(mediaSection) {
        var mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application'
            && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    var getRemoteFirefoxVersion = function(description) {
      // TODO: Is there a better solution for detecting Firefox?
      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      var version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    var getCanSendMaxMessageSize = function(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      var canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize =
            browserDetails.version === 57 ? 65535 : 65536;
        }
      }
      return canSendMaxMessageSize;
    };

    var getMaxMessageSize = function(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      var maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox'
           && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === 'firefox' &&
                  remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    var origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function() {
      var pc = this;
      pc._sctp = null;

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        var isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        var canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        var maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        var sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get: function() {
            return maxMessageSize;
          }
        });
        pc._sctp = sctp;
      }

      return origSetRemoteDescription.apply(pc, arguments);
    };
  },

  shimSendThrowTypeError: function(window) {
    if (!(window.RTCPeerConnection &&
        'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    var origCreateDataChannel =
      window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function() {
      var pc = this;
      var dataChannel = origCreateDataChannel.apply(pc, arguments);
      var origDataChannelSend = dataChannel.send;

      // Patch 'send' method
      dataChannel.send = function() {
        var dc = this;
        var data = arguments[0];
        var length = data.length || data.size || data.byteLength;
        if (length > pc.sctp.maxMessageSize) {
          throw new DOMException('Message too large (can send a maximum of ' +
            pc.sctp.maxMessageSize + ' bytes)', 'TypeError');
        }
        return origDataChannelSend.apply(dc, arguments);
      };

      return dataChannel;
    };
  }
};

},{"./utils":13,"sdp":2}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var shimRTCPeerConnection = require('rtcpeerconnection-shim');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(
            window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
    // Edge currently only implements the RTCDtmfSender, not the
    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
    if (window.RTCDtmfSender && !window.RTCDTMFSender) {
      window.RTCDTMFSender = window.RTCDtmfSender;
    }

    window.RTCPeerConnection =
        shimRTCPeerConnection(window, browserDetails.version);
  },
  shimReplaceTrack: function(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender &&
        !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack =
          window.RTCRtpSender.prototype.setTrack;
    }
  }
};

},{"../utils":13,"./getusermedia":9,"rtcpeerconnection-shim":1}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function(window) {
  var navigator = window && window.navigator;

  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.transceiver = {receiver: event.receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimSourceObject: function(window) {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (window.mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = window.mozRTCSessionDescription;
      window.RTCIceCandidate = window.mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      var map = new Map();
      Object.keys(stats).forEach(function(key) {
        map.set(key, stats[key]);
        map[key] = stats[key];
      });
      return map;
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(
      selector,
      onSucc,
      onErr
    ) {
      return nativeGetStats.apply(this, [selector || null])
        .then(function(stats) {
          if (browserDetails.version < 48) {
            stats = makeMapStats(stats);
          }
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(function(stat) {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach(function(stat, i) {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  },

  shimRemoveStream: function(window) {
    if (!window.RTCPeerConnection ||
        'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      utils.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(function(sender) {
        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {
          pc.removeTrack(sender);
        }
      });
    };
  }
};

},{"../utils":13,"./getusermedia":11}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  var shimError_ = function(e) {
    return {
      name: {
        InternalError: 'NotReadableError',
        NotSupportedError: 'TypeError',
        PermissionDeniedError: 'NotAllowedError',
        SecurityError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":13}],12:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var utils = require('../utils');

module.exports = {
  shimLocalStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getStreamById = function(id) {
        var result = null;
        if (this._localStreams) {
          this._localStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        if (this._remoteStreams) {
          this._remoteStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        return result;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (this._localStreams.indexOf(stream) === -1) {
          this._localStreams.push(stream);
        }
        var pc = this;
        stream.getTracks().forEach(function(track) {
          _addTrack.call(pc, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (this._localStreams.indexOf(stream) === -1) {
            this._localStreams.push(stream);
          }
        }
        return _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var pc = this;
        var tracks = stream.getTracks();
        this.getSenders().forEach(function(sender) {
          if (tracks.indexOf(sender.track) !== -1) {
            pc.removeTrack(sender);
          }
        });
      };
    }
  },
  shimRemoteStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function() {
          return this._onaddstream;
        },
        set: function(f) {
          var pc = this;
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            e.streams.forEach(function(stream) {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
      });
    }
  },
  shimCallbacksAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  },
  shimGetUserMedia: function(window) {
    var navigator = window && window.navigator;

    if (!navigator.getUserMedia) {
      if (navigator.webkitGetUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
      } else if (navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia) {
        navigator.getUserMedia = function(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
        }.bind(navigator);
      }
    }
  },
  shimRTCIceServerUrls: function(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  },
  shimTrackEventTransceiver: function(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCPeerConnection &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
        // defined for some reason even when window.RTCTransceiver is not.
        !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimCreateOfferLegacy: function(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {
      var pc = this;
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          pc.addTransceiver('audio');
        }


        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            videoTransceiver.setDirection('sendonly');
          } else if (videoTransceiver.direction === 'recvonly') {
            videoTransceiver.setDirection('inactive');
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          pc.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(pc, arguments);
    };
  }
};

},{"../utils":13}],13:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object.
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function(e) {
      cb(wrapper(e));
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function() {
      return this['_on' + eventNameToWrap];
    },
    set: function(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    }
  });
}

// Utility methods.
module.exports = {
  extractVersion: extractVersion,
  wrapPeerConnectionEvent: wrapPeerConnectionEvent,
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  disableWarnings: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  deprecated: function(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function(window) {
    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    if (navigator.mozGetUserMedia) { // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent,
          /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
      result.browser = 'edge';
      result.version = extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.RTCPeerConnection &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent,
          /AppleWebKit\/(\d+)\./, 1);
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

},{}]},{},[3])(3)
});
/**
     * requestAnimationFrame兼容性扩展，两方面工作：
     * 1、把各浏览器前缀进行统一
     * 2、在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法
     * */
    (function() {
        var lastTime = 0;
        var vendors = ["webkit", "moz"];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            // Webkit中此取消方法的名字变了
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
        }
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
                var id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
        }
    }());
if (!Function.prototype.bind) 
{   
	Function.prototype.bind = function (oThis) 
	{   
		if (typeof this !== "function") 
		{ 
			throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");   
		}   
		var aArgs = Array.prototype.slice.call(arguments, 1),   
		fToBind = this,   
		fNOP = function () {},   
		fBound = function () 
		{   
			return fToBind.apply(this instanceof fNOP && oThis   
			? this   
			: oThis,   
			aArgs.concat(Array.prototype.slice.call(arguments)));   
		};   
		fNOP.prototype = this.prototype;   
		fBound.prototype = new fNOP();   
		return fBound;   
	};   
}   

/**
 * 云屋web直播h5
 * @version 1.0.0
 */
this.Cr={};
this.Cr.__init = false;
/* Centralized function for browser feature detection
	- User agent string detection is only used when no good alternative is possible
	- Is executed directly for optimal performance
*/
Cr._ua = function () 
{
	var win = window;
    var doc = document;
    var nav = navigator;
    var SHOCKWAVE_FLASH = "Shockwave Flash";
    var SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash";
    var FLASH_MIME_TYPE = "application/x-shockwave-flash";
    var w3cdom = typeof doc.getElementById !== "undefined" && typeof doc.getElementsByTagName !== "undefined" && typeof doc.createElement !== "undefined";
    var u = nav.userAgent.toLowerCase();
    var p = nav.platform.toLowerCase();
    var windows = p ? /win/.test(p) : /win/.test(u);
    var mac = p ? /mac/.test(p) : /mac/.test(u);
    var webkit = /webkit/.test(u) ? parseFloat(u.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false;// returns either the webkit version or false if not webkit
    var ie = nav.appName === "Microsoft Internet Explorer";
    var playerVersion = [0, 0, 0];
    var d = null;
	if (typeof nav.plugins !== "undefined" && typeof nav.plugins[SHOCKWAVE_FLASH] === "object") {
		d = nav.plugins[SHOCKWAVE_FLASH].description;
		// nav.mimeTypes["application/x-shockwave-flash"].enabledPlugin indicates whether plug-ins are enabled or disabled in Safari 3+
		if (d && (typeof nav.mimeTypes !== "undefined" && nav.mimeTypes[FLASH_MIME_TYPE] && nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) {
			plugin = true;
			ie = false; // cascaded feature detection for Internet Explorer
			d = d.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
			playerVersion[0] = parseInt(d.replace(/^(.*)\..*$/, "$1"), 10);
			playerVersion[1] = parseInt(d.replace(/^.*\.(.*)\s.*$/, "$1"), 10);
			playerVersion[2] = /[a-zA-Z]/.test(d) ? parseInt(d.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0;
		}
	}
	else if (typeof win.ActiveXObject !== "undefined") {
		try {
			var a = new ActiveXObject(SHOCKWAVE_FLASH_AX);
			if (a) { // a will return null when ActiveX is disabled
				d = a.GetVariable("$version");
				if (d) {
					ie = true; // cascaded feature detection for Internet Explorer
					d = d.split(" ")[1].split(",");
					playerVersion = [parseInt(d[0],10), parseInt(d[1],10), parseInt(d[2],10)];
				}
			}
		}
		catch (e) {}
	}
	return {w3: w3cdom, pv: playerVersion, wk: webkit, ie: ie, win: windows, mac: mac};
}()
/**
 * @class
 */
Cr.CbProxy = function(name)
{
	this.name = name;
	this.callback = null;
}
Cr.CbProxy.prototype.call = function(args)
{
	if(this.callback && typeof(this.callback) == 'function')
	{
		this.callback.apply(null,args);
	}
}
/**
 * 接受到的消息信息
 * @class
 * @property {number} index - 消息索引
 * @property {string} msg - 消息体
 * @property {string} head - 头像
 * @property {number} sendTime - 发送时间戳
 * @property {string} targetNickname - 目标昵称
 * @property {number} targetTermId - 目标id
 * @property {string} srcNickname - 发送者昵称
 * @property {number} srcTermId - 发送者id
 * @property {bool} ishost - 是否主持人
 */
Cr.MsgInfo = function(data)
{
    this.type = data["type"];
	this.index = data["index"];
	this.msg = data["msg"];
	this.head = data["head"];
	this.sendTime = data["sendTime"];
	this.targetNickname = data["targetNickname"];
	this.targetTermId = data["targetTermId"];
	this.srcNickname = data["srcNickname"];
	this.srcTermId = data["srcTermId"];
	this.ishost = data["ishost"];
}
/**
 * 会议信息
 * @class
 * @property {number} termId - 用户id
 * @property {array} activeMembers - 成员列表
 * @property {string} myDetail - 用户详细信息
 * @property {bool} isBegan - 会议是否已开始
 * @property {number} countdown - 倒计时
 * @property {number} mainVideoTermID - 目标id
 * @property {string} pstnnum - pstn接入号
 * @property {string} pstnpwd - pstn接入密码
 * @property {bool} freeConf - 是否免费会议
 * @property {bool} isBroadcating - 是否直播
 * @property {string} webViewerRights - 直播权限
 * @property {bool} webviewerQues - 是否显示问答
 */
Cr.MeetInfo = function(data)
{

	this.termId = data["termId"];
	this.activeMembers = data["activeMembers"];
	this.myDetail = data["myDetail"];
	this.serverTime = data["serverTime"];
	this.isBegan = data["isBegan"];
	this.countdown = data["countdown"];
	this.mainVideoTermID = data["mainVideoTermID"];
	this.pstnnum = data["pstnnum"];
	this.pstnpwd = data["pstnpwd"];
	this.freeConf = data["freeConf"];
	this.isBroadcating = data["isBroadcating"];
	this.webViewerRights = data["webViewerRights"];
	this.webviewerQues = data["webviewerQues"];

}
/**
 * 提问
 * @class
 * @property {string} typeID - 问题类型ID
 * @property {number} asktime - 时间
 * @property {number} termID - 提问人ID
 * @property {string} content - 提问内容
 * @property {string} headUrl - 头像地址
 * @property {string} nickname - 提问人昵称

 */
Cr.Quesask = function(data)
{

	this.typeID = data["typeID"];
	this.asktime = data["asktime"];
	this.termID = data["termID"];
	/*var arr = Cr.Utils.ask2html(data["content"]);
	this.content = arr[1];
	this.headUrl = arr[0];*/
	this.content = data["content"];
	this.nickname = data["nickname"];
}
/**
* 问题状态
* @readonly
* @enum {number}
*/
Cr_Question_State = 
{
	/**未答复*/
	NotReply:0,   
	 /** 答复中，锁定  */         
	Replying:1,             //
	 /** 已答复，未公开  */    
	NotPublic:2,          //
	 /** 公开的已答复问题 */    
	Publiced:3,              //
	/** 问题已删除 */ 
	Deleted:4
}
/**
 * 提问回应
 * @class
 * @property {number} state - 问题状态
 * @property {string} replyCon - 问题答复或修改,回复的内容 
 * @property {number} replyTermId - 最后处理人ID
 * @property {number} replyTime - 答复时间
 * @property {number} publishTermID - 问题公布人ID
 * @property {number} publishTime - 公布时间
 * @property {number} delTermID - 问题删除人ID 
 * @property {number} delTime - 删除时间
 */
Cr.QuesDeal = function(data)
{

	this.state = data["state"]._value;
	this.replyCon = data["replyCon"];
	this.replyTermId = data["replyTermId"];
	this.replyTime = data["replyTime"];
	this.publishTermID = data["publishTermID"];
	this.publishTime = data["publishTime"];
	this.delTermID = data["delTermID"];
	this.delTime = data["delTime"];
}
/**
 * 问题
 * @class
 * @property {string} quesID - 问题id
 * @property {Cr.Quesask} ask - 提问
 * @property {Cr.QuesDeal} deal - 提问回应

 */
Cr.QuesInf = function(data)
{

	this.quesID = data["quesID"];
	this.ask = new Cr.Quesask(data["ask"]);
	this.deal = new Cr.QuesDeal(data["deal"]);

}
/**
 * 异步代理返回
 * @author deva.wang <deva.wang@cloudroom.com>
 * @constructor
 */	
Cr.AsyncResult = function()
{
}
/**
 * 继续，当异步代理返回时将调用fun方法
 * @access public
 * @param {function} fun - 要调用的方法
 */	
Cr.AsyncResult.prototype.then = function(fun)
{
	this.__child = new Cr.AsyncResult();
	this.__complete = fun;
	return this.__child;
}
 /** @access private */
Cr.AsyncResult.prototype.complete = function(args)
{
	var step = function ()
	{
		this.next(args);
		if(this.__parent && typeof(this.__parent.next) == 'function')
		{
			this.__parent.next(args);
		}
	}.bind(this)
	window.requestAnimationFrame(step);

}
 /** @access private */
Cr.AsyncResult.prototype.next = function(args)
{
	if(this.__complete && typeof(this.__complete) == 'function')
	{
		var async = this.__complete.apply(this,args);
		if(async && this.__child)
		{
			async.__parent = this.__child;
		}
	}
}

 /** @access private */
Cr.AsyncResult2As = function(id,proxy)
{
	this.id = id;
	this.proxy = proxy;
}
 /** @access private */
Cr.AsyncResult2As.prototype.complete = function(args)
{
	args.unshift(this.id);
	this.proxy.callback.apply(this.proxy,args);
}
 /** @access private */
Cr.Swf = 
{
	__callbackId_generator:0,
	__generateCallbackId:function()
	{
		return Cr.Swf.__callbackId_generator++;	
	},
	__callbackAsyncDict:{},
	__registerCallbackAsync:function(id,async)
	{
		if(!Cr.Swf.__callbackAsyncDict[id])
		{
			Cr.Swf.__callbackAsyncDict[id] = async;
		}else
		{
			throw "register swf callback error:duplicate id"; 
		}
	},
	asyncAsCallback:function()
	{
		if(arguments.length >= 1)
		{
			var args = new Array(arguments.length);
			for(var i = 0; i < args.length; ++i)
				args[i] = arguments[i];
				
			var id = args.shift();
			var async = Cr.Swf.__callbackAsyncDict[id]
			if(async)
			{
				async.complete(args);
			}else
			{
				throw "swf callback error:async not exist"; 
			}
		}else
		{
			throw "swf callback error:arguments deficient"; 
		}
	},
	
	callJs:function()
	{
		if(arguments.length >= 2)
		{
			var args = new Array(arguments.length);
			for(var i = 0; i < args.length; ++i)
				args[i] = arguments[i];
			cmd = args.shift();
			id = args.shift();
			
			cmdObj = Cr.Swf.__asCallbackCmdDict[cmd];
			if(cmdObj)
			{
				var fun = cmdObj["fun"];
				var proxy = cmdObj["proxy"];
				/*var async = Cr.AsyncResult2As(id,proxy);
				args.unshift(async);*/
				fun.call(null,args);
			}
		}
	},
	__asCallbackCmdDict:{},
	addAsCallback:function(cmd,fun,proxy)
	{
		if(!Cr.Swf.__asCallbackCmdDict[cmd])
		{
			Cr.Swf.__asCallbackCmdDict[cmd] = {"fun":fun,"proxy":proxy};
		}else
		{
			throw "register swf callback error:duplicate id"; 
		}
	}
}
Cr.crmt = null;
Cr.Utils = 
{
	//生存uuid
	generate_uuid:function () {

		var s = [];

		var hexDigits = "0123456789abcdef";

		for (var i = 0; i < 36; i++) {

			s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);

		}

		s[14] = "4";  // bits 12-15 of the time_hi_and_version field to 0010

		s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01

		s[8] = s[13] = s[18] = s[23] = "-";

	 

		var uuid = s.join("");

		return uuid;

	},
	//写cookies
	setCookie:function(name,value)
	{
		var Days = 30;
		var exp = new Date();
		exp.setTime(exp.getTime() + Days*24*60*60*1000);
		document.cookie = name + "="+ escape (value) + ";expires=" + exp.toGMTString();
	},
	//读取cookies
	getCookie:function(name)
	{
		var reg=new RegExp("(^| )"+name+"=([^;]*)(;|$)");
		var arr=document.cookie.match(reg);
		if(arr)
		{
			return unescape(arr[2]);
		}
		else
		{
			return;
		}
	},

	//删除cookies
	delCookie:function(name)
	{
		var exp = new Date();
		exp.setTime(exp.getTime() - 1);
		var cval=Utils.getCookie(name);
		if(cval!=null)
		document.cookie= name + "="+cval+";expires="+exp.toGMTString();
	},
	//Uint8Array to String
	Uint8ToString:function(u8a)
	{
	  var CHUNK_SZ = 0x8000;
	  var c = [];
	  for (var i=0; i < u8a.length; i+=CHUNK_SZ) {
		c.push(String.fromCharCode.apply(null, u8a.subarray(i, i+CHUNK_SZ)));
	  }
	  return c.join("");
	},
	//Uint8Array to base64	
	Uint8ToBase64:function(u8Arr)
	{
	  var CHUNK_SIZE = 0x8000; //arbitrary number
	  var index = 0;
	  var length = u8Arr.length;
	  var result = '';
	  var slice;
	  while (index < length) {
		slice = u8Arr.subarray(index, Math.min(index + CHUNK_SIZE, length)); 
		result += String.fromCharCode.apply(null, slice);
		index += CHUNK_SIZE;
	  }
	  return btoa(result);
	},
	//定义一个比较器 
	compare:function(propertyName) 
	{ 
		return function (object1, object2) { 
			var value1 = object1[propertyName]; 
			var value2 = object2[propertyName]; 
			if (value2 > value1) { 
				return -1; 
			} else if (value2 < value1) { 
				return 1; 
			} else { 
				return 0; 
			} 
		} 
	},
	//深拷贝
	deepCopy:function(source) { 
		var result={};
		for (var key in source) {
		  result[key] = typeof(source[key])==='object'? deepCoyp(source[key]): source[key];
	   } 
	   return result; 
	},
	//解析聊天
	chat2html:function(context,fontColor,fontSize) { 
		//type 0正常消息  1-移动端发红包 11 pc发红包 2-移动端抢金红包 12-pc抢到红包 3-移动端打赏 13-pc发打赏 4-移动端收打赏 14-pc收到打赏 5-移动端发送礼 15-pc端发送礼 6-pc端收到送礼 16-pc端收到送礼
		var newContext = "",type="",headimg="";
		if(context.indexOf("0x10x4") >= 0){
            var newContext = context.split("0x10x4")[1];
            if(newContext.indexOf("0x1") >= 0){
            	newContext = newContext.split("0x1")[0];
            }
            newContext = $.parseJSON(newContext); 
            type = newContext.opt; //type 1 发红包 2 抢红包 3 其他信息
            headimg = newContext.headerUrl;
        }else if(context.indexOf("0x10x5") >= 0){
        	var newContext = context.split("0x10x5")[1];
            if(newContext.indexOf("0x1") >= 0){
            	newContext = newContext.split("0x1")[0];
            }
            newContext = $.parseJSON(newContext); 
            type = newContext.opt;
            headimg = newContext.headerUrl;
        }else if(context.indexOf("0x10x6") >= 0){
        	var newContext = context.split("0x10x6")[1];
            if(newContext.indexOf("0x1") >= 0){
            	newContext = newContext.split("0x1")[0];
            }
            newContext = $.parseJSON(newContext); 
            type = newContext.opt; 
            headimg = newContext.headerUrl;
        }else{
			if(Cr._imgRegExp == null)
			{
				Cr._sign = Cr.Utils.utf8ByteToUnicodeStr([1]);
				Cr._signB = Cr.Utils.utf8ByteToUnicodeStr([2]);
				Cr._signA = Cr.Utils.utf8ByteToUnicodeStr([3]);
				Cr._imgRegExp = new RegExp(Cr._sign+Cr._sign+"\:*\/*([^"+Cr._sign+"]+?)"+Cr._sign,"g");
				Cr._headimgRegExp = new RegExp(Cr._sign+Cr._signA+"\:*\/*([^"+Cr._sign+"]+?)"+Cr._sign,"g");
				Cr._captureRegExp = new RegExp(Cr._sign+Cr._signB+"\:*\/*([^"+Cr._sign+"]+?)"+Cr._sign,"g");
			}
			newContext  = context.replace(/<br\/>/g,"\n");
			newContext = newContext.replace(/&quot;/g,"\"");
			newContext = newContext.replace(/&lt;/g,"<");
			newContext = newContext.replace(/&gt;/g,">");
			newContext = newContext.replace(/\&/g,"&amp;");
			newContext = newContext.replace(/\"/g,"&quot;");
			newContext = newContext.replace(/\</g,"&lt;");
			newContext = newContext.replace(/\>/g,"&gt;");
			newContext = newContext.replace(Cr._imgRegExp,"<img  src=\"$1\"></img>");
			newContext = newContext.replace(Cr._captureRegExp,"");
			//var headimgArr = newContext.match(Cr._headimgRegExp);
			var headimgArr = Cr._headimgRegExp.exec(newContext);
			if(headimgArr)
			{
				var headimg = headimgArr[1]
			}
			newContext = newContext.replace(Cr._headimgRegExp,"")
			
			var color = (0xFFFFFF&fontColor).toString(16)
			var len = 6 - color.length
			for (var i=0;i<len;i++)
			{
				color = "0"+color
			}
			newContext = "<p style=\"color:#"+color+";font-size:"+fontSize+"\">" + newContext +"</p>"; 
			type = 0;
		}
		return [type,headimg,newContext];
	},
	//解析聊天
	html2chat:function(newContext) { 
		if(Cr._imgRegExp == null)
		{
			Cr._sign = Cr.Utils.utf8ByteToUnicodeStr([1]);
			Cr._signB = Cr.Utils.utf8ByteToUnicodeStr([2]);
			Cr._signA = Cr.Utils.utf8ByteToUnicodeStr([3]);
			Cr._imgRegExp = new RegExp(Cr._sign+Cr._sign+"\:*\/*([^"+Cr._sign+"]+?)"+Cr._sign,"g");
			Cr._headimgRegExp = new RegExp(Cr._sign+Cr._signA+"\:*\/*([^"+Cr._sign+"]+?)"+Cr._sign,"g");
			Cr._captureRegExp = new RegExp(Cr._sign+Cr._signB+"\:*\/*([^"+Cr._sign+"]+?)"+Cr._sign,"g");
		}
		newContext = newContext.replace(/\<headimg\s+src=[\"\']([^\"\']*?)[\"\']\s*\/\>/gi,Cr._sign+Cr._signA+":$1"+Cr._sign);
		newContext = newContext.replace(/\<headimg\s+src=[\"\']([^\"\']*?)[\"\']\s*\>.*?\<\/s*imgs*\>/gi,Cr._sign+Cr._signA+":$1"+Cr._sign);
		newContext = newContext.replace(/\<img\s+[^>]*?src=[\"\']([\w\/\.\:]*)[\"\'][^>]*\/\>/gi,Cr._sign+Cr._sign+":/$1"+Cr._sign);
		newContext = newContext.replace(/\<img\s+[^>]*?src=[\"\']([\w\/\.\:]*)[\"\'][^>]*\>.*?\<\/s*imgs*\>/gi,Cr._sign+Cr._sign+":/$1"+Cr._sign);
		
	   return [newContext]; 
	},
	//解析聊天
	ask2html:function(context) { 
		if(Cr._imgRegExp == null)
		{
			Cr._sign = Cr.Utils.utf8ByteToUnicodeStr([1]);
			Cr._signA = Cr.Utils.utf8ByteToUnicodeStr([3]);
			Cr._imgRegExp = new RegExp(Cr._sign+Cr._sign+"\:*\/*([^"+Cr._sign+"]+?)"+Cr._sign,"g");
			Cr._headimgRegExp = new RegExp(Cr._sign+Cr._signA+"\:*\/*([^"+Cr._sign+"]+?)"+Cr._sign,"g");
		}
		var newContext  = context.replace(/<br\/>/g,"\n");
		newContext = newContext.replace(/\&/g,"&amp;");
		newContext = newContext.replace(/\"/g,"&quot;");
		newContext = newContext.replace(/\</g,"&lt;");
		newContext = newContext.replace(/\>/g,"&gt;");
		newContext = newContext.replace(Cr._imgRegExp,"<img  src=\"$1\"></img>")
		//var headimgArr = newContext.match(Cr._headimgRegExp);
		var headimgArr = Cr._headimgRegExp.exec(newContext);

		if(headimgArr)
		{
			var headimg = headimgArr[1]
		}
		newContext = newContext.replace(Cr._headimgRegExp,"")
		newContext = newContext;
	   return [headimg,newContext]; 
	},
	/**
	 * utf8 byte to unicode string
	 * @param utf8Bytes
	 * @returns {string}
	 */
	utf8ByteToUnicodeStr:function(utf8Bytes)
	{
		var unicodeStr ="";
		for (var pos = 0; pos < utf8Bytes.length;){
			var flag= utf8Bytes[pos];
			var unicode = 0 ;
			if ((flag >>>7) === 0 ) {
				unicodeStr+= String.fromCharCode(utf8Bytes[pos]);
				pos += 1;
	 
			} else if ((flag &0xFC) === 0xFC ){
				unicode = (utf8Bytes[pos] & 0x3) << 30;
				unicode |= (utf8Bytes[pos+1] & 0x3F) << 24;
				unicode |= (utf8Bytes[pos+2] & 0x3F) << 18;
				unicode |= (utf8Bytes[pos+3] & 0x3F) << 12;
				unicode |= (utf8Bytes[pos+4] & 0x3F) << 6;
				unicode |= (utf8Bytes[pos+5] & 0x3F);
				unicodeStr+= String.fromCharCode(unicode) ;
				pos += 6;
	 
			}else if ((flag &0xF8) === 0xF8 ){
				unicode = (utf8Bytes[pos] & 0x7) << 24;
				unicode |= (utf8Bytes[pos+1] & 0x3F) << 18;
				unicode |= (utf8Bytes[pos+2] & 0x3F) << 12;
				unicode |= (utf8Bytes[pos+3] & 0x3F) << 6;
				unicode |= (utf8Bytes[pos+4] & 0x3F);
				unicodeStr+= String.fromCharCode(unicode) ;
				pos += 5;
	 
			} else if ((flag &0xF0) === 0xF0 ){
				unicode = (utf8Bytes[pos] & 0xF) << 18;
				unicode |= (utf8Bytes[pos+1] & 0x3F) << 12;
				unicode |= (utf8Bytes[pos+2] & 0x3F) << 6;
				unicode |= (utf8Bytes[pos+3] & 0x3F);
				unicodeStr+= String.fromCharCode(unicode) ;
				pos += 4;
	 
			} else if ((flag &0xE0) === 0xE0 ){
				unicode = (utf8Bytes[pos] & 0x1F) << 12;;
				unicode |= (utf8Bytes[pos+1] & 0x3F) << 6;
				unicode |= (utf8Bytes[pos+2] & 0x3F);
				unicodeStr+= String.fromCharCode(unicode) ;
				pos += 3;
	 
			} else if ((flag &0xC0) === 0xC0 ){ //110
				unicode = (utf8Bytes[pos] & 0x3F) << 6;
				unicode |= (utf8Bytes[pos+1] & 0x3F);
				unicodeStr+= String.fromCharCode(unicode) ;
				pos += 2;
	 
			} else{
				unicodeStr+= String.fromCharCode(utf8Bytes[pos]);
				pos += 1;
			}
		}
		return unicodeStr;
	},
	log:function ()
	{
		var args = [];
		for( var i = 0; i < arguments.length; i++ )
		{  
			args.push(arguments[i]);
	    }  
		if (window["console"] && !Cr._ua.ie)
		{
			window["console"].log.apply(window["console"],args);
		}
	}
}

/** 
* sdk错误码
* @module cr/error
*/


//没有错误
/**
 * 没有错误
 * @static
 */
CR_NOERR = 0;
//------------------------------------------
//
//基础错误
//
//------------------------------------------
//未知错误
/**
 * 未知错误
 * @static
 */
CR_UNKNOWERR = 1;

//sdk内部错误   
/**
 * sdk内部错误
 * @static
 */       
CR_INNER_ERR = 3;

 //参数错误    
 /**
 * 参数错误
 * @static
 */
CR_MEETPARAM_ERR = 5;
//无效数据  
/**
 * 无效数据
 * @static
 */   
CR_ERR_DATA = 6;
 //帐号密码不正确
 /**
 * 帐号密码不正确
 * @static
 */
CR_ANCTPSWD_ERR = 7;
//服务异常	
/**
 * 服务异常
 * @static
 */	       
CR_SERVER_EXCEPTION = 8;

//------------------------------------------
//
//网络错误
//
//------------------------------------------
 //网络初始化失败
 /**
 * 网络初始化失败
 * @static
 */
CR_NETWORK_INITFAILED = 200;
//没有服务器信息
/**
 * 没有服务器信息
 * @static
 */
CR_NO_SERVERINFO = 201;
 //服务器没有响应
 /**
 * 服务器没有响应
 * @static
 */
CR_NOSERVER_RSP = 202;
//创建连接失败
/**
 * 创建连接失败
 * @static
 */
CR_CREATE_CONN_FAILED = 203;
//socket异常
/**
 * socket异常
 * @static
 */
CR_SOCKETEXCEPTION = 204;

//没有可用的服务器
/**
 * 没有可用的服务器
 * @static
 */
CR_NOTAVAILABLESERVER = 205;





//------------------------------------------
//
//会话业务错误
//
//------------------------------------------

//会议不存在或已结束
/**
 * 会议不存在或已结束
 * @static
 */
CR_MEETNOTEXIST = 800;
//会议密码不正确
/**
 * 会议密码不正确
 * @static
 */
CR_AUTHERROR = 801;
 //会议终端数量已满（购买的license不够)
 /**
 * 会议终端数量已满（购买的license不够)
 * @static
 */
CR_MEMBEROVERFLOWERROR = 802;
//分配会议资源失败
/**
 * 分配会议资源失败
 * @static
 */
CR_RESOURCEALLOCATEERROR = 803;
//会议掉线
/**
 * 会议掉线
 * @static
 */
CR_MEETOFFLINE = 804;


//用户已存在
/**
 * 用户已存在
 * @static
 */
CR_MEMBER_ALREADY_IN_MEET = 805;
//并发数超出
/**
 * 并发数超出
 * @static
 */
CR_CONCURRENCY_OVER = 806;
/**
 * 会议正在打开中
 * @static
 */
CR_MEET_IS_OPEN_ING = 807;
//------------------------------------------
//
//聊天错误
//
//------------------------------------------
//包含了敏感词
/**
 * 包含了敏感词
 * @static
 */
CR_CONTAINSSENSITIVEWORDS = 900;
/**
 * 包含了敏感词
 * @static
 */
CR_NOT_CHAT_PERMIT = 901;
/**
 * 第三方直播中
 * @static
 */
CR_THIRDPARTYLIVEISON = 1001;
/**
 * 列表直播中
 * @static
 */
CR_LISTLIVEISON = 1002;
/**
 * 客户端直播中
 * @static
 */
CR_CLIENTLIVEISON = 1003;
/**
 * 抽奖不存在
 * @static
 */
CR_LUCKYDRAWNOTEXISTS = 2001;
/**
 * 设置抽奖失败
 * @static
 */
CR_LUCKYDRAWCFGFAILS = 2002;
/**
 * 抽奖报名失败
 * @static
 */
CR_JOINLUCKYDRAWFAILS = 2003;
/**
 * 抽奖开奖失败
 * @static
 */
CR_ANNOUCELUCKYDRAWFAILS = 2004;

/** 
* sdk错误码
* @module cr/error
*/


//没有错误
/**
 * 没有错误
 * @static
 */
CRVideo_NOERR = 0;
//------------------------------------------
//
//基础错误
//
//------------------------------------------
//未知错误
/**
 * 未知错误
 * @static
 */
CRVideo_UNKNOWERR = 1;
//内存不足       
/**
 * 内存不足
 * @static
 */       
CRVideo_OUTOF_MEM = 2;
//sdk内部错误   
/**
 * sdk内部错误
 * @static
 */       
CRVideo_INNER_ERR = 3;
//不支持的sdk版本 
/**
 * 不支持的sdk版本
 * @static
 */
CRVideo_MISMATCHCLIENTVER = 4;
 //参数错误    
 /**
 * 参数错误
 * @static
 */
CRVideo_MEETPARAM_ERR = 5;
//无效数据  
/**
 * 无效数据
 * @static
 */   
CRVideo_ERR_DATA = 6;
 //帐号密码不正确
 /**
 * 帐号密码不正确
 * @static
 */
CRVideo_ANCTPSWD_ERR = 7;
//服务异常	
/**
 * 服务异常
 * @static
 */	       
CRVideo_SERVER_EXCEPTION = 8;
//登录用户被踢下线	
/**
 * 登录用户被踢下线
 * @static
 */	 
CRVideo_CRVideoSDK_USER_BEEN_KICKOUT = 10;

//------------------------------------------
//
//网络错误
//
//------------------------------------------
 //网络初始化失败
 /**
 * 网络初始化失败
 * @static
 */
CRVideo_NETWORK_INITFAILED = 200;
//没有服务器信息
/**
 * 没有服务器信息
 * @static
 */
CRVideo_NO_SERVERINFO = 201;
 //服务器没有响应
 /**
 * 服务器没有响应
 * @static
 */
CRVideo_NOSERVER_RSP = 202;
//创建连接失败
/**
 * 创建连接失败
 * @static
 */
CRVideo_CREATE_CONN_FAILED = 203;
//socket异常
/**
 * socket异常
 * @static
 */
CRVideo_SOCKETEXCEPTION = 204;
//网络超时
/**
 * 网络超时
 * @static
 */
CRVideo_SOCKETTIMEOUT = 205;
//连接被关闭
/**
 * 连接被关闭
 * @static
 */
CRVideo_FORCEDCLOSECONNECTION = 206;
//连接丢失
/**
 * 连接丢失
 * @static
 */
CRVideo_CONNECTIONLOST = 207;

//------------------------------------------
//
//队列错误
//
//------------------------------------------
//队列ID错误
/**
 * 队列ID错误
 * @static
 */
CRVideo_QUE_ID_INVALID = 400;
 //没有用户在排队
 /**
 * 没有用户在排队
 * @static
 */
CRVideo_QUE_NOUSER = 401;
//排队用户已取消	
/**
 * 排队用户已取消
 * @static
 */   
CRVideo_QUE_USER_CANCELLED = 402;
//队列服务还未开启
/**
 * 队列服务还未开启
 * @static
 */
CRVideo_QUE_SERVICE_NOT_START = 403
//已在其它队列排队(客户只能在一个队列排队)
/**
 * 已在其它队列排队(客户只能在一个队列排队)
 * @static
 */
CRVideo_ALREADY_OTHERQUE = 404

//------------------------------------------
//
//呼叫错误
//
//------------------------------------------
//无效的呼叫ID
/**
 * 无效的呼叫ID
 * @static
 */
CRVideo_INVALID_CALLID = 600;
//已在呼叫中
/**
 * 已在呼叫中
 * @static
 */
CRVideo_ERR_CALL_EXIST = 601;	
//对方忙
/**
 * 对方忙
 * @static
 */
CRVideo_ERR_BUSY = 602;
//对方不在线
/**
 * 对方不在线
 * @static
 */
CRVideo_ERR_OFFLINE = 603;	
//对方无应答
/**
 * 对方无应答
 * @static
 */			
CRVideo_ERR_NOANSWER = 604;
//用户不存在
/**
 * 用户不存在
 * @static
 */
CRVideo_ERR_USER_NOT_FOUND = 605;
//对方拒接
/**
 * 对方拒接
 * @static
 */
CRVideo_ERR_REFUSE = 606;

//------------------------------------------
//
//会话业务错误
//
//------------------------------------------
//会议不存在或已结束
/**
 * 会议不存在或已结束
 * @static
 */
CRVideo_MEETNOTEXIST = 800;
//会议密码不正确
/**
 * 会议密码不正确
 * @static
 */
CRVideo_AUTHERROR = 801;
 //会议终端数量已满（购买的license不够)
 /**
 * 会议终端数量已满（购买的license不够)
 * @static
 */
CRVideo_MEMBEROVERFLOWERROR = 802;
//分配会议资源失败
/**
 * 分配会议资源失败
 * @static
 */
CRVideo_RESOURCEALLOCATEERROR = 803;
//会议掉线
/**
 * 会议掉线
 * @static
 */
CRVideo_MEETOFFLINE = 804;

//------------------------------------------
//
//web错误
//
//------------------------------------------
//ocx未安装
/**
 * ocx未安装
 * @static
 */
CRVideo_WEB_OCX_NOTINSTALLED = 1001;
//不支持的浏览器
/**
 * 不支持的浏览器
 * @static
 */
CRVideo_WEB_BROWER_NOTUPPORTED = 1002;
//不支持的插件版本
/**
 * 不支持的插件版本
 * @static
 */
CRVideo_OCX_VERSION_NOTUPPORTED = 1003;
var PhoneFormat = {};
PhoneFormat.PCED_NO_ERR = 0;
PhoneFormat.PCED_ILLEGAL_CHAR = 1;
PhoneFormat.PCED_INVALID_LEN = 2;
PhoneFormat.PCED_INVALID_NUM = 3;
PhoneFormat.PCED_NO_AREA_CODE = 4;
PhoneFormat.PCED_ILLEGAL_EXT = 5;
PhoneFormat.result = "";
PhoneFormat.IsLegalChar = function(data)
{
	var dataLenght = data.length;
	for(var i=0; i<dataLenght; i++)
	{
		var char = data.charAt(i);
		if ( (char<'0'||char>'9') && char!='-' && char!='+' && char!='*' && char!='#' )
			return false;
	}
	return true;
}

PhoneFormat.isChinaMobile = function(standardFormatNum)
{
	if ( standardFormatNum.length<6 )
		return false;
	
	if (standardFormatNum.charAt(2)=='8' && standardFormatNum.charAt(3)=='6'
		&&standardFormatNum.charAt(4)=='1' && standardFormatNum.charAt(5)>'2' )
	{
		return true;
	}
	
	return false;
}
PhoneFormat.CoverToStandardFormat = function(num)
{
	PhoneFormat.result = num.concat();
	PhoneFormat.result = PhoneFormat.result.replace('＋', '+');
	PhoneFormat.result = PhoneFormat.result.replace('－', '-');
	var notHaveInterPrefix = false;
	
	
	//合法性检查
	if ( !PhoneFormat.IsLegalChar(PhoneFormat.result) )
	{
		return PhoneFormat.PCED_ILLEGAL_CHAR;
	}
	
	//长度检查
	if ( PhoneFormat.result.length<3 )
	{
		return PhoneFormat.PCED_INVALID_LEN;
	}
	
	//特殊号码自动加区号
	if ( PhoneFormat.result.charAt(0) == "9" && PhoneFormat.result.charAt(1)=="5" )
	{
//				result = "0755" + result;
		PhoneFormat.result = "0086" + PhoneFormat.result;
	}
	
	//修正国际号码前缀
	if ( PhoneFormat.result.charAt(0)=='+')
	{
		if ( PhoneFormat.result.charAt(1)=='0' )
		{
			return PhoneFormat.PCED_INVALID_NUM;
		}
		PhoneFormat.result = "00"+PhoneFormat.result.substr(2);

	}
		//没有国际前缀的,加中国国际码
	else if (PhoneFormat.result.charAt(0) != "0" || PhoneFormat.result.charAt(1)!="0")
	{
		PhoneFormat.result = "0086"+PhoneFormat.result;
		notHaveInterPrefix = true;
		
	}

	//号码中间不能再有+号或-号>2
	if (PhoneFormat.result.indexOf("+") != -1  )
	{
		var tmpArr = PhoneFormat.result.match(/-/g);
		if(tmpArr && tmpArr.length>2)
		{
			return PhoneFormat.PCED_INVALID_NUM;
		}
		
	}	
	
	//格式标准化后,至少6位( 3位国际码 + 3位号码 )
	if ( PhoneFormat.result.length<6 )
	{
		return PhoneFormat.PCED_INVALID_LEN;
	}
	
	//修正国内号码
	if ( PhoneFormat.result.substr(2,2)=="86" )
	{
		//去掉区号首为0的
		var notHaveZero = true;
		if ( PhoneFormat.result.charAt(4)=='0' )
		{
			notHaveZero = false;
			PhoneFormat.result = PhoneFormat.result.substr(0,4)+PhoneFormat.result.substr(5)
		}
		
		//手机号码
		if ( PhoneFormat.isChinaMobile(PhoneFormat.result) )
		{
			//不能包含+和-
			if ( PhoneFormat.result.indexOf('-') != -1)
			{
				return PhoneFormat.PCED_INVALID_NUM;
			}
			//号长应为4+11
			if ( PhoneFormat.result.length !=15 )
			{
				return PhoneFormat.PCED_INVALID_LEN;
			}
			
			return PhoneFormat.PCED_NO_ERR;
		}
		
		//400,800号
		var prefix = PhoneFormat.result.substr(4,3);
		var index = 0;
		if ( prefix=="400" || prefix=="800" )
		{
			//包含-号，应在第7和11位，长度为16
			index =  PhoneFormat.result.indexOf('-');
			if (index != -1 )
			{
				if ( index ==7 && index==11 && PhoneFormat.result.length==16 )
				{
					PhoneFormat.result = PhoneFormat.result.substr(0,index)+PhoneFormat.result.substr(index+1)
					return PhoneFormat.PCED_NO_ERR;
				}
				return PhoneFormat.PCED_INVALID_NUM;
			}
			else
			{
				//没有-号，长度应为4+10
				if ( PhoneFormat.result.length!=14 )
					return PhoneFormat.PCED_INVALID_LEN;
			}
			return PhoneFormat.PCED_NO_ERR;
		}
		
		//固话
		if ( notHaveInterPrefix && notHaveZero )
		{
			return PhoneFormat.PCED_NO_AREA_CODE;
		}
		
		//固话不能以0开头
		if ( PhoneFormat.result.charAt(4)=="0" )
		{
			return PhoneFormat.PCED_INVALID_NUM;
		}
		
		//去除表示区号间隔的-
		if ( PhoneFormat.result.charAt(6)=='-' )
		{
			PhoneFormat.result = PhoneFormat.result.substr(0,6)+PhoneFormat.result.substr(7)
		}
		else if ( PhoneFormat.result.charAt(7)=='-' )
		{
			PhoneFormat.result = PhoneFormat.result.substr(0,7)+PhoneFormat.result.substr(8)
		}
		
		//分机长度<8
		var tmpArr = PhoneFormat.result.match(/-/g);
		if(tmpArr && tmpArr.length>0)
		{
			prefix = PhoneFormat.result.substr(PhoneFormat.result.indexOf('-')+1);
			if ( tmpArr.lengt>1 || PhoneFormat.result.length>32 )
			{
				return PhoneFormat.PCED_ILLEGAL_EXT;
			}	
		}

	}
	
	if ( PhoneFormat.result.length>64 )
	{
		return PhoneFormat.PCED_INVALID_LEN;
	}
	
	return PhoneFormat.PCED_NO_ERR;
}
PhoneFormat.CoverToDisplayFormat = function(num)
{
	var err = PhoneFormat.CoverToStandardFormat(num);
	//先转标准格式
	if ( err!=PhoneFormat.PCED_NO_ERR )
		return err;
	
	//将00转成+
	PhoneFormat.result = PhoneFormat.result.substr(2);
	PhoneFormat.result = "+"+PhoneFormat.result;

	
	//如果不是+86,直接返回成功
	if ( PhoneFormat.result.charAt(1) !='8' || PhoneFormat.result.charAt(2)!='6' )
	{
		return PhoneFormat.PCED_NO_ERR;
	}
	PhoneFormat.result = PhoneFormat.result.substr(3);

	
	//QString prefix = displayStr.left(1);
	if ( PhoneFormat.result.charAt(0)=='1' && PhoneFormat.result.charAt(1)>'2' )
	{
		return PhoneFormat.PCED_NO_ERR;
	}
	var prefix = PhoneFormat.result.substr(0,3);
	if ( prefix=="400" || prefix=="800" )
	{
		return PhoneFormat.PCED_NO_ERR;
	}
	if ( PhoneFormat.result.charAt(0)=='9' && PhoneFormat.result.charAt(1) == '5')
	{
		return PhoneFormat.PCED_NO_ERR;
	}
	//固话前+0
	PhoneFormat.result ="0" + PhoneFormat.result
	return PhoneFormat.PCED_NO_ERR;
}
/** 
* sdk回调接口
* @module cr/callback
*/
 /**
 * 初始化返回
 * @callback Cr.CbProxy~CR_InitRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 */
var CR_InitRslt = new Cr.CbProxy("CR_InitRslt");

 


 /**
 * 登录服务器响应
 * @callback Cr.CbProxy~CR_LoginRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 * @param {Cr.MeetInfo} data   - 会议数据
 */
var CR_LoginRslt = new Cr.CbProxy("CR_LoginRslt");
 /**
 * 服务器保持会话响应
 * @callback Cr.CbProxy~CR__RefreshSessionRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 */
var CR__RefreshSessionRslt = new Cr.CbProxy("CR__KeepAliveRslt");
 /**
 * 服务器保持链接响应
 * @callback Cr.CbProxy~CR__KeepAliveRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 */
var CR__KeepAliveRslt = new Cr.CbProxy("CR__KeepAliveRslt");
/**
 * 结束会议
 * @callback Cr.CbProxy~CR__ExitRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 */
 var CR__ExitRslt = new Cr.CbProxy("CR__ExitRslt");
 /**
 * 获取在线会议人员信息
 * @callback Cr.CbProxy~CR__GetActiveMembersRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 */
 var CR__GetActiveMembersRslt = new Cr.CbProxy("CR__GetActiveMembersRslt");

 /**
 * 接收服务器聊天消息
 * @callback Cr.CbProxy~CR__ReceiveIMMsg
 * @param {Cr.MsgInfo} data   - data 聊天消息
 */
var CR__ReceiveIMMsg = new Cr.CbProxy("CR__ReceiveIMMsg");
 /**
 * 发送聊天消息
 * @callback Cr.CbProxy~CR__SendIMMsgRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 */
var CR__SendIMMsgRslt = new Cr.CbProxy("CR__SendIMMsgRslt");
 /**
 * 获取所有聊天记录消息返回
 * @callback Cr.CbProxy~CR__GetLastMsgRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 * @param {Array} list   - data 聊天消息Cr.MsgInfo列表
 */
var CR__GetLastMsgRslt = new Cr.CbProxy("CR__GetLastMsgRslt");
 /**
 * 获取指定聊天记录消息返回
 * @callback Cr.CbProxy~CR__GetLastNMsgRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 * @param {Array} list   - data 聊天消息Cr.MsgInfo列表
 */
var CR__GetLastNMsgRslt = new Cr.CbProxy("CR__GetLastNMsgRslt");
 /**
 * 用户离开会议
 * @callback Cr.CbProxy~CR__UserLeftMeet
 * @param {Number} terminalId   - terminalId 用户id
 */
var CR__UserLeftMeet = new Cr.CbProxy("CR__UserLeftMeet");
/**
 * 新成员入会
 * @callback Cr.CbProxy~CR__UserLeftMeet
 * @param {json} members   - memebers 新进入会议成员的信息
 */
var CRVideo_UserEnter = new Cr.CbProxy("CRVideo_UserEnter");
 /**
 * 会议结束
 * @callback Cr.CbProxy~CR__MeetEnded
 */
var CR__MeetEnded = new Cr.CbProxy("CR__MeetEnded");
 /**
 * 直播开始通知
 * @callback Cr.CbProxy~CR__NotifyStartBroadCast
 */
var CR__NotifyStartBroadCast = new Cr.CbProxy("CR__NotifyStartBroadCast");
 /**
 * 直播结束通知
 * @callback Cr.CbProxy~CR__NotifyStopBroadCast
 */
var CR__NotifyStopBroadCast = new Cr.CbProxy("CR__NotifyStopBroadCast");
 /**
 * 视频流开始通知
 * @callback Cr.CbProxy~CR__NotifyBroadCastStartPush
 */
var CR__NotifyBroadCastStartPush = new Cr.CbProxy("CR__NotifyBroadCastStartPush");
 /**
 * 视频流结束通知
 * @callback Cr.CbProxy~CR__NotifyBroadCastStopPush
 */
var CR__NotifyBroadCastStopPush = new Cr.CbProxy("CR__NotifyBroadCastStopPush");
 /**
 * 获取视频流地址返回
 * @callback Cr.CbProxy~CR__GetBroadCastUrlRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 * @param {Object} data   - 直播地址(key值为Conference.BOARDCAST_RTMP为PC用的,为Conference.BOARDCAST_HLS为移动用的);
 */
var CR__GetBroadCastUrlRslt = new Cr.CbProxy("CR__GetBroadCastUrlRslt");
 /**
 * 某某被屏蔽聊天/允许聊天
 * @callback Cr.CbProxy~CR__NotifyIMForbidStatus
 * @param {Number} dstId   - 目标id
 * @param {bool} bForbid   - 是否被禁言
 */
var CR__NotifyIMForbidStatus = new Cr.CbProxy("CR__NotifyIMForbidStatus");
 /**
 * 清空IM
 * @callback Cr.CbProxy~CR__NotifyClearIMMsg
 */
var CR__NotifyClearIMMsg = new Cr.CbProxy("CR__NotifyClearIMMsg");
 /**
 * 权限改变
 * @callback Cr.CbProxy~CR__RightChanged
 * @param {Number} termid - 被改变的用户id
 * @param {Array} addedRights -增加的权限列表
 * @param {Array} reducedRight - 删除的权限列表
 */
var CR__RightChanged = new Cr.CbProxy("CR__RightChanged");
 /**
 * 提问返回
 * @callback Cr.CbProxy~CR__AskQuesRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 * @param {Number} id - 问题id
 */
var CR__AskQuesRslt = new Cr.CbProxy("CR__AskQuesRslt");
 /**
 * 问题信息列表返回
 * @callback Cr.CbProxy~CR__GetQuesListRslt
 * @param {Number} errCode   - errCode 操作失败代码,定义见cr/error
 * @param {string} errDesc   - errDesc 信息
 * @param {Cr.QuesInf[]} list - 问题列表
 */
var CR__GetQuesListRslt = new Cr.CbProxy("CR__GetQuesListRslt");

 /**
 * 接受问题
 * @callback Cr.CbProxy~CR__AskQuesNotify
 * @param {Number} id - 问题id
 * @param {Cr.Quesask} asQue -问题
 */
var CR__AskQuesNotify = new Cr.CbProxy("CR__AskQuesNotify");
 /**
 * 锁定(问题正在答复)，解锁(问题变更为未答复)
 * @callback Cr.CbProxy~CR__LockQuesNotify
 * @param {Number} id - 问题id
 * @param {Cr.QuesDeal} quesDeal -问题回应
 */
var CR__LockQuesNotify = new Cr.CbProxy("CR__LockQuesNotify");
 /**
 * 回复问题
 * @callback Cr.CbProxy~CR__ReplyQuesNotify
 * @param {Number} id - 问题id
 * @param {Cr.QuesDeal} quesDeal -问题回
 */
var CR__ReplyQuesNotify = new Cr.CbProxy("CR__ReplyQuesNotify");
 /**
 * 修改问题
 * @callback Cr.CbProxy~CR__ModifyQuesNotify
 * @param {Number} id - 问题id
 * @param {Cr.QuesDeal} quesDeal -问题回
 */
var CR__ModifyQuesNotify = new Cr.CbProxy("CR__ModifyQuesNotify");
 /**
 * 删除问题
 * @callback Cr.CbProxy~CR__DelQuesNotify
 * @param {Number} id - 问题id
 * @param {Number} termId -删除人id
 */
var CR__DelQuesNotify = new Cr.CbProxy("CR__DelQuesNotify");
 /**
 * 删除所有
 * @callback Cr.CbProxy~CR__DelAllQuesNotify
 * @param {Number} termId -删除人id
 */
var CR__DelAllQuesNotify = new Cr.CbProxy("CR__DelAllQuesNotify");
 /**
 * 公开问题
 * @callback Cr.CbProxy~CR__PublicQuesNotify
 * @param {Number} id - 问题id
 * @param {Number} bPublic - 是否公开
 * @param {Number} termId -公开人id
 */
var CR__PublicQuesNotify = new Cr.CbProxy("CR__PublicQuesNotify");
 /**
 * 修改问题归属类型
 * @callback Cr.CbProxy~CR__QuesTypeChangeNotify
 * @param {Number} id - 问题id
 * @param {Number} typeID -类型id
 */
var CR__QuesTypeChangeNotify = new Cr.CbProxy("CR__QuesTypeChangeNotify");
 /**
 * 问题类型修改
 * @callback Cr.CbProxy~CR__ModifyQuesTypeNotify
 * @param {Number} id - 问题id
 * @param {Object} quesTypeList -问题类型列表
 */
var CR__ModifyQuesTypeNotify = new Cr.CbProxy("CR__ModifyQuesTypeNotify");
 /**
 * 直播问答功能修改通知
 * @callback Cr.CbProxy~CR__SetBroadCastQuesNotify
 * @param {boolean} bEnable - 是否显示问答
 */
var CR__SetBroadCastQuesNotify = new Cr.CbProxy("CR__SetBroadCastQuesNotify");
 /**
 * 回播流开始通知
 * @callback Cr.CbProxy~CR__NotifyPlayBackStartPush
 * @param {string} url - 回播地址
 */
var CR__NotifyPlayBackStartPush = new Cr.CbProxy("CR__NotifyPlayBackStartPush");
 /**
 * 删除IM消息
 * @callback Cr.CbProxy~CR__NotifyDeleteIMMsg
 * @param {number} sn - 序号
 */
var CR__NotifyDeleteIMMsg = new Cr.CbProxy("CR__NotifyDeleteIMMsg");
 /**
 * 获取公聊IM消息条数
 * @callback Cr.CbProxy~CR__GetIMMsgCountRslt
 * @param {number} count - IM消息条数
 */
var CR__GetIMMsgCountRslt = new Cr.CbProxy("CR__GetIMMsgCountRslt");
/**
* 通知付费观看成功
*/
var CR__Notifypayback = new Cr.CbProxy("CR__Notifypayback");

/**
* 通知回放关闭
*/
var CR__NotifyBroadCastPlaybackStop = new Cr.CbProxy("CR__NotifyBroadCastPlaybackStop");
/**
* 通知红包 打赏 打赏开关的通知
*  @param {number} ele - 功能模块  4:红包 5:打赏 51：打赏排行榜
*  @param {number} status - 0:关闭 1:打开 2:其它
*/
var CR__NotifySwtichLiveAppElements = new Cr.CbProxy("CR__NotifySwtichLiveAppElements");
/**
* 点赞通知接口
*  @param {number} opt - 功能模块 1 点赞
*  @param {number} num - 点赞数
*  @param {number} toatal - 总数
*  @param {number} info 其他信息
*/ 
var CR__NotifyThumbUp = new Cr.CbProxy("CR__NotifyThumbUp");
/**
* 通知抽奖配置变化
*  @param {number} memberType - 
*  @param {number} cdTime - 
*  @param {bool} isautoDraw -
*  @param {string} prizeName -
*  @param {number} prizeNum -
*/
var CR__NotifyLuckyDrawCfg = new Cr.CbProxy("CR__NotifyLuckyDrawCfg");
 /**
 * 获取抽奖信息配置的方法
 * @callback Cr.CbProxy~CR__GetQuesListRslt
 * @param {Cr.MsgInfo} data   - data 获取抽奖配置的结果
 */
var CR__GetLuckyDrawCfgRslt = new Cr.CbProxy("CR__GetLuckyDrawCfgRslt");
 /**
 * 获取抽奖报名结果的方法
 * @callback Cr.CbProxy~CR__JoinLuckyDrawMembersRslt
 * @param {Cr.MsgInfo} member   - member 抽奖报名的结果
 */
var CR__JoinLuckyDrawMembersRslt = new Cr.CbProxy("CR__JoinLuckyDrawMembersRslt");
 /**
 * 人员变化
 * @callback Cr.CbProxy~CR__NotifyLDMembersStatus
 * @param {Cr.MsgInfo} member   - member 抽奖报名的结果
 */
var  CR__NotifyLDMembersStatus = new Cr.CbProxy("CR__NotifyLDMembersStatus");
 /**
 * 开奖结果通知
 * @callback Cr.CbProxy~CR__NotifyLuckyDrawResult
 * @param {Cr.MsgInfo} member   - member 抽奖报名的结果
 */
var CR__NotifyLuckyDrawResult = new Cr.CbProxy("CR__NotifyLuckyDrawResult");
/**
 * 开始服务器录制结果
 * @callback Cr.CbProxy~CR__StartSvrRecordRslt
 * @param {Cr.MsgInfo} member   - member 抽奖报名的结果
 */
var CR__StartSvrRecordRslt = new Cr.CbProxy("CR__StartSvrRecordRslt");
/**
 * 更新录制信息
 * @callback Cr.CbProxy~CR__UpdateSvrRecCfgRslt
 * @param {Cr.MsgInfo} member   - member 抽奖报名的结果
 */
var CR__UpdateSvrRecCfgRslt = new Cr.CbProxy("CR__UpdateSvrRecCfgRslt");
/**
 * 停止服务器录制
 * @callback Cr.CbProxy~CR__StopSvrRecordRslt
 */
var CR__StopSvrRecordRslt = new Cr.CbProxy("CR__StopSvrRecordRslt");
/**
 * 服务器录制状态变化
 * @callback Cr.CbProxy~CR__NotifySvrRecordStateChanged
 */
var CR__NotifySvrRecordStateChanged = new Cr.CbProxy("CR__NotifySvrRecordStateChanged");
/**
 * 服务器录制状态变化
 * @callback Cr.CbProxy~CR__NotifySvrRecordCfgChanged
 */
var CR__NotifySvrRecordCfgChanged = new Cr.CbProxy("CR__NotifySvrRecordCfgChanged");

/*********************************** MSClientI ******************/
/** 分配媒体流
 * 语音流分配(无对端地址)
 * 参数: asParam --- 语音流参数
 * 返回值:  返回值大于等于0时为媒体流ID(MSID),-1为分配失败		
 **/
var CR__AudioAllocRaw = new Cr.CbProxy("CR__AudioAllocRaw");
/**
 * 上报自身的音频设备是否正常
 * @access private
 * @param {obj} bool - false为不正常 true为正常
 */	
var CR__SetAudioDeviceStatusRslt = new Cr.CbProxy("CR__SetAudioDeviceStatusRslt");
/**
 * 申请开mic;
 * @access public
 */	
var CR__AskForMicRslt = new Cr.CbProxy("CR__AskForMicRslt");

/**
 * 主持人开启自已、他人麦克风; 
 * terminalID 受控的终端ID
 * @access public
 */	
var CR__OpenMicExRslt = new Cr.CbProxy("CR__OpenMicExRslt");
/**
 * 关闭自已、或主持人关闭其他人的麦克风; 
 * terminalID 受控的终端ID
 */
var CR__CloseMicExRslt = new Cr.CbProxy("CR__CloseMicExRslt");

var CR__AudioAllocRawExt2 = new Cr.CbProxy("CR__AudioAllocRawExt2");

var CR__VideoAllocRawExt2 = new Cr.CbProxy("CR__VideoAllocRawExt2");

var CR__ModifyPeerAddrExt = new Cr.CbProxy("CR__ModifyPeerAddrExt");
////禁止终端上传视频到公网(ACCESS)
var CR__DisableSendVideo2Internet = new Cr.CbProxy("CR__DisableSendVideo2Internet");

//允许终端上传视频到公网(ACCESS)
var CR__EnableSendVideo2Internet = new Cr.CbProxy("CR__EnableSendVideo2Internet");
//释放流媒体
var CR__Free = new Cr.CbProxy("CR__Free");

var CR__ModifyPeerAddr = new Cr.CbProxy("CR__ModifyPeerAddr");

var CR__VideoAllocRaw = new Cr.CbProxy("CR__VideoAllocRaw");


/*****************************video 回调方法封装 开始******************************/
/**
 * 被请求打开视频
 */
var CR__NotifyAllowVideoWall = new Cr.CbProxy("CR__NotifyAllowVideoWall");
/**
 * 更新终端的视频状态，terminalID表示会议成员终端id
 * status 视频分享状态
*/
var CR__VideoUpdateStatus = new Cr.CbProxy("CR__VideoUpdateStatus");
/**
 * 请求打开视频
 * operId 
 */
var CR__NotifyOpenVideo = new Cr.CbProxy("CR__NotifyOpenVideo");
/**
 * 被主持人演示者打开视频
 */
var CR__StartVideoByManager = new Cr.CbProxy("CR__StartVideoByManager");
/**
 * 通知终端视频功能是否开启
 */
var CR__NotifyEnableVideo = new Cr.CbProxy("CR__NotifyEnableVideo");
/**
 * 更新主视频窗口
 * mode 主视频窗口显示模式
 * terminalID 要显示的终端ID
 */
var CR__UpdateFocusWindow = new Cr.CbProxy("CR__UpdateFocusWindow");
/**
 * 更新电视墙布局
 * mode 主视频窗口显示模式
 * terminalID 要显示的终端ID
 */
var CR__UpdateVLayout = new Cr.CbProxy("CR__UpdateVLayout");
/**
 * 更新主视频显示模式
 */
var CR__UpdateMainVideoShowMode = new Cr.CbProxy("CR__UpdateMainVideoShowMode");
/**
 * 更新视频列表模式
 */
var CR__UpdateVideoListMode = new Cr.CbProxy("CR__UpdateVideoListMode");
/**
 * 是否上传终端视频数据
 */
var CR__EnableUpload = new Cr.CbProxy("CR__EnableUpload");
/**
 * 是否上传终端视频数据2
 */
var CR__EnableUpload2 = new Cr.CbProxy("CR__EnableUpload2");
/**
 * 12指定产生I帧
 */
var CR__GenerateIFrame = new Cr.CbProxy("CR__GenerateIFrame");
/**
 * 拒绝开启视频，opid为拒绝的人
 */
var CR__NotifyRefuseOpenVideo = new Cr.CbProxy("CR__NotifyRefuseOpenVideo");
/**
 * 取得视频列表
 */
var CR__GetVideoSetting = new Cr.CbProxy("CR__GetVideoSetting");
/**
 * 设置视频设备
 */
var CR__SetCamera = new Cr.CbProxy("CR__SetCamera");
/**
 * 设置摄像头 id值
 */
var CR__SetCameraById = new Cr.CbProxy("CR__SetCameraById");
/**
 * 通知视频轮巡，如果演示者掉线由后台通知停止轮巡
 */
var CR__NotifyVideoPolling = new Cr.CbProxy("CR__NotifyVideoPolling");
/**
 * 更新视频墙内容
 */
var CR__NotifyPollingVideo = new Cr.CbProxy("CR__NotifyPollingVideo");
/**
 * 更新视频列表
 */
var CR__NotifyVideoList = new Cr.CbProxy("CR__NotifyVideoList");
/**
 * 更新用户的摄像头信息
 */
var CR__NotifyUpdateAllCameraInfos = new Cr.CbProxy("CR__NotifyUpdateAllCameraInfos");
/**
 * 通知开启的多摄像头个数
 */
var CR__NotifySetOpenedCameraNumber = new Cr.CbProxy("CR__NotifySetOpenedCameraNumber");
/**
 * 通知调整方向
 */
var CR__NotifyStartAdjustDirection = new Cr.CbProxy("CR__NotifyStartAdjustDirection");
/**
 * 通知变焦
 */
var CR__NotifyStartAdjustZoom = new Cr.CbProxy("CR__NotifyStartAdjustZoom");
/**
 * 通知停止调整方向
 */
var CR__NotifyStopAdjustDirection = new Cr.CbProxy("CR__NotifyStopAdjustDirection");
/**
 * 通知停止变焦
 */
var CR__NotifyStopAdjustZoom = new Cr.CbProxy("CR__NotifyStopAdjustZoom");

/**
 * 获取本地设备信息
 * @callback Cr.CbProxy~CR__SetDeviceStatusRslt
 * @param {Cr.MsgInfo} member 
 */
var CR__SetVideoDeviceStatusRslt = new Cr.CbProxy("CR__SetVideoDeviceStatusRslt");
/**
 * 开启视频墙
 * @access public
 */
var CR__AllowVideoWallRslt = new Cr.CbProxy("CR__AllowVideoWallRslt");	
 /**
 * 开启设备返回信息
 * @callback Cr.CbProxy~CR__JoinLuckyDrawMembersRslt
 * @param {Cr.MsgInfo} member   - member 抽奖报名的结果
 */
var CR__StartVideoRslt = new Cr.CbProxy("CR__StartVideoRslt");
/**
 * 关闭设备返回信息
 * @callback Cr.CbProxy~CR__StopVideoRslt
 * @param {Cr.MsgInfo} member
 */
var CR__StopVideoRslt = new Cr.CbProxy("CR__StopVideoRslt");
/**
 * 开启视频墙
 * @access public
 */	
var CR__ReqOpenVideoRslt = new Cr.CbProxy("CR__ReqOpenVideoRslt");
/**
 * 主持人演示者开启他人视频
 * terminalID 受控的终端ID
 * 异常表示可能因为资源达到最大值失败
 * @access public
 */	
var CR__StartVideoExRslt = new Cr.CbProxy("CR__StartVideoExRslt");
/**
 * 主持人演示者关闭他人视频
 * terminalID 受控的终端ID
 * 异常表示可能因为资源达到最大值失败
 * @access public
 */	
var CR__StopVideoExExRslt = new Cr.CbProxy("CR__StopVideoExExRslt");
/**
 * 开启关闭视频功能
 * @access public
 */	
var CR__EnableVideoRslt = new Cr.CbProxy("CR__EnableVideoRslt");
/**
 *主持人演示者选择主视频窗口
 * vMode 锁定/跟踪/演示者锁定
 * terminalID vMode为VMANAGERLOCK有效，锁定视频窗口的成员终端id
 */	
var CR__SetFocusWindowRslt = new Cr.CbProxy("CR__SetFocusWindowRslt");
/**
 * 批量订阅，退订视频
 * @access public
 */	
var CR__BatchSubscribeVideoRslt = new Cr.CbProxy("CR__BatchSubscribeVideoRslt");
/**
 * 批量订阅，退订视频
 * @access public
 */	
var CR__BatchSubscribeVideo2Rslt = new Cr.CbProxy("CR__BatchSubscribeVideo2Rslt");
/**
 * 设置订阅主视频
 * @access public
 */
var CR__SubscribeFocusWindowRslt = new Cr.CbProxy("CR__SubscribeFocusWindowRslt");
/**
 * 设置订阅主视频
 * @access public
 */
var CR__SubscribeFocusWindow2Rslt = new Cr.CbProxy("CR__SubscribeFocusWindow2Rslt");
/**
 * 变更视频布局（主持人，演示者、助理有权限）
 * @access public
 */
var CR__SetVLayoutRslt = new Cr.CbProxy("CR__SetVLayoutRslt");
/**
 * 变更主视频显示模式（主持人，演示者、助理有权限）
 * @access public
 */
var CR__SetMainVideoShowModeRslt = new Cr.CbProxy("CR__SetMainVideoShowModeRslt");
/**
 * 变更视频列表模式
 * @access public
 */
var CR__SetVideoListModeRslt = new Cr.CbProxy("CR__SetVideoListModeRslt");
/**
 * 拒绝开启视频，termId表示向某人发送这个消息
 * @access public
 */
var CR__RefuseOpenVideoRslt = new Cr.CbProxy("CR__RefuseOpenVideoRslt");
/**
 * 取得视频列表
 * @access public
 */
var CR__GetVideoSettingRslt = new Cr.CbProxy("CR__GetVideoSettingRslt");
/**
 * 设置摄像头
 * @access public
 */
var CR__SetCameraRslt = new Cr.CbProxy("CR__SetCameraRslt");
/**
 * 设置主摄像头
 * @access public
 */
var CR__SetCameraByIdRslt = new Cr.CbProxy("CR__SetCameraByIdRslt");
/**
 * 开启关闭视频轮巡
 * @access public
 */
var CR__SetVideoPollingRslt = new Cr.CbProxy("CR__SetVideoPollingRslt");
/**
 * 更新轮巡的视频列表
 * @access public
 */
var CR__UpdatePollingVideoRslt = new Cr.CbProxy("CR__UpdatePollingVideoRslt");
/**
 * 更新视频列表
 * @access public
 */
var CR__UpdateVideoListRslt = new Cr.CbProxy("CR__UpdateVideoListRslt");
/**
 * 是否开启了视频轮巡，轮巡的视频列表
 * @access public
 */
var CR__GetVideoPollingStateRslt = new Cr.CbProxy("CR__GetVideoPollingStateRslt");
/**
 * 上报摄像头信息
 * @access public
 */
var CR__UpdateAllCameraInfosRslt = new Cr.CbProxy("CR__UpdateAllCameraInfosRslt");
/**
 * 设置用户开启的摄像头(默认摄像头放在第1个，后面为所有打开的摄像头camid(包含默认摄像头）其顺序即为显示序号)
 * @access public
 */
var CR__SetOpenedCameraNumberRslt = new Cr.CbProxy("CR__SetOpenedCameraNumberRslt");
/**
 * 设置用户开启的摄像头(默认摄像头放在第1个，后面为所有打开的摄像头camid(包含默认摄像头）其顺序即为显示序号)
 * @access public
 */
var CR__StartAdjustDirectionRslt = new Cr.CbProxy("CR__StartAdjustDirectionRslt");
/**
 * 变焦
 * @access public
 */
var CR__StartAdjustZoomRslt = new Cr.CbProxy("CR__StartAdjustZoomRslt");
/**
 * 停止变焦
 * @access public
 */
var CR__StopAdjustDirectionRslt = new Cr.CbProxy("CR__StopAdjustDirectionRslt");

/***********************************audio的方法******************************************************/
/**
 * 更新终端的音频状态
 * operatorID操作者ID,自己/演示者/主持人开麦时为本人/演示者/主持人termId,角色切换时的自动开麦为Conference.ANON_TERMID
 * terminalID会议成员终端id
 *status音频状态
 */

var CR__AudioUpdateStatus = new Cr.CbProxy("CR__AudioUpdateStatus");
/**
 * 更新语音能量
 **/
var CR__UpdateVoiceEnergy = new Cr.CbProxy("CR__UpdateVoiceEnergy");
/**
 * 更新当前声音能量最大的成员
 * terminalID 终端ID 
 */
var CR__UpdateSpeaker = new Cr.CbProxy("CR__UpdateSpeaker");
/**
 * 全体静音，主持人、演示者可用
 * @access public
 */
var CR__CloseAll = new Cr.CbProxy("CR__CloseAll");
/**
 * 开始，停止背景音乐广播消息 
 */
var CR__PlayBackgroundMusic = new Cr.CbProxy("CR__PlayBackgroundMusic");

var CR__NotifyVoiceHowling = new Cr.CbProxy("CR__NotifyVoiceHowling");

var CR__NotifyVoiceNoise = new Cr.CbProxy("CR__NotifyVoiceNoise");

var CR__GetRemoteAudioInfNotify = new Cr.CbProxy("CR__GetRemoteAudioInfNotify");

var CR__RemoteAudioSetNotify = new Cr.CbProxy("CR__RemoteAudioSetNotify");
/**
 * 通知同局域网内不要开太多的麦 
 */
var CR__NotifyLanLessMicOpen = new Cr.CbProxy("CR__NotifyLanLessMicOpen");
/**
 * 上报本终端一段时间内语音能量
 * ve语音能量
 * 2秒报一次，暂定
 */	
var CR__SetVoiceEnergyRslt = new Cr.CbProxy("CR__SetVoiceEnergyRslt");
/**
 * 切换当前麦状态
 * 关麦变申请
 * 申请变取消申请
 * 开麦变关麦
 */	
var CR__PstnSwitchMicStatusRslt = new Cr.CbProxy("CR__PstnSwitchMicStatusRslt");
/**
 * 开始会议录音(每次开始产生一个新的文件)
 * @access public
 */	
var CR__StartRecordRslt = new Cr.CbProxy("CR__StartRecordRslt");
/**
 * 正在会议录音(每次开始产生一个新的文件)
 * @access public
 */	
var CR__IsRecordingRslt = new Cr.CbProxy("CR__IsRecordingRslt");
/**
 * 停止会议录音
 * @access public
 */	
var CR__StopRecordRslt = new Cr.CbProxy("CR__StopRecordRslt");
/**
 * 播放掌声
 * @access public
 */	
var CR__PlayApplauseRslt = new Cr.CbProxy("CR__PlayApplauseRslt");
/**
 * 背景音乐
 * @access public
 */
var CR__GetMusicListRslt = new Cr.CbProxy("CR__GetMusicListRslt");
/**
 * ""表示没播放的音乐
 * @access public
 */
var CR__GetPlayBGMusicRslt = new Cr.CbProxy("CR__GetPlayBGMusicRslt");
/**
 * 开始播放背景音乐
 * @access public
 */
var CR__StartBGMusicRslt = new Cr.CbProxy("CR__StartBGMusicRslt");
/**
 * 停止播放背景音乐
 * @access public
 */
var CR__StopPlayBGMusicRslt = new Cr.CbProxy("CR__StopPlayBGMusicRslt");

/**
 * 设置播放背景音乐音量 0-100
 * @access public
 */
var CR__SetPlayBGMusicVolumnRslt = new Cr.CbProxy("CR__SetPlayBGMusicVolumnRslt");
/**
 * 获得音量大小
 * @access public
 */
var CR__GetPlayBGMusicVolumnRslt = new Cr.CbProxy("CR__GetPlayBGMusicVolumnRslt");
/**
 * 获取音量结果
 * @access public
 */
var CR__VoiceHowlingRslt = new Cr.CbProxy("CR__VoiceHowlingRslt");
/**
 * 音量
 * @access public
 */
var CR__VoiceNoiseRslt = new Cr.CbProxy("CR__VoiceNoiseRslt");
/**
 * 远程音频设置
 * @access public
 */
var CR__RemoteAudioSetRslt = new Cr.CbProxy("CR__RemoteAudioSetRslt");
/**
 * 
 * @access public
 */
var CR__GetRemoteAudioInfRslt = new Cr.CbProxy("CR__GetRemoteAudioInfRslt");




 








ConferenceReceptor =Ice.Class(Conference.ConferenceCallback, 
{

	setProxy:function(value)
	{
		this.proxy = value;
	},
	//用户进入会议
	entered:function(newMember)
	{
		Cr.Utils.log('newMember');
		this.proxy.callCallback("entered",[newMember]);
	},
	//用户离开会议
	left:function(operatorId, terminalId, callbackCategory, reason)
	{
		//特殊处理，重登后第一次要过滤
		console.log("离线原因：",reason)
		Cr.Utils.log('left');
		this.proxy.callCallback("left",[terminalId,reason]);

	},
	actorChanged:function(operatorId, terminalId, actorType)
	{
		Cr.Utils.log('actorChanged');
	},
	 //昵称改变 
	 //@param operatorId
	 // @param terminalId
	 //@param newNickName
	 // @param __current
	
	nicknameChanged:function(operatorId, terminalId, newNickName)
	{
		Cr.Utils.log('nicknameChanged');
	},
	//上报用户的相关状况，网络状况、CPU占用率等
	/*notifyReportStatus_async:function(__cb:AMD_ConferenceCallback_notifyReportStatus, operatorId, lastTime)
	{

	},*/
	
	optionChanged:function(option)
	{
		Cr.Utils.log('optionChanged');
	},
	
	agendaUpdated:function (agenda)
	{
		Cr.Utils.log('agendaUpdated');
	},
	
	autoEndCancelled:function()
	{
		Cr.Utils.log('autoEndCancelled');
	},
	
	conferenceBegan:function()
	{
		Cr.Utils.log('conferenceBegan');
	},
	
	conferenceEnded:function(operator, reason)
	{

		Cr.Utils.log('conferenceEnded');
		this.proxy.callCallback("conferenceEnded");
		
	},
	
	confirmAutoEnd:function(countDownSeconds)
	{
		Cr.Utils.log('confirmAutoEnd');
	},
	//调用客户端的内部令命
	/*exeCmd_async:function(__cb:AMD_ConferenceCallback_exeCmd, cmdAndParam)
	{

	},*/
	//邀请状态改变
	inviteStateChanged:function(t, member)
	{
		
		Cr.Utils.log('inviteStateChanged:');
	},
	
	memberCount:function(totalNumber)
	{
		Cr.Utils.log('memberCount');
	},
	
	notifyApplyDemo:function(termID)
	{
		Cr.Utils.log('notifyApplyDemo');
	},
	
	notifyApplyRejected:function(operatorId, termID)
	{
		Cr.Utils.log('notifyApplyRejected');
	},
	
	notifyAssistantChanged:function(operatorId, termID, isAssistant)
	{
		Cr.Utils.log('notifyAssistantChanged');
	},
	
	notifyNetDetectResults:function(termId, nLevel, bWifi)
	{
		Cr.Utils.log('notifyNetDetectResults');
		
	},
	notifyReportStatus:function(operatorId,lastTime)
	{
		Cr.Utils.log('notifyReportStatus');
		
	},
	exeCmd:function(cmdAndParam)
	{
		Cr.Utils.log('exeCmd');
		
	},
	notifyStart1v1SubMeeting:function(peerID)
	{
		Cr.Utils.log('notifyStart1v1SubMeeting');
		
	},
	notifyStop1v1SubMeeting:function(peerID)
	{
		Cr.Utils.log('notifyStop1v1SubMeeting');
		
	},
	notifyStart1v1SubMeetingRslt:function(peerID,startRslt)
	{
		Cr.Utils.log('notifyStart1v1SubMeetingRslt');
		
	},
	setWDT1v1SubMeetingMode:function(peerID,mode)
	{
		Cr.Utils.log('setWDT1v1SubMeetingMode');
		
	},
	notifyIVRStatus:function(termID,isIVR)
	{
		Cr.Utils.log('notifyIVRStatus');
		
	},
	notifyStartSvrBroadcast:function(operatorId,jsonCfg)
	{
		Cr.Utils.log('notifyStartSvrBroadcast');
		
	},
	notifyLuckyDrawCfg:function(args)
    {
        Cr.Utils.log('notifyLuckyDrawCfg');   
    },
	notifyLuckyDrawResult:function(args)
    {
        Cr.Utils.log('notifyLuckyDrawResult');
    },
	roomKnocked:function(knocker, reason)
	{
		Cr.Utils.log('roomKnocked');
	},
	
	roomStateChanged:function(locked)
	{
		Cr.Utils.log('roomStateChanged');
	},
	
	serverNotify:function(id)
	{
		Cr.Utils.log('serverNotify');
	},
	
	serverNotifyMsg:function(msg)
	{


	},
	
	subjectUpdated:function(subject)
	{
		Cr.Utils.log('subjectUpdated');
	},
	
	updateAppStatus:function(activeTermIds, deactiveTermIds)
	{
		Cr.Utils.log('updateAppStatus');
	},
	notifyStartBroadCast:function()
	{
		
		this.proxy.callCallback("notifyStartBroadCast");
		Cr.Utils.log('notifyStartBroadCast');
	},
	notifyStopBroadCast:function()
	{
		this.proxy.callCallback("notifyStopBroadCast");
		Cr.Utils.log('notifyStopBroadCast');
	},
	notifyWebViewerNum:function(number)
	{
		Cr.Utils.log('notifyWebViewerNum');
	},
	notifyBroadCastStartPush:function()
	{
		this.proxy.callCallback("notifyBroadCastStartPush");
		Cr.Utils.log('notifyBroadCastStartPush');
	},
	notifyBroadCastStopPush:function()
	{
		this.proxy.callCallback("notifyBroadCastStopPush");
		Cr.Utils.log('CR__NotifyBroadCastStopPush');
	},
	rightChanged:function(rights)
	{
		var addedRights = Array.from(rights.addedRights)
		var reducedRights = Array.from(rights.reducedRights)
		CR__RightChanged.call([rights.termId,addedRights,reducedRights]);
		this.proxy.callCallback("rightChanged",[rights.termId,addedRights,reducedRights]);

		Cr.Utils.log('rightChanged');
	},
	notifyBroadCastPlayback:function(url)
	{
		this.proxy.callCallback("notifyPlayBackStartPush",[url]);
	},
    notifypayback:function()
	{
		this.proxy.callCallback("notifypayback");
	},
	notifyBroadCastPlaybackStop:function(url)
	{
		this.proxy.callCallback("notifyBroadCastPlaybackStop",[url]);
	},
	notifySwtichLiveAppElements:function(ele,status)
	{
		this.proxy.callCallback("notifySwtichLiveAppElements",[ele,status]);
	},
	notifyThumbUp:function(num,total,info)
	{
		this.proxy.callCallback("notifyThumbUp",[num,total,info]);
	},
	notifyLuckyDrawCfg:function(args)
	{
        this.proxy.callCallback("notifyLuckyDrawCfg",[args.cdTime,args.isAutoDraw,args.memberType,args.prizes]);
        Cr.Utils.log('notifyLuckyDrawCfg');
	},
	notifyLDMembersStatus:function(args){
        this.proxy.callCallback("notifyLDMembersStatus",args);
	},
	notifyLuckyDrawResult:function(args)
	{
        this.proxy.callCallback("notifyLuckyDrawResult",[args.prize,args.annouceTime,args.res]);
        Cr.Utils.log('notifyLuckyDrawResult');
	},
	notifySvrRecordStateChanged:function(operatorId,state,err)
	{
        Cr.Utils.log('notifySvrRecordStateChanged',[operatorId,state,err]);
	},
	notifySvrRecordCfgChanged:function(operatorId,jsonCfg)
	{
        Cr.Utils.log('notifySvrRecordCfgChanged',[operatorId,jsonCfg]);
	},
	notifySvrBroadcastCfgChanged:function(operatorId,jsonCfg)
	{
        Cr.Utils.log('notifySvrBroadcastCfgChanged');
	},
	notifyAppUILocked:function(UILockStatus)
	{
        Cr.Utils.log('notifyAppUILocked');
	},
	notifyBeginVote:function(operId,id,jsonVoteInfo)
	{
        Cr.Utils.log('notifyBeginVote');
	},
	notifyEndVote:function(operId)
	{
        Cr.Utils.log('notifyEndVote');
	},
	notifyPublishVoteResult:function(operId,jsonVoteResult)
	{
        Cr.Utils.log('notifyPublishVoteResult');
	},
	notifyCommitVote:function(operId,jsonVoteResult)
	{
        Cr.Utils.log('notifyCommitVote');
	}
});
MSClientI =Ice.Class(MS.MSClient,
{
	setProxy:function(value)
	{
		this.proxy = value;
	},
	/** 分配媒体流
	 * 语音流分配(无对端地址)
	 * 参数: asParam --- 语音流参数
     * 返回值:  返回值大于等于0时为媒体流ID(MSID),-1为分配失败		
     **/
	AudioAllocRaw_async:function(cb,asParam)
	{
		this.proxy.callCallback("AudioAllocRaw",[cb,asParam]);
        Cr.Utils.log('AudioAllocRaw');  

	},
	/** 视频流分配(无对端地址)
	 * 参数: asParam --- 语音流参数
     * 返回值:  返回值大于等于0时为媒体流ID(MSID),-1为分配失败		
     **/
	VideoAllocRaw_async:function(cb,vsParam,srcSelf)
	{
		this.proxy.callCallback("VideoAllocRaw",[cb,vsParam,srcSelf]);
        Cr.Utils.log('VideoAllocRaw');  

	},
	
	/** 语音流分配(无对端地址)(WEBRTC)
	 * 参数:  asParam --- 语音流参数
	 *         strOutParams --- 返回WEBRTC媒体流信息:'sdp': webrtc客户端sdp、"icecandidate": ice candidate	
     * 返回值:  返回值大于等于0时为媒体流ID(MSID),-1为分配失败	
     **/
	AudioAllocRawExt2_async:function(cb,asParam,strParams,strOutParams)
	{
		this.proxy.callCallback("AudioAllocRawExt2",[cb,asParam,strParams]);
        Cr.Utils.log('AudioAllocRawExt2');  

	},
	/** 语音流分配(有对端地址)
	 * 参数:  asParam --- 语音流参数
	 *          peerAddr --- 对端IP,端口,MSID
     * 返回值:  返回值大于等于0时为媒体流ID(MSID),-1为分配失败	
     **/
	AudioAlloc_async:function(cb,asParam,strParams,strOutParams)
	{
		this.proxy.callCallback("AudioAllocRawExt2",[cb,asParam,strParams]);
        Cr.Utils.log('AudioAllocRawExt2');  
        
	},
	 /* 参数:    MSID --- 媒体流ID
	 *          peerAddr --- 对端IP,端口,MSID
     * 返回值:  返回值大于等于0时为媒体流ID(MSID),-1为分配失败	
     **/
	ModifyPeerAddr_async:function(cb,MSID,peerAddr)
	{
		this.proxy.callCallback("ModifyPeerAddr",[cb,asParam,strParams]);
        Cr.Utils.log('ModifyPeerAddr');  
	},


	//视频流分配(无对端地址)(WEBRTC)
	// 参数:  vsParam --- 视频流参数
	//        srcSelf --- 本端是否视频的源端
	//        strOutParams --- 返回WEBRTC媒体流信息:'sdp': webrtc客户端sdp、"icecandidate": ice candidate
    // 返回值:  返回值大于等于0时为媒体流ID(MSID),-1为分配失败	
	VideoAllocRawExt2_async:function (cb,vsParam,srcSelf,strParams,strOutParams)
	{
		this.proxy.callCallback("VideoAllocRawExt2",[cb,vsParam,srcSelf,strParams]);
		Cr.Utils.log('VideoAllocRawExt2_async');
	},
	// 修改媒体流对端地址信息(WEBRTC)
	// 参数: MSID --- 媒体流ID
	// peerAddr --- 对端IP,端口,MSID
	ModifyPeerAddrExt_async:function(cb,MSID,strParams)
	{
		cb.ice_response();
		this.proxy.callCallback("ModifyPeerAddrExt",[MSID,strParams]);
        Cr.Utils.log('ModifyPeerAddrExt');
	},
	////禁止终端上传视频到公网(ACCESS)
	DisableSendVideo2Internet_async:function(cb,cameraID)
	{
		cb.ice_response();
		this.proxy.callCallback("DisableSendVideo2Internet",[cameraID]);
        Cr.Utils.log('DisableSendVideo2Internet');
	},
	//允许终端上传视频到公网(ACCESS)
	EnableSendVideo2Internet_async:function(cb,cameraID)
	{
		cb.ice_response();
		this.proxy.callCallback("EnableSendVideo2Internet",[cameraID]);
        Cr.Utils.log('EnableSendVideo2Internet');
	},
	//释放媒体流
	// 参数: MSID --- 媒体流ID
	Free_async:function(cb,MSID)
	{
		cb.ice_response();
		this.proxy.callCallback("Free",[MSID]);
        Cr.Utils.log('Free');
	}
	
});
AnsQueReceptor =Ice.Class(Conference.AnsQueCallback, 
{
	setProxy:function(value)
	{
		this.proxy = value;
	},
	//��������
	askQuesNotify:function(id,askQue)
	{
		
		this.proxy.callCallback("askQuesNotify",[id,askQue]);
		Cr.Utils.log('askQuesNotify(id:%s)',id);
		
	},
	//����(�������ڴ���)������(��������Ϊδ����)
	lockQuesNotify:function(id,queDeal)
	{
		
		this.proxy.callCallback("lockQuesNotify",[id,queDeal]);
		Cr.Utils.log('lockQuesNotify(id:%s)',id);
		
	},
	
	//�ظ�����
	replyQuesNotify:function(id,queDeal)
	{
		
		this.proxy.callCallback("replyQuesNotify",[id,queDeal]);
		Cr.Utils.log('replyQuesNotify(id:%s)',id);
		
	},
	//�޸�����
	modifyQuesNotify:function(id,queModify)
	{
		
		this.proxy.callCallback("modifyQuesNotify",[id,queModify]);
		Cr.Utils.log('modifyQuesNotify(id:%s)',id);
		
	},
	//ɾ������
	delQuesNotify:function(id,termId)
	{
		
		this.proxy.callCallback("delQuesNotify",[id,termId]);
		Cr.Utils.log('delQuesNotify(id:%s)',id);
		
	},
	//ɾ������
	delAllQuesNotify:function(termId)
	{
		
		this.proxy.callCallback("delAllQuesNotify",[termId]);
		Cr.Utils.log('delAllQuesNotify(termId:%s)',termId);
		
	},
	//��������
	publicQuesNotify:function(id,bPublic,termId)
	{
		
		this.proxy.callCallback("publicQuesNotify",[id,bPublic,termId]);
		Cr.Utils.log('publicQuesNotify(id:%s)',id);
		
	},
	//�޸�������������
	quesTypeChangeNotify:function(id,typeID)
	{
		
		this.proxy.callCallback("quesTypeChangeNotify",[id,typeID]);
		Cr.Utils.log('quesTypeChangeNotify(id:%s)',id);
		
	},
	//���������޸�
	modifyQuesTypeNotify:function(termId,quesType)
	{
		
		this.proxy.callCallback("modifyQuesTypeNotify",[termId,quesType]);
		Cr.Utils.log('modifyQuesTypeNotify(termId:%s)',termId);
		
	},
	//ֱ���ʴ������޸�֪ͨ
	setBroadCastQuesNotify:function(bEnable)
	{
		
		this.proxy.callCallback("setBroadCastQuesNotify",[bEnable]);
		Cr.Utils.log('setBroadCastQuesNotify(bEnable:%s)',bEnable);
		
	}
});
ChatReceptor =Ice.Class(Conference.IMCallback, 
{
	setProxy:function(value)
	{
		this.proxy = value;
	},
	//接收IM消息
	receiveIMMsg:function(msgInfo)
	{
		
        //var msgInfo = args[0]
        if(Cr._zeorByte)
        {
            Cr._zeorByte = Cr.Utils.utf8ByteToUnicodeStr([0]);
        }
        var arr = Cr.Utils.chat2html(msgInfo.inMsg.msg,msgInfo.inMsg.font.color,msgInfo.inMsg.font.size);
        
        var nicknameArr = msgInfo.srcNickname.split('\0');
        
        var data = {"type":arr[0],"index":msgInfo.index,"msg":arr[2],'head':arr[1],"sendTime":msgInfo.inMsg.sendTime,
        "targetNickname":msgInfo.inMsg.targetNickname,"targetTermId":msgInfo.inMsg.targetTermId,
        "srcNickname":nicknameArr[0],"srcTermId":msgInfo.srcTermId,"ishost":nicknameArr.length>1?true:false}
		this.proxy.callCallback("receiveIMMsg",[new Cr.MsgInfo(data)]);
		Cr.Utils.log('receiveIMMsg(srcNickname:%s)',msgInfo.srcNickname);
		
	},
	//某某被屏蔽IM/允许IM
    notifyIMForbidStatus:function(operId,dstId,bForbid)
	{
		
		this.proxy.callCallback("notifyIMForbidStatus",[dstId,bForbid]);
	},
	//清空IM
    notifyClearIMMsg:function(operId)
	{
		
		this.proxy.callCallback("notifyClearIMMsg");
	},
	//删除IM消息
	notifyDeleteIMMsg:function(sn)
	{
		
		this.proxy.callCallback("notifyDeleteIMMsg",[sn]);
	}
});
VideoReceptor =Ice.Class(Conference.VideoCallback, 
{
	setProxy:function(value)
	{
		this.proxy = value;
	},
	/**
	 * 被请求打开视频
	 */
	notifyAllowVideoWall: function(b,opId){

		this.proxy.callCallback("notifyAllowVideoWall",[b,opId]);
	},
	/**
	  * 更新终端的视频状态，terminalID表示会议成员终端id
	  * status 视频分享状态
	  */
	updateStatus: function(terminalID,status,opId){
		this.proxy.callCallback("VideoUpdateStatus",[terminalID,status,opId]);
	},
	/**
	 * 请求打开视频
	 * operId 
	 */
	notifyOpenVideo:function(operId)
	{
		
		this.proxy.callCallback("notifyOpenVideo",[operId]);
	},
	/**
	 * 被主持人演示者打开视频
	 */
	startVideoByManager:function()
	{
		
		this.proxy.callCallback("startVideoByManager");
	},
	/**
	 * 通知终端视频功能是否开启
	 */
	notifyEnableVideo:function(termID,b,opId)
	{
		
		this.proxy.callCallback("notifyEnableVideo",[termID,b,opId]);
	},
	/**
	 * 更新主视频窗口
	 * mode 主视频窗口显示模式
	 * terminalID 要显示的终端ID
	 */
	updateFocusWindow:function(mode,terminalID)
	{
		
		this.proxy.callCallback("updateFocusWindow",[mode,terminalID]);
	},
	/**
	 * 更新电视墙布局
	 * mode 主视频窗口显示模式
	 * terminalID 要显示的终端ID
	 */
	updateVLayout:function(lo,opId)
	{
		
		this.proxy.callCallback("updateVLayout",[lo,opId]);
	},
	/**
	 * 更新主视频显示模式
	 */
	updateMainVideoShowMode:function(MVM_value,opID)
	{
		
		this.proxy.callCallback("updateMainVideoShowMode",[MVM_value,opID]);
	},
	/**
	 * 更新视频列表模式
	 */
	updateVideoListMode:function(jsonMode,opID)
	{
		
		this.proxy.callCallback("updateVideoListMode",[jsonMode,opID]);
	},
	/**
	 * 是否上传终端视频数据
	 */
	enableUpload:function(camID,bUpload)
	{
		
		this.proxy.callCallback("enableUpload",[camID,bUpload]);
	},
	/**
	 * 是否上传终端视频数据2
	 */
	enableUpload2:function(camID,VIDEO_SS_value)
	{
		
		this.proxy.callCallback("enableUpload2",[camID,VIDEO_SS_value]);
	},
	/**
	 * 12指定产生I帧
	 */
	generateIFrame:function(camID)
	{
		
		this.proxy.callCallback("generateIFrame",[camID]);
	},
	/**
	 * 拒绝开启视频，opid为拒绝的人
	 */
	notifyRefuseOpenVideo:function(opId)
	{
		
		this.proxy.callCallback("notifyRefuseOpenVideo",[opId]);
	},
	/**
	 * 取得视频列表
	 */
	getVideoSetting:function()
	{
		
		this.proxy.callCallback("getVideoSetting");
	},
	/**
	 * 设置视频设备
	 */
	setCamera:function(setting,opId)
	{
		
		this.proxy.callCallback("setCamera",[setting,opId]);
	},
	/**
	 * 设置摄像头 id值
	 */
	setCameraById:function()
	{
		
		this.proxy.callCallback("setCameraById");
	},
	/**
	 * 通知视频轮巡，如果演示者掉线由后台通知停止轮巡
	 */
	notifyVideoPolling:function(opId,bStart,interval)
	{
		
		this.proxy.callCallback("notifyVideoPolling",[opId,bStart,interval]);
	},
	/**
	 * 更新视频墙内容
	 */
	notifyPollingVideo:function(opId,watchIDs)
	{
		
		this.proxy.callCallback("notifyPollingVideo",[opId,watchIDs]);
	},
	/**
	 * 更新视频列表
	 */
	notifyVideoList:function(opId,jsonDat)
	{
		
		this.proxy.callCallback("notifyVideoList",[opId,jsonDat]);
	},
	/**
	 * 更新用户的摄像头信息
	 */
	notifyUpdateAllCameraInfos:function(termId,camInfos)
	{
		
		this.proxy.callCallback("notifyUpdateAllCameraInfos",[termId,camInfos]);
	},
	/**
	 * 通知开启的多摄像头个数
	 */
	notifySetOpenedCameraNumber:function(termId,mutiCamIDs)
	{
		
		this.proxy.callCallback("notifySetOpenedCameraNumber",[termId,mutiCamIDs]);
	},
	/**
	 * 通知调整方向
	 */
	notifyStartAdjustDirection:function(cameraId,ptz_dir)
	{
		
		this.proxy.callCallback("notifyStartAdjustDirection",[cameraId,ptz_dir]);
	},
	/**
	 * 通知变焦
	 */
	notifyStartAdjustZoom:function(cameraId,ptz_zoom)
	{
		
		this.proxy.callCallback("notifyStartAdjustZoom",[cameraId,ptz_zoom]);
	},
	/**
	 * 通知停止调整方向
	 */
	notifyStopAdjustDirection:function(cameraId)
	{
		
		this.proxy.callCallback("notifyStopAdjustDirection",[cameraId]);
	},
	/**
	 * 通知停止变焦
	 */
	notifyStopAdjustZoom:function(cameraId)
	{
		
		this.proxy.callCallback("notifyStopAdjustZoom",[cameraId]);
	}
});
AudioReceptor =Ice.Class(Conference.AudioCallback, 
{
	setProxy:function(value)
	{
		this.proxy = value;
	},
	/**
	 * 更新终端的音频状态
     * operatorID操作者ID,自己/演示者/主持人开麦时为本人/演示者/主持人termId,角色切换时的自动开麦为Conference.ANON_TERMID
     * terminalID会议成员终端id
     *status音频状态
	 */
    updateStatus:function(operatorID,terminalID,status)
	{
		
		this.proxy.callCallback("AudioUpdateStatus",[operatorID,terminalID,status]);
	},
	/**
	  * 更新语音能量
	  *
	  */
	updateVoiceEnergy:function(energys)
	{
		
		this.proxy.callCallback("updateVoiceEnergy",[energys]);
	},
	/**
	 * 更新当前声音能量最大的成员
	 * terminalID 终端ID 
	 */
	updateSpeaker:function(terminalID)
	{
		
		this.proxy.callCallback("updateSpeaker",[terminalID]);
	},
	/**
	 * 全体静音，除主持人，演示者，处于申请状态的 
	 */
	closeAll:function(operatorID)
	{
		
		this.proxy.callCallback("closeAll",[operatorID]);
	},
	/**
	 * 开始，停止背景音乐广播消息 
	 */
	playBackgroundMusic:function(operatorID,sPlay)
	{
		
		this.proxy.callCallback("playBackgroundMusic",[operatorID,sPlay]);
	},
	//6
	notifyVoiceHowling:function(termid,bHowling)
	{
		
		this.proxy.callCallback("notifyVoiceHowling",[termid,bHowling]);
	},
	//7
	notifyVoiceNoise:function(termid,bNoising)
	{
		
		this.proxy.callCallback("notifyVoiceNoise",[termid,bNoising]);
	},
	//8
	getRemoteAudioInfNotify:function(cb,reqTermID)
	{
		cb.ice_response();
		this.proxy.callCallback("getRemoteAudioInfNotify",[reqTermID]);
	},
	//9
	remoteAudioSetNotify:function(opeTermId,rAudio)
	{
		
		this.proxy.callCallback("remoteAudioSetNotify",[opeTermId,rAudio]);
	},
	/**
	 * 通知同局域网内不要开太多的麦 
	 */
	notifyLanLessMicOpen:function()
	{
		
		this.proxy.callCallback("notifyLanLessMicOpen");
	}
});
/**
 * 云屋直播
 * @author deva.wang <deva.wang@cloudroom.com>
 * @constructor
 * @param config配置 
 */	
Cr.LHProxy = function(config)
{
	this.__config = config;
	if(this.__config && (this.__config["protocol"] == "ws" || this.__config["protocol"] == "wss"))
	{
		this._protocol = this.__config["protocol"]
	}else
	{
		this._protocol = "wss"
	}
	this._type = "html5"
	this._logining = false
	Cr.__init = true;
}


/**
 * 初始化
 * @access private
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.init = function()
{
	var async = new Cr.AsyncResult();
    var err_code = CR_NOERR
    var err_desc = ''
	this.callbackDict = {};
	
	this._initData = new Ice.InitializationData()
	this._initData.properties = Ice.createProperties()
	this._initData.properties.setProperty("Ice.Trace.Network", "0")
	this._initData.properties.setProperty("Ice.Trace.Protocol", "0")
	this._initData.properties.setProperty("Ice.ACM.Client", "0")
	this._initData.properties.setProperty("Ice.Default.EncodingVersion", "1.0")
    async.complete([CR_NOERR,""])

	
	return async;
}
/**
 * 注册回调对象
 * @access private
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.registeredCallback = function(name,fun)
{
	if(this.callbackDict[name])
	{
		throw "已经存在的注册对象";
	}else
	{
		this.callbackDict[name] = fun;
	}
	
}
/**
 * 反注册回调对象
 * @access private
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.unregisterCallback = function(name,fun)
{
	this.callbackDict[name] = null;
	delete this.callbackDict[name];
}
Cr.LHProxy.prototype.callCallback = function(name,aArgs)
{
	var fun = this.callbackDict[name]
	if(fun && typeof(fun) == "function")
	{
		fun.call(null,aArgs)
	}
}
Cr.LHProxy.prototype.initCon= function()
{
	if(this._communicator)
		this._communicator.shutdown();
	this._communicator = null;
	if(this._connection)
		this._connection.destroy(0);
	this._connection = null;
	if(this._adapter)
		this._adapter.destroy();
	this._adapter = null;
	if(this._routerPrx)
		this._routerPrx.destroySession();
	this._routerPrx = null;
}
/**
 * 会议登录
 * @access private
 * @param {string} value - crmt串认证
 * @param {string} termId - termid 上次登录的id默认为空
 * @param {object} myDetail - myDetail用户详细信息默认为空
 * @param {string} client_pcid - client_pcid 唯一识别串
 * @param {string} openid - openid 用户的微信openID
 */
Cr.LHProxy.prototype.login = function(value,termId,myDetail,client_pcid,openid)
{
	//----------------------------------------------------------
	//
	//登录会议服务器
	//
	//---------------------------------------------------------
	var login = function(accessNo)
	{
		var data = {};
		
		
		this._routerPrx.createSession('T'+Cr.crmt["MEET"][0], '').then(
		function(session)
		{
			this._session = session;
			return this._communicator.createObjectAdapterWithRouter("CallbackAdapter",this._routerPrx)
			
		}.bind(this)).then(function(adapter)
		{
			this._adapter = adapter;
			this._adapter.activate()
			return this._routerPrx.ice_getConnection()
			
		}.bind(this)).then(function(connection)
		{
			this._connection = connection;
			this._connection.setAdapter(this._adapter);
			return this._routerPrx.getCategoryForClient()
		}.bind(this)).then(function(category)
		{
			//登录服务器
			this._category = category
			var confObjId = 'c'+Cr.crmt["MEET"][0]+'/ConferenceRoom  @ c'+Cr.crmt["MEET"][0]+'-ReplicaConfCtrlAdapters';
			var server = Conference.ConferenceRoomPrx.uncheckedCast(this._communicator.stringToProxy(confObjId));

			
			var loginRequest = new Conference.LoginRequest();
			loginRequest.confId = Cr.crmt["MEET"][0];
			loginRequest.confKey =  Cr.crmt["MEET"][1];
			if(termId)
			{
				loginRequest.termId = termId;
			}else
			{
				loginRequest.termId = 0;//crmtResponse["ACNT"][0];
			}
			if(myDetail)
			{
				loginRequest.memberId = myDetail.id;
				loginRequest.memberType = myDetail.type;
				loginRequest.nickname = myDetail.nickname;
			}else
			{
				loginRequest.memberId = Cr.crmt["ACNT"][0];
				loginRequest.memberType = Cr.crmt["ACNT"][1];
				loginRequest.nickname = Cr.crmt["ACNT"][3];
			}
			
			loginRequest.accessNo = accessNo;
			
			loginRequest.callbacks = new Ice.HashMap();
			loginRequest.extProperty =  new Ice.HashMap();
			loginRequest.extProperty.set("client_pcid",client_pcid);
			//loginRequest.extProperty.set(Conference.CLINET_IS_WEB_VIEWER,'1');
			if(myDetail){
                loginRequest.extProperty.set(Conference.CLIETN_PRIV_DAT,myDetail.nickname); 
            }else{
                loginRequest.extProperty.set(Conference.CLIETN_PRIV_DAT,Cr.crmt["ACNT"][3]);
            }
            //登录上传使用的平台
            var isMac = /macintosh|mac os x/i.test(navigator.userAgent);
            var isWin =  /windows|win32/i.test(navigator.userAgent);
            var isLinux = /linux/i.test(navigator.userAgent);
            var isAndroid = navigator.userAgent.indexOf('Android') > -1 || navigator.userAgent.indexOf('Adr') > -1;
            var isiOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
            var plantForm = "";
            if(isMac){
            	plantForm = Conference.PLATFORMTYPE_MAC;
            }else if(isWin){
            	plantForm = Conference.PLATFORMTYPE_WIN32;
            }else if(isLinux){
            	plantForm = Conference.PLATFORMTYPE_LINUX;
            }else if(isAndroid){
            	plantForm = Conference.PLATFORMTYPE_ANDROID;
            }else if(isiOS){
            	plantForm = Conference.PLATFORMTYPE_IOS;
            }
            //平台信息
			loginRequest.extProperty.set(Conference.CLINET_PLATFORM,plantForm);

			//浏览器信息
			var ua = navigator.userAgent.toLowerCase();
			var Sys = {},isBrower="";
			if(window.ActiveXObject){
				Sys.ie = ua.match(/msie ([\d.]+)/)[1];
			}else if(document.getBoxObjectFor){
				Sys.firefox = ua.match(/firefox\/([\d.]+)/)[1]
			}else if(window.MessageEvent && !document.getBoxObjectFor){
				if(ua.match(/chrome\/([\d.]+)/)){
					Sys.chrome = ua.match(/chrome\/([\d.]+)/)[1]
				}else{
					Sys.chrome = "chrome0"
				}
			}else if(window.opera){
				Sys.opera = ua.match(/opera.([\d.]+)/)[1];
			}else if(window.openDatabase){
				Sys.safari = ua.match(/version\/([\d.]+)/)[1]
			}else if(navigator.userAgent.match(/MicroMessenger\/([\d\.]+)/i)){
				Sys.weixin = navigator.userAgent.match(/MicroMessenger\/([\d\.]+)/i)[1];
			}else if(ua.match(/QQ/i) == "qq"){
				Sys.QQ = "QQbrow"
			}
			if(Sys.ie){
				isBrower = "IE:"	+ Sys.ie;	
			}else if(Sys.firefox){
				isBrower = "firefox:" +  Sys.firefox;	
			}else if(Sys.chrome){
				isBrower = "chrome:" + Sys.chrome;
			}else if(Sys.opera){
				isBrower = "opera:" +  Sys.opera;
			}else if(Sys.safari){
				isBrower = "safari:" +  Sys.safari;
			}else if(Sys.weixin){
				isBrower = "weixin:" +　wechatInfo[1];
			}else if(Sys.QQ){
				isBrower = "QQbrow:"
			}
            //浏览器信息
			loginRequest.extProperty.set(Conference.CLINET_BROWSER_INFO,isBrower);
			
			//视频支持的类型
			var rtc_codecs = "",isvp8="",isH264="";
			window.loginConnection = new RTCPeerConnection({"iceServers": [{urls: 'stun:121.42.156.84:3478'}]});
            var offerOptions = {
                  offerToReceiveAudio: false,
                  offerToReceiveVideo: true,
                  voiceActivityDetection: false
            };
             window.loginConnection.createOffer(function(offer) {
               if(offer.sdp.indexOf("H264") != -1){
                    isH264 = "H264"
               }
               if(offer.sdp.indexOf("VP8") != -1){
                    isvp8 = "vp8";
               }
               if(isvp8 && isH264){
                    rtc_codecs = "vp8,H264";
                }else if(isvp8){
                    rtc_codecs = "vp8";
                }else if(isH264){
                    rtc_codecs = "H264";
                }
                loginRequest.extProperty.set(Conference.CLINET_WEBRTC_CODECS,rtc_codecs);
                //是否支持vp8
                if(isvp8 == "vp8"){
                    loginRequest.extProperty.set(Conference.CLINET_VP8_SUPPORT,isvp8);
                }
            }, function(error) {
            	console.log(error)
            },offerOptions);
            
            loginRequest.extProperty.set(Conference.CLINET_OPENID,openid);
           

			loginRequest.extProperty.set(Conference.CLINET_DEVICETYPE,Conference.DEVICETYPE_WEBRTC);
			
			var conferenceIdent = new Ice.Identity();
			conferenceIdent.name = 'ConferenceCallback'
			conferenceIdent.category = this._category;
			
			this._conferenceReceptor = new ConferenceReceptor();
			this._conferenceReceptor.setProxy(this);
			this._adapter.add(this._conferenceReceptor,conferenceIdent);
			var conferenceCallbackPrx = Conference.ConferenceCallbackPrx.uncheckedCast( this._adapter.createDirectProxy(conferenceIdent));
			loginRequest.callbacks.set("ConferenceCallback",conferenceCallbackPrx);
			
			var imIdent = new Ice.Identity();
			imIdent.name = 'IMCallback'
			imIdent.category =  this._category;
			
			this._chatReceptor = new ChatReceptor();
			this._chatReceptor.setProxy(this);
			this._adapter.add(this._chatReceptor,imIdent);
			var imCallbackPrx = Conference.IMCallbackPrx.uncheckedCast(this._adapter.createDirectProxy(imIdent));
			loginRequest.callbacks.set("IMCallback",imCallbackPrx);
			
			var ansQueIdent = new Ice.Identity();
			ansQueIdent.name = 'AnsQueCallback'
			ansQueIdent.category =  this._category;
			
			this._ansQueReceptor = new AnsQueReceptor();
			this._ansQueReceptor.setProxy(this);
			this._adapter.add(this._ansQueReceptor,ansQueIdent);
			var ansQueCallbackPrx = Conference.AnsQueCallbackPrx.uncheckedCast(this._adapter.createDirectProxy(ansQueIdent));
			loginRequest.callbacks.set("AnsQueCallback",ansQueCallbackPrx);

			var videoIdent = new Ice.Identity();
			videoIdent.name = 'VideoCallback'
			videoIdent.category =  this._category;
			
			this._videoReceptor = new VideoReceptor();
			this._videoReceptor.setProxy(this);
			this._adapter.add(this._videoReceptor,videoIdent);
			var videoCallbackPrx = Conference.VideoCallbackPrx.uncheckedCast(this._adapter.createDirectProxy(videoIdent));
			loginRequest.callbacks.set("VideoCallback",videoCallbackPrx);

			var audioIdent = new Ice.Identity();
			audioIdent.name = 'AudioCallback'
			audioIdent.category =  this._category;
			
			this._audioReceptor = new AudioReceptor();
			this._audioReceptor.setProxy(this);
			this._adapter.add(this._audioReceptor,audioIdent);
			var audioCallbackPrx = Conference.AudioCallbackPrx.uncheckedCast(this._adapter.createDirectProxy(audioIdent));
			loginRequest.callbacks.set("AudioCallback",audioCallbackPrx);

			var mSClientI = new Ice.Identity();
			mSClientI.name = 'MS.MSClient'
			mSClientI.category =  this._category;
			
			this._mSClientI = new MSClientI();
			this._mSClientI.setProxy(this);
			this._adapter.add(this._mSClientI,mSClientI);
			var mSClientPrx = MS.MSClientPrx.uncheckedCast(this._adapter.createDirectProxy(mSClientI));
			loginRequest.callbacks.set("MS.MSClient",mSClientPrx);
			return server.login(loginRequest)
		}.bind(this)).then(function(loginResponse)
		{
			data["termId"] = loginResponse.termId;
			data["activeMembers"] = loginResponse.activeMembers;
			data["myDetail"] = loginResponse.myDetail;
			data["serverTime"] = loginResponse.ServerUTCTime * 1000 - (new Date()).getTime();
			data["isBegan"] = loginResponse.isBegan;
			data["countdown"] = loginResponse.countdown;
			data["mainVideoTermID"] = loginResponse.mainVideoTermID;
			data["pstnnum"] = loginResponse.confInfo.get(Conference.CONFINFO_PSTNNUM)
			data["pstnpwd"] = loginResponse.confInfo.get(Conference.CONFINFO_PSTNPWD)
			data["freeConf"] = loginResponse.confInfo.get(Conference.CONFINFO_FREECONF)
			data["isBroadcating"] = loginResponse.confInfo.get(Conference.CONFINFO_IS_BROADCATING)
			//data["webViewerRights"] = loginResponse.confInfo.get(Conference.CONFINFO_WEBVIEWER_RIGHTS).split(';');
			data["webviewerQues"] = loginResponse.confInfo.get(Conference.CONFINFO_WEBVIEWER_QUES)
			
			
			for (var  index in data["activeMembers"]) 
			{
				var member = data["activeMembers"][index]
				if(member['termId'] == data['termId'])
				{
					data["nickname"] =  member.nickname;
					data['bindId'] = member['bindId'];
					data['openedCamIDs'] = member.extProperty.get(Conference.MINFO_OPENEDCAMIDS);
				}
				
			}
			this._conferenceRequest =  Conference.ConferenceSessionPrx.uncheckedCast(loginResponse.modules.get("ConferenceSession"));
			this._chatRequest =  Conference.IMSessionPrx.uncheckedCast(loginResponse.modules.get("IMSession"));
			
			this._ansQuesCtrl =  Conference.AnsQuesCtrlPrx.uncheckedCast(loginResponse.modules.get("AnsQuesCtrl"));

			this._videoCtrl =  Conference.VideoCtrlPrx.uncheckedCast(loginResponse.modules.get("VideoCtrl"));
			this._audioCtrl =  Conference.AudioCtrlPrx.uncheckedCast(loginResponse.modules.get("AudioCtrl"));

			this._clientReport =  MS.ClientReportPrx.uncheckedCast(loginResponse.modules.get("ClientReport"));

			this._logining = false;
			if(window.loginConnection){
				window.loginConnection.close();
			}
            window.loginConnection = null;
			async.complete([CR_NOERR,"",new Cr.MeetInfo(data)])	

			Cr.Utils.log("登陆耗时："+((new Date()).getTime() - Cr.startTime));
			
		}.bind(this)).exception(function(ex) 
		{
			this._logining = false;
			if(ex instanceof Ice.SocketException)
			{
				async.complete([CR_SOCKETEXCEPTION,"socket错误"])	

			}else if(ex instanceof Conference.MemberAlreadyInCanTryVisitor || ex instanceof Conference.MemberAlreadyInMeet)
			{
				async.complete([CR_MEMBER_ALREADY_IN_MEET,"用户已存在"])	
			}else if(ex instanceof Conference.MemberOverflowError)
			{
				async.complete([CR_CONCURRENCY_OVER,"并发数超出"])	
			}else if(ex instanceof Conference.ConferencePrepareError){
				async.complete([CR_MEET_IS_OPEN_ING,"会议正在打开中"]);
				setTimeout(function(){
					CR__Login(value,termId,myDetail,client_pcid,openId,livetype,livemobile,loginserver)
				},10000)	
			}else
			{
				async.complete([CR_INNER_ERR,ex.toString()])	
				
			}
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this)); 
	}.bind(this);
	//----------------------------------------------------------
	//
	//服务会议器探测
	//
	//-----------------------------------------------------------
	


	var ping = function(index)
	{
		
		var acssvr =  acssvrs[index];
		//var port = 443;
		if(document.location.protocol == "https:"){
            var port = 2066;
        }else{
            var port = 13111;
        }
        var routerPrx = Glacier2.RouterPrx.uncheckedCast(this._communicator.stringToProxy("s"+acssvr[0]+"/Access:"+this._protocol+" -h "+acssvr[1] + " -p "+port))
		routerPrx.ice_ping().then(function()
		{
			Cr.Utils.log("结束 ping("+this._protocol+"://"+acssvr[1]+":"+port+")耗时："+(new Date().getTime()-startPingTime))
			if(!pingEnd)
			{
				pingEnd = true
				this._routerPrx = routerPrx;
				this._communicator.setDefaultRouter(this._routerPrx);
				//登陆会议
				login(acssvr[0]);
				Cr.Utils.log(acssvr[0]);
			}
			
		}.bind(this)).exception(function(ex) 
		{
			Cr.Utils.log("结束 ping("+this._protocol+"://"+acssvr[1]+":"+port+")网络不好")
			if(pingEnd)
			{
				ping_failure_length++;
			if(ping_failure_length == acssvrs_length)
				{
					this._logining = false
					async.complete([CR_NOTAVAILABLESERVER,"没有可用服务器"])
				}
			}
			
			
		}.bind(this));
	}.bind(this);
	
	
	var probeAcssvr = function()
	{
		Ice.Promise.try2(function()
		{
			this._communicator = Ice.initialize(this._initData)
			startPingTime = (new Date()).getTime();
			acssvrs = Cr.crmt["ACSSVR"];
			acssvrs_length = acssvrs.length;
			pingEnd = false
			ping_failure_length = 0;

			for (var i = 0; i < acssvrs_length; i++) 
			{	
                ping(i);
			}
		}.bind(this)).exception(function(ex) 
		{
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
			this._logining = false
			async.complete([CR_UNKNOWERR,"未知错误"])

		}.bind(this)); 
	}.bind(this)
	
	//----------------------------------------------------------
	//
	//crmt解析
	//
	//-----------------------------------------------------------
	var parseCrmt = function(data)
	{
		Cr.crmt = {};
		var crmtRpe = atob(data.substr(5)); // 解码12

		var crmtRpeArr = crmtRpe.split("\n");

		for (var  index in crmtRpeArr) 
		{
			var item = crmtRpeArr[index]

			var itemArr = item.match(/-(\w+?)=(\S+)/);
			if(itemArr != null && itemArr.length ==3)
			{
				Cr.crmt[itemArr[1]] = itemArr[2]
				Cr.Utils.log('key:%s value:%s',itemArr[1],itemArr[2])
			}
		}

		var acntArr =  Cr.crmt["ACNT"].split(";");
		var nickNameHexArr = acntArr[3].match(/../g);
		var nickNameByte = new ArrayBuffer(nickNameHexArr.length);
		var nickNameDataView = new DataView(nickNameByte)
		var bytes = [];
		for (var i = 0; i < nickNameHexArr.length; i++) {
			nickNameDataView.setUint8(i,parseInt(nickNameHexArr[i],16))
			bytes[i] = nickNameDataView.getUint8(i);
		}
		var nickName = Cr.Utils.utf8ByteToUnicodeStr(bytes);
		acntArr[3] = nickName;

		Cr.crmt["ACNT"] = acntArr;
		
		Cr.crmt["MEET"] =  Cr.crmt["MEET"].split(";");
		
		var acssvrArr =  Cr.crmt["ACSSVR"].split(";");
		acssvrArr.pop();
		for (var i = 0; i < acssvrArr.length; i++) 
		{
			acssvrArr[i] = acssvrArr[i].split(":");
		}
		Cr.crmt["ACSSVR"] = acssvrArr;
	}.bind(this)
	
	if(this._logining)
	{
		return
	}
	var async = new Cr.AsyncResult();
	try
	{
		this._logining = true
		var ping_failure_length = 0;
		var pingEnd = false
		var startPingTime = 0;
		var acssvrs_length = 0;
		var acssvrs = null;
		
		Cr.startTime = (new Date()).getTime();
		
		this.initCon()

		if(Cr.crmt)
		{
			Ice.Promise.try2(function()
			{
				//parseCrmt(data);
				probeAcssvr();
			}.bind(this)).exception(function(ex) 
			{
				Cr.Utils.log(ex.toString());
				Cr.Utils.log(ex.stack);
				async.complete([CR_UNKNOWERR,"未知错误"])
			}.bind(this)); 
		}else
		{
			var webCrmt =atob(value); // 解码12
			var host = webCrmt.match(/-MEETURL=(.*)/)[1];
			
			//host = host.replace("10.8.8.220","10.8.8.220:543");
			if(document.location.protocol == "https:"){
                host = host.replace("10.8.8.220","10.8.8.220:543");
            }else{
                host = host.replace("10.8.8.220","10.8.8.220:80");
            }
			var url = document.location.protocol + "//"+ host;
			url = url.replace("getLiveAccKey","getWebrtcAccKey");
			url = url.replace("www.cloudroom.com","rtc.cloudroom.com");
			var pcCrmt = webCrmt+"\r\n-PRODUCT=win32_net"
			var pcCrmtBase64 = "crmt:"+btoa(pcCrmt).replace(/\r\n/g,"");
			Ice.Promise.try2(function()
			{
				$.ajax({
					type: 'POST',
					url: url,
					data:pcCrmtBase64,
					dataType:'text',
					success:function(data,status)
					{
						if(status == "success")
						{
							if(data.indexOf("erro:") != -1)
							{
								this._logining = false
								async.complete([CR_AUTHERROR,data])
							}else
							{
								parseCrmt(data);
								probeAcssvr();
							}
						}else
						{
							this._logining = false
							async.complete([CR_NOSERVER_RSP,"服务器没有响应"])
						}
					}.bind(this)
				});
			}.bind(this)).exception(function(ex) 
			{
				Cr.Utils.log(ex.toString());
				Cr.Utils.log(ex.stack);
				this._logining = false
				async.complete([CR_UNKNOWERR,"未知错误"])
			}.bind(this)); 
		}
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 刷新会话session
 * @access private
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.refreshSession = function()
{
	var async = new Cr.AsyncResult();
	try
	{
		this._routerPrx.refreshSession().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 保持心跳代理
 * @access private
 * @param {number} watch - 否观看直播："0"--没有观看,"1"	--观看中
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.keepAlive = function(watch)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		statusDict =  new Ice.HashMap();
		statusDict.set("w",watch.toString());

		this._conferenceRequest.keepAlive(statusDict).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 退出会议
 * @access private
 * @param {string} reason - 退出会议的原因
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.exit = function(reason)
{
	
	var async = new Cr.AsyncResult();
	try
	{

		this._conferenceRequest.exit(reason).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 获取在线人数信息
 * @access private
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.getActiveMembers = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		statusDict =  new Ice.HashMap();

		this._conferenceRequest.getActiveMembers().then(function(membersList)
		{
			for (var i in membersList)
			{
				var msgInfo = membersList[i].extProperty;
				
				var arr = msgInfo.get(Conference.MINFO_OPENEDCAMIDS)
                if(arr != undefined){
                    arr = arr.split(";")[0];
                }
				membersList[i].openedCamIDs = arr;
			}
			async.complete([CR_NOERR,"",membersList])	
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 发送聊天消息
 * @access private
 * @param {number} targetTermId - 聊天对象id
 * @param {string} targetNickname - 聊天对象昵称
 * @param {object} font - 字体
 * @param {string} msg - 消息
 * @param {number} sendTime - 发送时间
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.snedIMMsg = function(targetTermId,targetNickname,font,msg,sendTime)
{
	var async = new Cr.AsyncResult();
	try
	{
		//Cr.Utils.log("msg:"+msg);
		var reqContext = new Ice.Context();
		reqContext["_fwd"] = "z";
		var inImmsginfo = new Conference.InIMMsgInfo(); 
		inImmsginfo.targetTermId = targetTermId;
		inImmsginfo.targetNickname = targetNickname;
		inImmsginfo.font = font;
		inImmsginfo.msg = Cr.Utils.html2chat(msg);
		inImmsginfo.sendTime = sendTime;
		this._chatRequest.sendIMMsg(inImmsginfo,reqContext).then(function()
		{
			async.complete([CR_NOERR,""])		
		}.bind(this)).exception(function(ex) 
		{	
			
			if(ex instanceof Conference.ContainsSensitiveWords)
			{
				async.complete([CR_CONTAINSSENSITIVEWORDS,"包含了敏感词"])	

			}else if(ex instanceof Conference.NotPermitError)
			{
				async.complete([CR_NOT_CHAT_PERMIT,"没有聊天权限"])	
			}else
			{
				async.complete([CR_UNKNOWERR,"未知错误"])	
			}

			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	
	return async;
}
/**
 * 获取公聊IM消息条数
 * @access private
 * @returns {Cr.AsyncResult} IM消息条数
 */	
Cr.LHProxy.prototype.getIMMsgCount = function()
{
	var async = new Cr.AsyncResult();
	try
	{
		this._chatRequest.getIMMsgCount().then(function(count)
		{
			
			async.complete([CR_NOERR,"",count])	
			
		}.bind(this)).exception(function(ex) 
		{
				async.complete([CR_UNKNOWERR,"未知错误"])		
				Cr.Utils.log(ex.toString());
				Cr.Utils.log(ex.stack);
		}.bind(this));
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 获取所有聊天记录
 * @access private
 * @param {number} index - 从index开始获取
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.getLastMsg = function(index)
{
	var async = new Cr.AsyncResult();
	try
	{
		var reqContext = new Ice.Context();
		reqContext["_fwd"] = "z";

		this._chatRequest.getLastMsg(index,reqContext).then(function(outMsgList)
		{
			
			var objList = [];
			for (var i in outMsgList)
			{
				var msgInfo = outMsgList[i];
				var nicknameArr = msgInfo.srcNickname.split('\0');
				var arr = Cr.Utils.chat2html(msgInfo.inMsg.msg,msgInfo.inMsg.font.color,msgInfo.inMsg.font.size);
				var obj = {"type":arr[0],"index":msgInfo.index,"msg":arr[2],'head':arr[1],"sendTime":msgInfo.inMsg.sendTime,
						"targetNickname":msgInfo.inMsg.targetNickname,"targetTermId":msgInfo.inMsg.targetTermId,
						"srcNickname":nicknameArr[0],"srcTermId":msgInfo.srcTermId,"ishost":nicknameArr.length>1?true:false};
				objList.push(new Cr.MsgInfo(obj))
			}
			async.complete([CR_NOERR,"",objList])	
			
		}.bind(this)).exception(function(ex) 
		{
				async.complete([CR_UNKNOWERR,"未知错误"])		
				Cr.Utils.log(ex.toString());
				Cr.Utils.log(ex.stack);
		}.bind(this));
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 获取指定聊天记录
 * @access private
 * @param {number} index - 从index开始获取
 * @param {number} count - 获取的数量
 */	
Cr.LHProxy.prototype.getLastNMsg = function(index,count)
{
	var async = new Cr.AsyncResult();
	try
	{
		var reqContext = new Ice.Context();
		reqContext["_fwd"] = "z";

		this._chatRequest.getLastNMsg(index,count,reqContext).then(function(outMsgList)
		{
			var objList = [];
			for (var i in outMsgList)
			{
				var msgInfo = outMsgList[i];
				var nicknameArr = msgInfo.srcNickname.split('\0');
				var arr = Cr.Utils.chat2html(msgInfo.inMsg.msg,msgInfo.inMsg.font.color,msgInfo.inMsg.font.size);
				var obj = {"type":arr[0],"index":msgInfo.index,"msg":arr[2],'head':arr[1],"sendTime":msgInfo.inMsg.sendTime,
						"targetNickname":msgInfo.inMsg.targetNickname,"targetTermId":msgInfo.inMsg.targetTermId,
						"srcNickname":nicknameArr[0],"srcTermId":msgInfo.srcTermId,"ishost":nicknameArr.length>1?true:false};
				objList.push(new Cr.MsgInfo(obj))
			}
			async.complete([CR_NOERR,"",objList])	
			Cr.Utils.log("获取聊天记录耗时："+((new Date()).getTime() - Cr.startTime));
		}.bind(this)).exception(function(ex) 
		{
			async.complete([CR_UNKNOWERR,"未知错误"])		

			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 获取直播链接
 * @access private
 */	
Cr.LHProxy.prototype.getBroadCastUrl = function()
{
	var async = new Cr.AsyncResult();
	try
	{
		this._conferenceRequest.getBroadCastUrl().then(
		function(broadCastDict)
		{
			var data = {"rtmp":broadCastDict.get(Conference.BOARDCAST_RTMP),"hls":broadCastDict.get(Conference.BOARDCAST_HLS)};
			async.complete([CR_NOERR,"",data])	
			
		}).exception(
			function(ex) {

				async.complete([CR_UNKNOWERR,"未知错误"])		
				Cr.Utils.log(ex.toString());
				Cr.Utils.log(ex.stack);
			}
		);
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}

/**
 * 提问
 * @access private
 * @param {string} typeID - 问题类型ID
 * @param {number} asktime - 时间
 * @param {short} termID - 提问人ID
 * @param {string} headadurl - 提问人头像
 * @param {string} content - 提问内容      
 * @param {string} nickname - 提问人昵称

 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.askQues = function(typeID,asktime,termID,headadurl,content,nickname)
{

	
	var async = new Cr.AsyncResult();
	try
	{
		var quesAsk = new Conference.QuesAsk(); 
		quesAsk.typeID = typeID;
		quesAsk.asktime = asktime;
		quesAsk.termID = termID;
		if(headadurl && headadurl != '')
		{
			content = "<headimg src=\""+headadurl+"\"/>"+ + content
		}
		quesAsk.content = content;//Cr.Utils.html2chat(content);;
		quesAsk.nickname = nickname;
		this._ansQuesCtrl.askQues(quesAsk).then(
		function(id)
		{
			async.complete([CR_NOERR,"",id])	
			
		}).exception(
			function(ex) {

				async.complete([CR_UNKNOWERR,"未知错误"])		
				Cr.Utils.log(ex.toString());
				Cr.Utils.log(ex.stack);
			}
		);
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 获取问题信息列表
 * @access private
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.getQuesList = function()
{
	var async = new Cr.AsyncResult();
	try
	{
		this._ansQuesCtrl.getQuesList().then(
		function(list)
		{
			quesList = []
			for(var i in list)
			{
				var obj = list[i];
				quesList.push(new Cr.QuesInf(obj));
			}

			async.complete([CR_NOERR,"",quesList])	
			
		}).exception(
			function(ex) {

				async.complete([CR_UNKNOWERR,"未知错误"])		
				Cr.Utils.log(ex.toString());
				Cr.Utils.log(ex.stack);
			}
		);
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 获取抽奖信息
 * @access private
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.getLuckyDrawCfg = function()
{
	var async = new Cr.AsyncResult();
	try
	{
		this._conferenceRequest.getLuckyDrawCfg().then(
		function(LuckyDrawCfg)
		{
			var data = LuckyDrawCfg;
			async.complete([CR_NOERR,"",data])	
			
		}).exception(
			function(ex) {
				async.complete([CR_UNKNOWERR,"未知错误"])
			}
		);
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 抽奖报名信息
 * @access private
 * @param {obj} members - 成员信息
 * @param {number} memberType - 客户信息 0是客户端 2是收看端 3是所有名单
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.joinLuckyDrawMembers = function(members,memberType)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._conferenceRequest.joinLuckyDrawMembers(members,memberType).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 开始服务器录制
 * @access jsonCfg采用json格式
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.startSvrRecord = function(jsonCfg)
{
	var async = new Cr.AsyncResult();
	try
	{
		this._conferenceRequest.startSvrRecord(jsonCfg).then(
		function()
		{
			//var data = LuckyDrawCfg;
			//async.complete([CR_NOERR,"",data])
			async.complete([CR_NOERR])	
			
		}).exception(
			function(ex) {
				async.complete([CR_UNKNOWERR,"未知错误"])
			}
		);
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 更新录制信息, jsonCfg采用json格式
 * @access jsonCfg采用json格式
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.updateSvrRecCfg = function(jsonCfg)
{
	var async = new Cr.AsyncResult();
	try
	{
		this._conferenceRequest.updateSvrRecCfg(jsonCfg).then(
		function()
		{
			//var data = LuckyDrawCfg;
			//async.complete([CR_NOERR,"",data])
			async.complete([CR_NOERR,""])	
			
		}).exception(
			function(ex) {
				async.complete([CR_UNKNOWERR,"未知错误"])
			}
		);
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 停止服务器云端录制
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.stopSvrRecord = function()
{
	var async = new Cr.AsyncResult();
	try
	{
		this._conferenceRequest.stopSvrRecord().then(
		function()
		{
			//var data = LuckyDrawCfg;
			//async.complete([CR_NOERR,"",data])
			async.complete([CR_NOERR,""])	
			
		}).exception(
			function(ex) {
				async.complete([CR_UNKNOWERR,"未知错误"])
			}
		);
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/************************************************************   video 相关 方法**********************************************/
/**
 * 获取视频设备信息
 * @access private
 * @param {obj} members - 成员信息
 * @param {number} memberType - 
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.setVideoDeviceStatus = function(bool)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setDeviceStatus(bool).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 开启视频墙
 */	
Cr.LHProxy.prototype.allowVideoWall = function(bool)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.allowVideoWall(bool).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 开启视频设备
 * @access private
 * @param {obj} members - 成员信息
 * @param {number} memberType - 
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.startVideo = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.startVideo().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 关闭视频设备
 * @access private
 * @param {obj} members - 成员信息
 * @param {number} memberType - 
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.stopVideo = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.stopVideo().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 主持人演示者请求他人开启视
 */	
Cr.LHProxy.prototype.reqOpenVideo = function(terminalID)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.reqOpenVideo(terminalID).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 主持人演示者开启他人视频
 * terminalID 受控的终端ID
 * 异常表示可能因为资源达到最大值失败
 * @access public
 */	
Cr.LHProxy.prototype.startVideoEx = function(terminalID)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.startVideoEx(terminalID).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 主持人演示者他人视频
 * terminalID 受控的终端ID
 * 异常表示可能因为资源达到最大值失败
 * @access public
 */	
Cr.LHProxy.prototype.stopVideoEx = function(terminalID)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.stopVideoEx(terminalID).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 开启关闭视频功能
 * @access public
 */	
Cr.LHProxy.prototype.enableVideo = function(bool)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.enableVideo(bool).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 *主持人演示者选择主视频窗口
 * vMode 锁定/跟踪/演示者锁定
 * terminalID vMode为VMANAGERLOCK有效，锁定视频窗口的成员终端id
 */	
Cr.LHProxy.prototype.setFocusWindow = function(vMode,terminalID)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setFocusWindow(vMode,terminalID).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * @access private
 * 批量订阅视频; 
 * terminalID 受控的终端ID
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.batchSubscribeVideo = function(watchIDs,bSub)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.batchSubscribeVideo(watchIDs,bSub).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * @access private
 * 批量订阅视频; 
 * terminalID 受控的终端ID
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.batchSubscribeVideo2 = function(termID,camID,VIDEO_SS_value)
{
	
	var async = new Cr.AsyncResult();
    // var usrCamSizeList = [new Conference.UsrCamSize(termID.toString(),camID.toString(),VIDEO_SS_value)];
    var usrCamSizeList = [new Conference.UsrCamSize(Number(termID),Number(camID),Number(Conference.VIDEO_SS_1M))];
    var reqContext = new Ice.Context();
        reqContext["_fwd"] = "z";
    console.log("向后台报数据了",usrCamSizeList)
	try
	{
		this._videoCtrl.batchSubscribeVideo2(usrCamSizeList,reqContext).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * @access private
 * 订阅主视频，显示主视频; 
 * bool
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.subscribeFocusWindow = function(bool)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.subscribeFocusWindow(bool).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * @access private
 * 订阅主视频，显示主视频; 
 * terminalID 受控的终端ID
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.subscribeFocusWindow2 = function(num)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.subscribeFocusWindow2(num).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 变更视频布局（主持人，演示者、助理有权限）
 * @access public
 */
Cr.LHProxy.prototype.setVLayout = function(lo)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setVLayout(lo).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 变更主视频显示模式（主持人，演示者、助理有权限）
 * @access public
 */
Cr.LHProxy.prototype.setMainVideoShowMode = function(MVM_value)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setMainVideoShowMode(MVM_value).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 变更视频列表模式
 * @access public
 */
Cr.LHProxy.prototype.setVideoListMode = function(jsonMode)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setVideoListMode(jsonMode).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
/**
 * 拒绝开启视频，termId表示向某人发送这个消息
 * @access public
 */
Cr.LHProxy.prototype.refuseOpenVideo = function(termId)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.refuseOpenVideo(termId).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
/**
 * 取得视频列表
 * @access public
 */
Cr.LHProxy.prototype.getVideoSetting = function(termId)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.getVideoSetting(termId).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
/**
 * 设置摄像头
 * @access public
 */
Cr.LHProxy.prototype.setCamera= function(termId,setting)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setCamera(termId,setting).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
/**
 * 设置默认摄像头
 * @access public
 */
 Cr.LHProxy.prototype.setCameraById= function(cameraId)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setCameraById(cameraId).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
/**
 * 开启关闭视频轮巡
 * @access public
 */
 Cr.LHProxy.prototype.setVideoPolling= function(bStart,interval)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setVideoPolling(bStart,interval).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
/**
 * 更新轮巡的视频列表
 * @access public
 */
  Cr.LHProxy.prototype.updatePollingVideo= function(watchIDs)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.updatePollingVideo(watchIDs).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
/**
 * 更新视频列表
 * @access public
 */
  Cr.LHProxy.prototype.updateVideoList= function(jsonDat)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.updateVideoList(jsonDat).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
/**
 * 是否开启了视频轮巡，轮巡的视频列表
 * @access public
 */
  Cr.LHProxy.prototype.getVideoPollingState= function(watchIDs,interval)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.getVideoPollingState(watchIDs,interval).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
};
//上报摄像头信息
Cr.LHProxy.prototype.updateAllCameraInfos = function(camInfos)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.updateAllCameraInfos(camInfos).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
//设置用户开启的摄像头(默认摄像头放在第1个，后面为所有打开的摄像头camid(包含默认摄像头）其顺序即为显示序号)
Cr.LHProxy.prototype.setOpenedCameraNumber = function(mutiCamIDs)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.setOpenedCameraNumber(mutiCamIDs).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
//设置用户开启的摄像头(默认摄像头放在第1个，后面为所有打开的摄像头camid(包含默认摄像头）其顺序即为显示序号)
Cr.LHProxy.prototype.startAdjustDirection = function(cameraId,ptz_dir)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.startAdjustDirection(cameraId,ptz_dir).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
//变焦
Cr.LHProxy.prototype.startAdjustZoom = function(cameraId,ptz_zoom)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.startAdjustZoom(cameraId,ptz_zoom).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
//变焦
Cr.LHProxy.prototype.stopAdjustDirection = function(cameraId)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.stopAdjustDirection(cameraId).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
//停止变焦
Cr.LHProxy.prototype.stopAdjustDirection = function(cameraId)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._videoCtrl.stopAdjustDirection(cameraId).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}

/********************************************** audio 开始**********************************************/
/**
 * 上报自身的音频设备是否正常
 * @access private
 * @param {obj} bool - false为不正常 true为正常
 */	
Cr.LHProxy.prototype.setAudioDeviceStatus = function(bool)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.setDeviceStatus(bool).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 申请开mic;
 * @access private
 */	
Cr.LHProxy.prototype.askForMic = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.askForMic().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 申请开mic;
 * @access private
 * @param {obj} members - 成员信息
 * @param {number} memberType - 
 * @returns {Cr.AsyncResult} 返回一个异步代理
 */	
Cr.LHProxy.prototype.askForMic = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.askForMic().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * @access private
 * 主持人开启自已、他人麦克风; 
 * terminalID 受控的终端ID
 */	
Cr.LHProxy.prototype.openMicEx = function(terminalID)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.openMicEx(terminalID).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * @access private
 * 关闭自已、或主持人关闭其他人的麦克风; 
 * terminalID 受控的终端ID
 */	
Cr.LHProxy.prototype.closeMicEx = function(id)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.closeMicEx(id).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * @access private
 * 全体静音，主持人、演示者可用
 * @access public
 */
Cr.LHProxy.prototype.closeAll = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.closeAll().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 上报本终端一段时间内语音能量
 * ve语音能量
 * 2秒报一次，暂定
 */	
Cr.LHProxy.prototype.setVoiceEnergy = function(ve)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.setVoiceEnergy(ve).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 切换当前麦状态
 * 关麦变申请
 * 申请变取消申请
 * 开麦变关麦
 */	
Cr.LHProxy.prototype.pstnSwitchMicStatus = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.pstnSwitchMicStatus().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 开始会议录音(每次开始产生一个新的文件)
 * @access public
 */	
Cr.LHProxy.prototype.startRecord = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.startRecord().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 正在会议录音(每次开始产生一个新的文件)
 * @access public
 */	
Cr.LHProxy.prototype.isRecording = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.isRecording().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 停止会议录音
 * @access public
 */	
Cr.LHProxy.prototype.stopRecord = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.stopRecord().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 播放掌声
 * @access public
 */	
Cr.LHProxy.prototype.playApplause = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.playApplause().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
//背景音乐
Cr.LHProxy.prototype.getMusicList = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.getMusicList().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
//""表示没播放的音乐
Cr.LHProxy.prototype.getPlayBGMusic = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.getPlayBGMusic().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
} 
/**
 * 开始播放背景音乐
 * @access public
 */
Cr.LHProxy.prototype.startBGMusic = function(nMusic,volumn)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.startBGMusic(nMusic,volumn).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 停止播放背景音乐
 * @access public
 */
Cr.LHProxy.prototype.stopPlayBGMusic = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.stopPlayBGMusic().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}  
/**
 * 设置播放背景音乐音量 0-100
 * @access public
 */
Cr.LHProxy.prototype.setPlayBGMusicVolumn = function(volumn)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.setPlayBGMusicVolumn(volumn).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 获得音量大小
 * @access public
 */  
Cr.LHProxy.prototype.getPlayBGMusicVolumn = function()
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.getPlayBGMusicVolumn().then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**
 * 获得音量大小
 * @access public
 */ 
Cr.LHProxy.prototype.voiceHowling = function(voiceHowling)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.voiceHowling(voiceHowling).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
Cr.LHProxy.prototype.voiceNoise = function(bNoising)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.voiceNoise(bNoising).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
//远程音频设置
Cr.LHProxy.prototype.remoteAudioSet = function(termID,rAudio)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.remoteAudioSet(termID,rAudio).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
Cr.LHProxy.prototype.getRemoteAudioInf = function(termID)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.getRemoteAudioInf(termID).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}
/**************************************** client_log 开始*************************************************/
Cr.LHProxy.prototype.getRemoteAudioInf = function(termID)
{
	
	var async = new Cr.AsyncResult();
	try
	{
		this._audioCtrl.getRemoteAudioInf(termID).then(function()
		{
			async.complete([CR_NOERR,""])
			
		}.bind(this)).exception(function(ex)
		{

			async.complete([CR_SOCKETEXCEPTION,"网络错误"])
			Cr.Utils.log(ex.toString());
			Cr.Utils.log(ex.stack);
		}.bind(this));
		
	}catch(ex)
	{
		async.complete([CR_INNER_ERR,ex.toString()])
	}
	return async;
}



/**
 * Cr初始化
 * @access public
 * @param {string} type - 使用flash还是js
 * @param {Object} config - 参数
 * @returns {Number} 返回错误码cr/error
 */	
function CR__Init(type,config)
{
	try
	{
		
		Cr._proxy = new Cr.LHProxy(config);
		Cr._proxy.init().then(function(errCode,errDesc)
		{
			Cr._proxy.registeredCallback("receiveIMMsg",function(args)
			{
				CR__ReceiveIMMsg.call(args);
			});
			Cr._proxy.registeredCallback("notifyIMForbidStatus",function(args)
			{
				CR__NotifyIMForbidStatus.call(args);
			});
			Cr._proxy.registeredCallback("notifyClearIMMsg",function()
			{
				CR__NotifyClearIMMsg.call();
			});
			
			
			
			Cr._proxy.registeredCallback("conferenceEnded",function()
			{
				CR__MeetEnded.call();
			});
			Cr._proxy.registeredCallback("entered",function(args)
			{
				CRVideo_UserEnter.call(args);
			});
			Cr._proxy.registeredCallback("left",function(args)
			{
				CR__UserLeftMeet.call(args);
			});
			Cr._proxy.registeredCallback("notifyStartBroadCast",function()
			{
				CR__NotifyStartBroadCast.call();
			});
			
			Cr._proxy.registeredCallback("notifyStopBroadCast",function()
			{
				CR__NotifyStopBroadCast.call();
			});
			
			Cr._proxy.registeredCallback("notifyBroadCastStartPush",function()
			{
				CR__NotifyBroadCastStartPush.call();
			});
			Cr._proxy.registeredCallback("notifyBroadCastStopPush",function()
			{
				CR__NotifyBroadCastStopPush.call();
			});
			Cr._proxy.registeredCallback("rightChanged",function(args)
			{
				CR__RightChanged.call(args);
			});
			Cr._proxy.registeredCallback("askQuesNotify",function(args)
			{
				id = args[0];
				askQue = args[1];
				CR__AskQuesNotify.call([id,new Cr.Quesask(askQue)]);
			});
			Cr._proxy.registeredCallback("lockQuesNotify",function(args)
			{
				id = args[0];
				queDeal = args[1];
				CR__LockQuesNotify.call([id,new Cr.QuesDeal(queDeal)]);
			});
			Cr._proxy.registeredCallback("replyQuesNotify",function(args)
			{
				id = args[0];
				queDeal = args[1];
				CR__ReplyQuesNotify.call([id,new Cr.QuesDeal(queDeal)]);
			});
			Cr._proxy.registeredCallback("modifyQuesNotify",function(args)
			{
				id = args[0];
				queDeal = args[1];
				CR__ModifyQuesNotify.call([id,new Cr.QuesDeal(queDeal)]);
			});
			Cr._proxy.registeredCallback("delQuesNotify",function(args)
			{
				id = args[0];
				termId = args[1];
				CR__DelQuesNotify.call([id,termId]);
			});
			Cr._proxy.registeredCallback("delAllQuesNotify",function(args)
			{
				termId = args[0];
				CR__DelAllQuesNotify.call([termId]);
			});
			Cr._proxy.registeredCallback("publicQuesNotify",function(args)
			{	
				id = args[0];
				bPublic = args[1];
				termId = args[2];
				CR__PublicQuesNotify.call([id,bPublic,termId]);
			});
			Cr._proxy.registeredCallback("quesTypeChangeNotify",function(args)
			{
				id = args[0];
				typeID = args[1];
				CR__QuesTypeChangeNotify.call([termId]);
			});
			Cr._proxy.registeredCallback("modifyQuesTypeNotify",function(args)
			{
				termId = args[0];
				quesType = args[1];
				CR__ModifyQuesTypeNotify.call([termId]);
			});
			Cr._proxy.registeredCallback("setBroadCastQuesNotify",function(args)
			{
				bEnable = args[0];
				CR__SetBroadCastQuesNotify.call([bEnable]);
			});
			Cr._proxy.registeredCallback("notifyPlayBackStartPush",function(args)
			{
				url = args[0];
				CR__NotifyPlayBackStartPush.call([url]);
			});
            Cr._proxy.registeredCallback("notifypayback",function(args)
			{
				CR__Notifypayback.call();
			});
			Cr._proxy.registeredCallback("notifyDeleteIMMsg",function(args)
			{
				count = args[0];
				CR__NotifyDeleteIMMsg.call([count]);
			});
			Cr._proxy.registeredCallback("notifyBroadCastPlaybackStop",function(args)
			{
				url = args[0];
				CR__NotifyBroadCastPlaybackStop.call([url]);
			});
			Cr._proxy.registeredCallback("notifySwtichLiveAppElements",function(args)
			{
				ele = args[0];
				status = args[1];
				CR__NotifySwtichLiveAppElements.call([ele,status]);
			});
			Cr._proxy.registeredCallback("notifyThumbUp",function(args)
			{
				num = args[0];
				total = args[1];
				info = args[2];
				CR__NotifyThumbUp.call([num,total,info]);
			});
			Cr._proxy.registeredCallback("notifyLuckyDrawCfg",function(args)
			{
				CR__NotifyLuckyDrawCfg.call(args);
			});
			Cr._proxy.registeredCallback("notifyLDMembersStatus",function(args)
			{
				CR__NotifyLDMembersStatus.call(args);
			});
			Cr._proxy.registeredCallback("notifyLuckyDrawResult",function(args)
			{
				CR__NotifyLuckyDrawResult.call(args);
			});
			Cr._proxy.registeredCallback("notifySvrRecordStateChanged",function(args)
			{
				CR__NotifySvrRecordStateChanged.call(args);
			});
			Cr._proxy.registeredCallback("notifySvrRecordCfgChanged",function(args)
			{
				CR__NotifySvrRecordCfgChanged.call(args);
			});
			/*******************  MSClient 封装开始 *************************/
			Cr._proxy.registeredCallback("AudioAllocRaw",function(args)
			{
				CR__AudioAllocRaw.call(args);
			});
			Cr._proxy.registeredCallback("ModifyPeerAddr",function(args)
			{
				CR__ModifyPeerAddr.call(args);
			});
			Cr._proxy.registeredCallback("VideoAllocRaw",function(args)
			{
				CR__VideoAllocRaw.call(args);
			});

			Cr._proxy.registeredCallback("AudioAllocRawExt2",function(args)
			{
				CR__AudioAllocRawExt2.call(args);
			});
			Cr._proxy.registeredCallback("VideoAllocRawExt2",function(args)
			{
				CR__VideoAllocRawExt2.call(args);
			});
			Cr._proxy.registeredCallback("ModifyPeerAddrExt",function(args)
			{
				CR__ModifyPeerAddrExt.call(args);
			});
			Cr._proxy.registeredCallback("DisableSendVideo2Internet",function(args)
			{
				CR__DisableSendVideo2Internet.call(args);
			});
			Cr._proxy.registeredCallback("EnableSendVideo2Internet",function(args)
			{
				CR__EnableSendVideo2Internet.call(args);
			});
			Cr._proxy.registeredCallback("Free",function(args)
			{
				CR__Free.call(args);
			});
			/************************* video 接口封装开始 ***********************/
			Cr._proxy.registeredCallback("notifyAllowVideoWall",function(args)
			{
				CR__NotifyAllowVideoWall.call(args);
			});
			Cr._proxy.registeredCallback("VideoUpdateStatus",function(args)
			{
				CR__VideoUpdateStatus.call(args);
			});

			Cr._proxy.registeredCallback("notifyOpenVideo",function(args)
			{
				CR__NotifyOpenVideo.call(args);
			});
			Cr._proxy.registeredCallback("startVideoByManager",function(args)
			{
				CR__StartVideoByManager.call(args);
			});
			Cr._proxy.registeredCallback("notifyEnableVideo",function(args)
			{
				CR__NotifyEnableVideo.call(args);
			});
			Cr._proxy.registeredCallback("updateFocusWindow",function(args)
			{
				CR__UpdateFocusWindow.call(args);
			});
			Cr._proxy.registeredCallback("updateVLayout",function(args)
			{
				CR__UpdateVLayout.call(args);
			});
			Cr._proxy.registeredCallback("updateMainVideoShowMode",function(args)
			{
				CR__UpdateMainVideoShowMode.call(args);
			});
			Cr._proxy.registeredCallback("updateVideoListMode",function(args)
			{
				CR__UpdateVideoListMode.call(args);
			});
			Cr._proxy.registeredCallback("enableUpload",function(args)
			{
				CR__EnableUpload.call(args);
			});
			Cr._proxy.registeredCallback("enableUpload2",function(args)
			{
				CR__EnableUpload2.call(args);
			});
			Cr._proxy.registeredCallback("generateIFrame",function(args)
			{
				CR__GenerateIFrame.call(args);
			});
			Cr._proxy.registeredCallback("notifyRefuseOpenVideo",function(args)
			{
				CR__NotifyRefuseOpenVideo.call(args);
			});
			Cr._proxy.registeredCallback("getVideoSetting",function(args)
			{
				CR__GetVideoSetting.call(args);
			});
			Cr._proxy.registeredCallback("setCamera",function(args)
			{
				CR__SetCamera.call(args);
			});
			Cr._proxy.registeredCallback("setCameraById",function(args)
			{
				CR__SetCameraById.call(args);
			});
			Cr._proxy.registeredCallback("notifyVideoPolling",function(args)
			{
				CR__NotifyVideoPolling.call(args);
			});
			Cr._proxy.registeredCallback("notifyPollingVideo",function(args)
			{
				CR__NotifyPollingVideo.call(args);
			});
			Cr._proxy.registeredCallback("notifyVideoList",function(args)
			{
				CR__NotifyVideoList.call(args);
			});
			Cr._proxy.registeredCallback("notifyUpdateAllCameraInfos",function(args)
			{
				CR__NotifyUpdateAllCameraInfos.call(args);
			});
			Cr._proxy.registeredCallback("notifySetOpenedCameraNumber",function(args)
			{
				termId = args[0];
                carmId = args[1];
				CR__NotifySetOpenedCameraNumber.call([termId,carmId]);
			});
			Cr._proxy.registeredCallback("notifyStartAdjustDirection",function(args)
			{
				CR__NotifyStartAdjustDirection.call(args);
			});
			Cr._proxy.registeredCallback("notifyStartAdjustZoom",function(args)
			{
				CR__NotifyStartAdjustZoom.call(args);
			});
			Cr._proxy.registeredCallback("notifyStopAdjustDirection",function(args)
			{
				CR__NotifyStopAdjustDirection.call(args);
			});
			Cr._proxy.registeredCallback("notifyStopAdjustZoom",function(args)
			{
				CR__NotifyStopAdjustZoom.call(args);
			});

			/************************  audio 方法开始 ************************/
			Cr._proxy.registeredCallback("AudioUpdateStatus",function(args)
			{
				CR__AudioUpdateStatus.call(args);
			});
			Cr._proxy.registeredCallback("updateVoiceEnergy",function(args)
			{
				CR__UpdateVoiceEnergy.call(args);
			});
			Cr._proxy.registeredCallback("updateSpeaker",function(args)
			{
				CR__UpdateSpeaker.call(args);
			});
			Cr._proxy.registeredCallback("closeAll",function(args)
			{
				CR__CloseAll.call(args);
			});
			Cr._proxy.registeredCallback("playBackgroundMusic",function(args)
			{
				CR__PlayBackgroundMusic.call(args);
			});
			Cr._proxy.registeredCallback("notifyVoiceHowling",function(args)
			{
				CR__NotifyVoiceHowling.call(args);
			});
			Cr._proxy.registeredCallback("notifyVoiceNoise",function(args)
			{
				CR__NotifyVoiceNoise.call(args);
			});
			Cr._proxy.registeredCallback("getRemoteAudioInfNotify",function(args)
			{
				CR__GetRemoteAudioInfNotify.call(args);
			});
			Cr._proxy.registeredCallback("remoteAudioSetNotify",function(args)
			{
				CR__RemoteAudioSetNotify.call(args);
			});
			Cr._proxy.registeredCallback("notifyLanLessMicOpen",function(args)
			{
				CR__NotifyLanLessMicOpen.call(args);
			});
			
			CR_InitRslt.call([errCode,errDesc]);
		})
		
	}catch (e) 
	{ 
		Cr.Utils.log(e);
		CR_InitRslt.call([CR_INNER_ERR,"sdk内部错误"]);
	}
}
/**
 * Cr反初始化
 * @access public
 * @returns {Number} 返回错误码cr/error
 */	
function CR__UnInit()
{
	try
	{
		if(Cr.communicator)
			Cr.communicator.shutdown();
		Cr.communicator = null;
		if(Cr._connection)
			Cr._connection.destroy(0);
		Cr._connection = null;
		if(Cr._adapter)
			Cr._adapter.destroy();
		Cr	._adapter = null;
		if(Cr._routerPrx)
			Cr._routerPrx.destroySession();
		Cr._routerPrx = null;
	}catch (e) 
	{ 
		return CR_INNER_ERR
	}
	
}
/**
 * 会议登录
 * @access public
 * @param {string} crmt - crmt串认证
 * @param {string} termId - termid 上次登录的id默认为空
 * @param {object} myDetail - myDetail用户详细信息默认为空
 * @param {string} client_pcid - client_pcid 唯一识别串
 * @param {string} openId - openId 微信的openId
 * @param {string} livetype - livetype 观看类型 用户来源（0：微信用户、1：企业用户、2：其他用户）
 * @param {string} livemobile - livemobile 手机观看时的手机号码
 */	
function CR__Login(value,termId,myDetail,client_pcid,openId)
{
	if(!Cr._proxy._loinging)
	{
		Cr._proxy.login(value,termId,myDetail,client_pcid,openId).then(function(errCode,errDesc,data)
		{
			if(errCode == 0)
			{
				if(Cr._proxy._type == "flash")
				{
					CR_LoginRslt.call([errCode,errDesc,new Cr.MeetInfo(data)]);
				}else
				{
					CR_LoginRslt.call([errCode,errDesc,data]);
				}
			}else
			{
				CR_LoginRslt.call([errCode,errDesc,data]);
			}
			
		})
	}
}
/**
 * 心跳包（登录后每15秒需要执行一次）
 * @access public
 */	
function CR__RefreshSession()
{
	Cr._proxy.refreshSession().then(function(errCode,errDesc)
	{
		CR__RefreshSessionRslt.call([errCode,errDesc]);
	})
}
/**
 * 心跳包（登录后每15秒需要执行一次）
 * @access public
 * @param {number} watch - 否观看直播："0"--没有观看,"1"	--观看中
 */	
function CR__KeepAlive(watch)
{
	if(watch === undefined)
	{
		watch = 0;
	}
	Cr._proxy.keepAlive(watch).then(function(errCode,errDesc)
	{
		CR__KeepAliveRslt.call([errCode,errDesc]);
	})
}
/**
 * 退出结束会议
 * @access public
 * @param {number} watch - 否观看直播："0"--没有观看,"1"	--观看中
 */	
function CR__Exit(reason)
{
	if(reason === undefined)
	{
		reason = "";
	}
	Cr._proxy.exit(reason).then(function(errCode,errDesc)
	{
		CR__ExitRslt.call([errCode,errDesc]);
	})
}
/**
 * 获取在线的人数信息
 * @access public
 * @param {number} watch - 否观看直播："0"--没有观看,"1"	--观看中
 */	
function CR__GetActiveMembers()
{
	Cr._proxy.getActiveMembers().then(function(errCode,errDesc,data)
	{
		if(errCode == 0){
            CR__GetActiveMembersRslt.call([errCode,errDesc,data]);
        }else{
            CR__GetActiveMembersRslt.call([errCode,errDesc]);
        }
	})
}
/**
 * 发送聊天消息
 * @access public
 * @param {number} targetTermId - 聊天对象id
 * @param {string} targetNickname - 聊天对象昵称
 * @param {object} font - 字体
 * @param {string} msg - 消息
 * @param {number} sendTime - 发送时间
 */	
function CR__SnedIMMsg(targetTermId,targetNickname,font,msg,sendTime)
{
	Cr._proxy.snedIMMsg(targetTermId,targetNickname,font,msg,sendTime).then(function(errCode,errDesc)
	{
		CR__SendIMMsgRslt.call([errCode,errDesc]);
	});
}
/**
 * 获取公聊IM消息条数
 * @access private
 */	
function CR__GetIMMsgCount()
{
	Cr._proxy.getIMMsgCount().then(function(errCode,errDesc,count)
	{
		if(errCode == 0)
		{

			CR__GetIMMsgCountRslt.call([errCode,errDesc,count]);
		}else
		{
			CR__GetIMMsgCountRslt.call([errCode,errDesc]);
		}
		
	});
}
/**
 * 获取所有聊天记录
 * @access public
 * @param {number} index - 从index开始获取
 */	
function CR__GetLastMsg(index)
{
	Cr._proxy.getLastMsg(index).then(function(errCode,errDesc,objList)
	{
		if(errCode == 0)
		{
			
			CR__GetLastMsgRslt.call([errCode,errDesc,objList]);
		}else
		{
			CR__GetLastMsgRslt.call([errCode,errDesc]);
		}
		
	});


}
/**
 * 获取指定聊天记录
 * @access public
 * @param {number} index - 从index开始获取
 * @param {number} count - 获取的数量
 */	
function CR__GetLastNMsg(index,count)
{
	Cr._proxy.getLastNMsg(index,count).then(function(errCode,errDesc,objList)
	{
		if(errCode == 0)
		{
			CR__GetLastNMsgRslt.call([errCode,errDesc,objList]);
		}else
		{
			CR__GetLastNMsgRslt.call([errCode,errDesc]);
		}
		
	});
}

/**
 * 获取直播链接
 * @access public
 */	
function CR__GetBroadCastUrl()
{
	Cr._proxy.getBroadCastUrl().then(function(errCode,errDesc,data)
	{
		if(errCode == 0)
		{
			CR__GetBroadCastUrlRslt.call([errCode,errDesc,data]);
		}else
		{
			CR__GetBroadCastUrlRslt.call([errCode,errDesc]);
		}
		
	})
}

/**
 * 提问
 * @access public
 * @param {string} typeID - 问题类型ID
 * @param {number} asktime - 时间
 * @param {short} termID - 提问人ID
 * @param {string} headadurl - 提问人头像
 * @param {string} content - 提问内容      
 * @param {string} nickname - 提问人昵称
 * @access public
 */	
function CR__AskQues(typeID,asktime,termID,headadurl,content,nickname)
{
	Cr._proxy.askQues(typeID,asktime,termID,headadurl,content,nickname).then(function(errCode,errDesc,id)
	{
		if(errCode == 0)
		{
			CR__AskQuesRslt.call([errCode,errDesc,id]);
		}else
		{
			CR__AskQuesRslt.call([errCode,errDesc]);
		}
		
	})
}
/**
 * 获取问题信息列表
 * @access public
 */	
function CR__GetQuesList()
{
	Cr._proxy.getQuesList().then(function(errCode,errDesc,list)
	{
		if(errCode == 0)
		{
			CR__GetQuesListRslt.call([errCode,errDesc,list]);
		}else
		{
			CR__GetQuesListRslt.call([errCode,errDesc]);
		}
		
	})
}
/**
 * 获取抽奖信息
 * @access public
 */	
function CR__GetLuckyDrawCfg()
{
	Cr._proxy.getLuckyDrawCfg().then(function(errCode,errDesc,data)
	{
		if(errCode == 0)
		{
			CR__GetLuckyDrawCfgRslt.call([errCode,errDesc,data]);
		}else
		{
			CR__GetLuckyDrawCfgRslt.call([errCode,errDesc]);
		}
		
	})
}
/**
 * 抽奖报名
 * @access public
 */	
function CR__JoinLuckyDrawMembers(members,memberType)
{
	Cr._proxy.joinLuckyDrawMembers(members,memberType).then(function(errCode,errDesc)
	{
		if(errCode == 0)
		{
			CR__JoinLuckyDrawMembersRslt.call([errCode,errDesc]);
		}else
		{
			CR__JoinLuckyDrawMembersRslt.call([errCode,errDesc]);
		}
	});
}
/**
 * 开始服务器录制, jsonCfg采用json格式
 * @access public
 */	
function CR__StartSvrRecord(jsonCfg)
{

	Cr._proxy.startSvrRecord(jsonCfg).then(function(errCode,errDesc)
	{
		CR__StartSvrRecordRslt.call([errCode,errDesc]);
	});
}
/**
 * 更新录制信息, jsonCfg采用json格式
 * @access public
 */	
function CR__UpdateSvrRecCfg(jsonCfg)
{
	Cr._proxy.updateSvrRecCfg(jsonCfg).then(function(errCode,errDesc)
	{
		
		CR__UpdateSvrRecCfgRslt.call([errCode,errDesc]);
	});
}
/**
 * 停止服务器录制
 * @access public
 */	
function CR__StopSvrRecord()
{
	Cr._proxy.stopSvrRecord().then(function(errCode,errDesc)
	{
		
		CR__StopSvrRecordRslt.call([errCode,errDesc]);
	});
}

/*************************** video 方法的请求处理 开始 ************************/
/**
 * 上报自身的视频设备是否正常
 * @access public
 */	
function CR__SetVideoDeviceStatus(bool)
{
	Cr._proxy.setVideoDeviceStatus(bool).then(function(errCode,errDesc)
	{
		CR__SetVideoDeviceStatusRslt.call([errCode,errDesc]);
	});
}
/**
 * 开启视频墙
 * @access public
 */	
function CR__AllowVideoWall(bool)
{
	Cr._proxy.allowVideoWall(bool).then(function(errCode,errDesc)
	{
		CR__AllowVideoWallRslt.call([errCode,errDesc]);
	});
}
/**
 * 开启自己的视频
 * @access public
 */	
function CR__StartVideo()
{
	Cr._proxy.startVideo().then(function(errCode,errDesc)
	{
		CR__StartVideoRslt.call([errCode,errDesc]);
	});
}
/**
 * 停止自己的视频
 * @access public
 */	
function CR__StopVideo()
{
	Cr._proxy.stopVideo().then(function(errCode,errDesc)
	{
		CR__StopVideoRslt.call([errCode,errDesc]);
	});
}
/**
 * 开启视频墙
 * @access public
 */	
function CR__ReqOpenVideo(terminalID)
{
	Cr._proxy.reqOpenVideo(terminalID).then(function(errCode,errDesc)
	{
		CR__ReqOpenVideoRslt.call([errCode,errDesc]);
	});
}
/**
 * 主持人演示者开启他人视频
 * terminalID 受控的终端ID
 * 异常表示可能因为资源达到最大值失败
 * @access public
 */	
function CR__StartVideoEx(terminalID)
{
	Cr._proxy.startVideoEx(terminalID).then(function(errCode,errDesc)
	{
		CR__StartVideoExRslt.call([errCode,errDesc]);
	});
}
/**
 * 主持人演示者关闭他人视频
 * terminalID 受控的终端ID
 * 异常表示可能因为资源达到最大值失败
 * @access public
 */	
function CR__StopVideoEx(terminalID)
{
	Cr._proxy.stopVideoEx(terminalID).then(function(errCode,errDesc)
	{
		CR__StopVideoExExRslt.call([errCode,errDesc]);
	});
}
/**
 * 开启关闭视频功能
 * @access public
 */	
function CR__EnableVideo(bool)
{
	Cr._proxy.enableVideo(bool).then(function(errCode,errDesc)
	{
		CR__EnableVideoRslt.call([errCode,errDesc]);
	});
}
/**
 *主持人演示者选择主视频窗口
 * vMode 锁定/跟踪/演示者锁定
 * terminalID vMode为VMANAGERLOCK有效，锁定视频窗口的成员终端id
 */	
function CR__SetFocusWindow(vMode,terminalID)
{
	Cr._proxy.setFocusWindow(vMode,terminalID).then(function(errCode,errDesc)
	{
		CR__SetFocusWindowRslt.call([errCode,errDesc]);
	});
}
/**
 * 批量订阅，退订视频
 * @access public
 */	
function CR__BatchSubscribeVideo(watchIDs,bSub)
{
	Cr._proxy.batchSubscribeVideo(watchIDs,bSub).then(function(errCode,errDesc)
	{
		CR__BatchSubscribeVideoRslt.call([errCode,errDesc]);
	});
}
/**
 * 批量订阅，退订视频
 * @access public
 */	
function CR__BatchSubscribeVideo2(termID,camID,VIDEO_SS_value)
{
	Cr._proxy.batchSubscribeVideo2(termID,camID,VIDEO_SS_value).then(function(errCode,errDesc)
	{
		CR__BatchSubscribeVideo2Rslt.call([errCode,errDesc]);
	});
}
/**
 * 设置订阅主视频
 * @access public
 */
function CR__SubscribeFocusWindow(bool)
{
	Cr._proxy.subscribeFocusWindow(bool).then(function(errCode,errDesc)
	{
		CR__SubscribeFocusWindowRslt.call([errCode,errDesc]);
	});
}
/**
 * 设置订阅主视频
 * @access public
 */	
function CR__SubscribeFocusWindow2(num)
{
	Cr._proxy.subscribeFocusWindow2(num).then(function(errCode,errDesc)
	{
		CR__SubscribeFocusWindow2Rslt.call([errCode,errDesc]);
	});
}
/**
 * 变更视频布局（主持人，演示者、助理有权限）
 * @access public
 */
function CR__SetVLayout(lo)
{
	Cr._proxy.setVLayout(lo).then(function(errCode,errDesc)
	{
		CR__SetVLayoutRslt.call([errCode,errDesc]);
	});
}
/**
 * 变更主视频显示模式（主持人，演示者、助理有权限）
 * @access public
 */
function CR__SetMainVideoShowMode(MVM_value)
{
	Cr._proxy.setMainVideoShowMode(MVM_value).then(function(errCode,errDesc)
	{
		CR__SetMainVideoShowModeRslt.call([errCode,errDesc]);
	});
}
/**
 * 变更视频列表模式
 * @access public
 */
function CR__SetVideoListMode(jsonMode)
{
	Cr._proxy.setVideoListMode(jsonMode).then(function(errCode,errDesc)
	{
		CR__SetVideoListModeRslt.call([errCode,errDesc]);
	});
}
/**
 * 拒绝开启视频，termId表示向某人发送这个消息
 * @access public
 */
function CR__RefuseOpenVideo(termId)
{
	Cr._proxy.refuseOpenVideo(termId).then(function(errCode,errDesc)
	{
		CR__RefuseOpenVideoRslt.call([errCode,errDesc]);
	});
}
/**
 * 取得视频列表
 * @access public
 */
function CR__GetVideoSetting(termId)
{
	Cr._proxy.getVideoSetting(termId).then(function(errCode,errDesc)
	{
		CR__GetVideoSettingRslt.call([errCode,errDesc]);
	});
}
/**
 * 设置摄像头
 * @access public
 */
function CR__SetCamera(termId,setting)
{
	Cr._proxy.setCamera(termId,setting).then(function(errCode,errDesc)
	{
		 CR__SetCameraRslt.call([errCode,errDesc]);
	});
}
/**
 * 设置默认摄像头
 * @access public
 */
function CR__SetCameraById(cameraId)
{
	Cr._proxy.setCameraById(cameraId).then(function(errCode,errDesc)
	{
		 CR__SetCameraByIdRslt.call([errCode,errDesc]);
	});
}
/**
 * 开启关闭视频轮巡
 * @access public
 */
function CR__SetVideoPolling(bStart,interval)
{
	Cr._proxy.setVideoPolling(bStart,interval).then(function(errCode,errDesc)
	{
		 CR__SetVideoPollingRslt.call([errCode,errDesc]);
	});
}
/**
 * 更新轮巡的视频列表
 * @access public
 */
function CR__UpdatePollingVideo(watchIDs)
{
	Cr._proxy.updatePollingVideo(watchIDs).then(function(errCode,errDesc)
	{
		 CR__UpdatePollingVideoRslt.call([errCode,errDesc]);
	});
}
/**
 * 更新视频列表
 * @access public
 */
function CR__UpdateVideoList(jsonDat)
{
	Cr._proxy.updateVideoList(jsonDat).then(function(errCode,errDesc)
	{
		 CR__UpdateVideoListRslt.call([errCode,errDesc]);
	});
}
/**
 * 是否开启了视频轮巡，轮巡的视频列表
 * @access public
 */
function CR__GetVideoPollingState(watchIDs,interval)
{
	Cr._proxy.getVideoPollingState(watchIDs,interval).then(function(errCode,errDesc)
	{
		 CR__GetVideoPollingStateRslt.call([errCode,errDesc]);
	});
}
/**
 * 更新用户的摄像头信息
 * camInfos 多个摄像头信息，使用/n区分开
 * @access public
 */	
function CR__UpdateAllCameraInfos(camInfos)
{
	Cr._proxy.updateAllCameraInfos(camInfos).then(function(errCode,errDesc)
	{
		CR__UpdateAllCameraInfosRslt.call([errCode,errDesc]);
	});
}
//设置用户开启的摄像头(默认摄像头放在第1个，后面为所有打开的摄像头camid(包含默认摄像头）其顺序即为显示序号)
function CR__SetOpenedCameraNumber(mutiCamIDs)
{
	Cr._proxy.setOpenedCameraNumber(mutiCamIDs).then(function(errCode,errDesc)
	{
		CR__SetOpenedCameraNumberRslt.call([errCode,errDesc]);
	});
}
//云台控制
//调整方向
function CR__StartAdjustDirection(cameraId,ptz_dir)
{
	Cr._proxy.startAdjustDirection(cameraId,ptz_dir).then(function(errCode,errDesc)
	{
		CR__StartAdjustDirectionRslt.call([errCode,errDesc]);
	});
}
//变焦
function CR__StartAdjustZoom(cameraId,ptz_zoom)
{
	Cr._proxy.startAdjustZoom(cameraId,ptz_zoom).then(function(errCode,errDesc)
	{
		CR__StartAdjustZoomRslt.call([errCode,errDesc]);
	});
}
//停止调整方向
function CR__StopAdjustDirection(cameraId)
{
	Cr._proxy.stopAdjustDirection(cameraId).then(function(errCode,errDesc)
	{
		CR__StopAdjustDirectionRslt.call([errCode,errDesc]);
	});
}
//停止变焦
function CR__StopAdjustZoom(cameraId)
{
	Cr._proxy.stopAdjustZoom(cameraId).then(function(errCode,errDesc)
	{
		CR__StopAdjustZoomRslt.call([errCode,errDesc]);
	});
}
/*************************** audio接口封装开始 ********************************/
/**
 * 上报自身的音频设备是否正常
 * @access public
 */	
function CR__SetAudioDeviceStatus(bool)
{
	Cr._proxy.setAudioDeviceStatus(bool).then(function(errCode,errDesc)
	{
		CR__SetAudioDeviceStatusRslt.call([errCode,errDesc]);
	});
}
/**
 * 申请开mic;
 * @access public
 */	
function CR__AskForMic()
{
	Cr._proxy.askForMic().then(function(errCode,errDesc)
	{
		CR__AskForMicRslt.call([errCode,errDesc]);
	});
}
/**
 * 主持人开启自已、他人麦克风; 
 * terminalID 受控的终端ID
 * @access public
 */	
function CR__OpenMicEx(id)
{
	Cr._proxy.openMicEx(id).then(function(errCode,errDesc)
	{
		CR__OpenMicExRslt.call([errCode,errDesc]);
	});
}
/**
 * 关闭自已、或主持人关闭其他人的麦克风; 
 * terminalID 受控的终端ID
 */	
function CR__CloseMicEx(id)
{
	Cr._proxy.closeMicEx(id).then(function(errCode,errDesc)
	{
		CR__CloseMicExRslt.call([errCode,errDesc]);
	});
}
/**
 * 全体静音，主持人、演示者可用
 * @access public
 */	
function CR__CloseAll()
{
	Cr._proxy.closeAll().then(function(errCode,errDesc)
	{
		CR__CloseAllRslt.call([errCode,errDesc]);
	});
}
/**
 * 上报本终端一段时间内语音能量
 * ve语音能量
 * 2秒报一次，暂定
 */	
function CR__SetVoiceEnergy(ve)
{
	Cr._proxy.setVoiceEnergy(ve).then(function(errCode,errDesc)
	{
		CR__SetVoiceEnergyRslt.call([errCode,errDesc]);
	});
}
/**
 * 切换当前麦状态
 * 关麦变申请
 * 申请变取消申请
 * 开麦变关麦
 */	
function CR__PstnSwitchMicStatus()
{
	Cr._proxy.pstnSwitchMicStatus().then(function(errCode,errDesc)
	{
		CR__PstnSwitchMicStatusRslt.call([errCode,errDesc]);
	});
}
/**
 * 开始会议录音(每次开始产生一个新的文件)
 * @access public
 */	
function CR__StartRecord()
{
	Cr._proxy.startRecord().then(function(errCode,errDesc)
	{
		CR__StartRecordRslt.call([errCode,errDesc]);
	});
}
/**
 * 正在会议录音(每次开始产生一个新的文件)
 * @access public
 */	
function CR__IsRecording()
{
	Cr._proxy.isRecording().then(function(errCode,errDesc)
	{
		CR__IsRecordingRslt.call([errCode,errDesc]);
	});
}
/**
 * 停止会议录音
 * @access public
 */	
function CR__StopRecord()
{
	Cr._proxy.isRecording().then(function(errCode,errDesc)
	{
		CR__StopRecordRslt.call([errCode,errDesc]);
	});
}
/**
 * 播放掌声
 * @access public
 */	
function CR__PlayApplause()
{
	Cr._proxy.playApplause().then(function(errCode,errDesc)
	{
		CR__PlayApplauseRslt.call([errCode,errDesc]);
	});
}
/**
 * 背景音乐
 * @access public
 */
function CR__GetMusicList()
{
	Cr._proxy.getMusicList().then(function(errCode,errDesc)
	{
		CR__GetMusicListRslt.call([errCode,errDesc]);
	});
}
/**
 * ""表示没播放的音乐
 * @access public
 */
function CR__GetPlayBGMusic()
{
	Cr._proxy.getPlayBGMusic().then(function(errCode,errDesc)
	{
		CR__GetPlayBGMusicRslt.call([errCode,errDesc]);
	});
}
/**
 * 开始播放背景音乐
 * @access public
 */
function CR__StartBGMusic(nMusic,volumn)
{
	Cr._proxy.startBGMusic(nMusic,volumn).then(function(errCode,errDesc)
	{
		CR__StartBGMusicRslt.call([errCode,errDesc]);
	});
}
/**
 * 停止播放背景音乐
 * @access public
 */
function CR__StopPlayBGMusic()
{
	Cr._proxy.stopPlayBGMusic().then(function(errCode,errDesc)
	{
		CR__StopPlayBGMusicRslt.call([errCode,errDesc]);
	});
}
/**
 * 设置播放背景音乐音量 volumn 0-100
 * @access public
 */
function CR__SetPlayBGMusicVolumn(volumn)
{
	Cr._proxy.setPlayBGMusicVolumn(volumn).then(function(errCode,errDesc)
	{
		CR__SetPlayBGMusicVolumnRslt.call([errCode,errDesc]);
	});
}
/**
 * 获得音量大小
 * @access public
 */
function CR__GetPlayBGMusicVolumn()
{
	Cr._proxy.getPlayBGMusicVolumn().then(function(errCode,errDesc)
	{
		CR__GetPlayBGMusicVolumnRslt.call([errCode,errDesc]);
	});
}
/**
 * 
 * @access public
 */
function CR__VoiceHowling(bool)
{
	Cr._proxy.voiceHowling(bool).then(function(errCode,errDesc)
	{
		CR__VoiceHowlingRslt.call([errCode,errDesc]);
	});
}
/**
 * 
 * @access public
 */
function CR__VoiceNoise(bool)
{
	Cr._proxy.voiceNoise(bool).then(function(errCode,errDesc)
	{
		CR__VoiceNoiseRslt.call([errCode,errDesc]);
	});
}
/**
 * 远程音频设置
 * @access public
 */
function CR__RemoteAudioSet(termID,rAudio)
{
	Cr._proxy.remoteAudioSet(termID,rAudio).then(function(errCode,errDesc)
	{
		CR__RemoteAudioSetRslt.call([errCode,errDesc]);
	});
}
/**
 * 
 * @access public
 */
function CR__GetRemoteAudioInf(termID)
{
	Cr._proxy.getRemoteAudioInf(termID).then(function(errCode,errDesc)
	{
		CR__GetRemoteAudioInfRslt.call([errCode,errDesc]);
	});
}









var CRVideo = function () 
{
	var win = window,
		doc = document,
		nav = navigator,

		w3cdom = typeof doc.getElementById !== "undefined" && typeof doc.getElementsByTagName !== "undefined" && typeof doc.createElement !== "undefined",
		u = nav.userAgent.toLowerCase(),
		p = nav.platform.toLowerCase(),
		windows = p ? /win/.test(p) : /win/.test(u),
		mac = p ? /mac/.test(p) : /mac/.test(u),
		webkit = /webkit/.test(u) ? parseFloat(u.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false, // returns either the webkit version or false if not webkit
		ff =u.indexOf("firefox")>-1?true:false;//是否是火狐
		ie = nav.appName === "Microsoft Internet Explorer";

		var agent = navigator.userAgent.toLowerCase();
		var regStr_ie = /msie ([\d.])+/gi;
		if(ie)
		{
				var vArrStr = agent.match(regStr_ie)[0];
				var v = vArrStr.split(' ')[1]
		}
	return {"w3": w3cdom, "wk": webkit, "ie": ie,"ff":ff, "win": windows, "mac": mac,"v":v};
}()
CRVideo.addEventListener = function(target,name,fun)
{
	if (target.addEventListener) {                    //所有主流浏览器，除了 IE 8 及更早 IE版本
	    target.addEventListener(name, fun);
	} else if (target.attachEvent) {                  // IE 8 及更早 IE 版本
	    target.attachEvent("on"+name, fun);
	};
}
CRVideo.ic = null;
CRVideo.callserverName =null;
CRVideo.proxy = null;
CRVideo.logproxy = null;
CRVideo.queInfo = null;
CRVideo.queuingID = null;
CRVideo.Server = null;
CRVideo.sessionID=null;
CRVideo.cookie="";
CRVideo.MeetInfoObj =null;
CRVideo.CallID ="";
CRVideo.HandErrTimes =0;
CRVideo.LoginFlag =0;
CRVideo.meetSubject ="test";
CRVideo.queStatusInfo =[];   //对象字段 {"queID": 96, "agent_num": 1, "srv_num": 1, "wait_num": 0, "prepare_num": 0}
CRVideo.queServiceInfo = "demo-queID"
CRVideo.IceAddr =null;
CRVideo.inviteID ="";
CRVideo.protocol = document.location.protocol;
CRVideo.logServer = null ; //日志服务器地址
CRVideo.logUUID = ""; //日志保存的uuid

 
CRVideo_initIce = function(server ,port){
	this._initData = new Ice.InitializationData();
   	this._initData.properties = Ice.createProperties();
   	this._initData.properties.setProperty("Ice.Trace.Network", "0");
  	this._initData.properties.setProperty("Ice.Trace.Protocol", "0");
    this._initData.properties.setProperty("Ice.ACM.Client", "0");
	this._initData.properties.setProperty("Ice.ACM.Server", "0");
 
   	this._initData.properties.setProperty("Ice.Default.EncodingVersion", "1.0");
   	CRVideo.ic = Ice.initialize(this._initData);
	var jsserver = "jserver:wss -h "+ server + " -p " +port ;
	CRVideo.proxy = CRVideo.ic.stringToProxy(jsserver);
	console.log(jsserver)
};
CRVideo.CbProxy = function(name)
{
	this.name = name;
	this.callback = null;
}
var CRVideo_QueueStatusChanged = new CRVideo.CbProxy("CRVideo_QueueStatusChanged");	
var CRVideo_QueuingInfoChanged = new CRVideo.CbProxy("CRVideo_QueuingInfoChanged");
var CRVideo_AutoAssignUser = new CRVideo.CbProxy("CRVideo_AutoAssignUser");
var CRVideo_CancelAssignUser = new CRVideo.CbProxy("CRVideo_CancelAssignUser");
var CRVideo_NotifyCallIn = new CRVideo.CbProxy("CRVideo_NotifyCallIn");
var CRVideo_NotifyCallAccepted = new CRVideo.CbProxy("CRVideo_NotifyCallAccepted");
var CRVideo_NotifyUserStatus = new CRVideo.CbProxy("CRVideo_NotifyUserStatus"); 
var CRVideo_LineOff = new CRVideo.CbProxy("CRVideo_LineOff");
var CRVideo_LoginSuccess = new CRVideo.CbProxy("CRVideo_LoginSuccess");
var CRVideo_LoginFail = new CRVideo.CbProxy("CRVideo_LoginFail");
var CRVideo_ShakeHandRslt = new CRVideo.CbProxy("CRVideo_ShakeHandRslt");
var CRVideo_SetDNDStatusSuccess = new CRVideo.CbProxy("CRVideo_SetDNDStatusSuccess"); 
var CRVideo_SetDNDStatusFail = new CRVideo.CbProxy("CRVideo_SetDNDStatusFail"); 
var CRVideo_StartUserStatusNotifyRslt = new CRVideo.CbProxy("CRVideo_StartUserStatusNotifyRslt"); 
var CRVideo_StopUserStatusNotifyRslt = new CRVideo.CbProxy("CRVideo_StopUserStatusNotifyRslt"); 
var CRVideo_GetUserStatusSuccess = new CRVideo.CbProxy("CRVideo_GetUserStatusSuccess"); 
var CRVideo_GetUserStatusFail = new CRVideo.CbProxy("CRVideo_GetUserStatusFail"); 
var CRVideo_CallSuccess = new CRVideo.CbProxy("CRVideo_CallSuccess"); 
var CRVideo_CallFail = new CRVideo.CbProxy("CRVideo_CallFail"); 
var CRVideo_InitQueueDatRslt = new CRVideo.CbProxy("CRVideo_InitQueueDatRslt");
var CRVideo_GetQueueStatusRslt = new CRVideo.CbProxy("CRVideo_GetQueueStatusRslt");
var CRVideo_StartQueuingRslt = new CRVideo.CbProxy("CRVideo_StartQueuingRslt");
var CRVideo_StartServiceRslt = new CRVideo.CbProxy("CRVideo_StartServiceRslt");
var CRVideo_StopServiceRslt = new CRVideo.CbProxy("CRVideo_StopServiceRslt");
var CRVideo_ReqAssignUserRslt = new CRVideo.CbProxy("CRVideo_ReqAssignUserRslt");
var CRVideo_NotifyCallHungup = new CRVideo.CbProxy("CRVideo_NotifyCallHungup"); 
var CRVideo_NotifyCallRejected = new CRVideo.CbProxy("CRVideo_NotifyCallRejected");
var CRVideo_AcceptCallSuccess = new CRVideo.CbProxy("CRVideo_AcceptCallSuccess"); 
var CRVideo_AcceptCallFail = new CRVideo.CbProxy("CRVideo_AcceptCallFail"); 
var CRVideo_GetCallServerInfoFail= new CRVideo.CbProxy("CRVideo_GetCallServerInfoFail");
var CRVideo_GetCallServerInfoSuccess = new CRVideo.CbProxy("CRVideo_GetCallServerInfoSuccess");
var CRVideo_VideoStatusChanged = new CRVideo.CbProxy("CRVideo_VideoStatusChanged");
var CRVideo_DefVideoChanged = new CRVideo.CbProxy("CRVideo_DefVideoChanged");
var CRVideo_VideoDevChanged = new CRVideo.CbProxy("CRVideo_VideoDevChanged");
var CRVideo_EnterMeetingRslt = new CRVideo.CbProxy("CRVideo_EnterMeetingRslt");
var CRVideo_HangupCallSuccess = new CRVideo.CbProxy("CRVideo_HangupCallSuccess");
var CRVideo_HangupCallFail = new CRVideo.CbProxy("CRVideo_HangupCallFail");
var CRVideo_MeetingDropped = new CRVideo.CbProxy("CRVideo_MeetingDropped");
var CRVideo_NotifyCmdData = new CRVideo.CbProxy("CRVideo_NotifyCmdData");
var CRVideo_StopQueuingRslt = new CRVideo.CbProxy("CRVideo_StopQueuingRslt");

var CRVideo_CreateMeetingSuccess = new CRVideo.CbProxy("CRVideo_CreateMeetingSuccess");
var CRVideo_CreateMeetingFail = new CRVideo.CbProxy("CRVideo_CreateMeetingFail");
var CRVideo_CallMorePartyRslt = new CRVideo.CbProxy("CRVideo_CallMorePartyRslt");
var CRVideo_CancelCallMorePartyRslt = new CRVideo.CbProxy("CRVideo_CancelCallMorePartyRslt");
var CRVideo_NotifyCallMorePartyStatus = new CRVideo.CbProxy("CRVideo_NotifyCallMorePartyStatus");
var CRVideo_UserLeftMeeting = new CRVideo.CbProxy("CRVideo_UserLeftMeeting");
var CRVideo_UserEnterMeeting  = new CRVideo.CbProxy("CRVideo_UserEnterMeeting");




var CRVideo_sendCmdNameFunc = {
	NotifyQueueStatus: function(backJson){
		CRVideo_QueueStatusChanged.callback(backJson.status);
	},
	NotifyPosition: function(backJson){
		CRVideo_QueueStatusChanged.callback(backJson.status);
		CRVideo_QueuingInfoChanged.callback(backJson);
	},
	AssignUser: function(backJson){
		 CRVideo_AutoAssignUser.callback(backJson);
		 console.log("CRVideo_AutoAssignUser："+backJson)
		 CRVideo.remoteinfo["nickname"] = backJson.userName;
		 CRVideo.remoteinfo["userID"] = backJson.userID;
	},
	AssignCancel: function(backJson){
		CRVideo_CancelAssignUser.callback(backJson.queID,backJson.userID);
	},
	ServerAccept: function(backJson){
		CRVideo_NotifyCallAccepted.callback(backJson.callID,backJson.meeting,"");
	},
	ServerCall: function(backJson){
		CRVideo_NotifyCallIn.callback(backJson.callID,backJson.meeting,backJson.caller,backJson.usrExDat);
		console.log("CRVideo_AutoAssignUser："+backJson)
		CRVideo.remoteinfo["nickname"] = backJson.callerName;
		CRVideo.remoteinfo["userID"] = backJson.caller;
	},
	ServerPushUserStatus: function(backJson){
		CRVideo_NotifyUserStatus.callback(backJson.usersStatus,"");
	},
	ServerDecline: function(backJson){
		CRVideo_NotifyCallRejected.callback(backJson.callID,"","");
	},
	ServerKickoutUser: function(backJson){
		CRVideo_LineOff.callback(backJson);
	},
	ServerReleaseCall : function(backJson){
		console.log("ServerReleaseCall："+backJson);
		CRVideo_NotifyCallHungup.callback(CRVideo.CallID)
		CRVideo.CallID ="";
	},
	ServerCancelCall : function(backJson){
		console.log("ServerReleaseCall："+backJson)
	},
	ServerNotifyInvite: function(backJson){
		CRVideo_NotifyCallMorePartyStatus.callback(backJson.inviteID,backJson.callProgress); 
	} 
}
var CRVideo_webSendCmdNameFunc = {
	 
	Login: function(json,jsonName){
		if(json.RspCode == 0){
			CRVideo.LoginFlag =1;
			CRVideo_LoginSuccess.callback(json.sessionID,"");
			setInterval(function()
			{
				CRVideo_ShakeHand();
				//CRVideo_SendBufferTest();
			},30000);
		}
		else {
			CRVideo_LoginFail.callback(json.RspDesc,"");
		}
	},
	ShakeHand: function(json,jsonName){
		if(json.RspCode == 0){
			CRVideo_ShakeHandRslt.callback(json);
		}
	},
	GetServiceData: function(json,jsonName){
		if(json.RspCode == 0){
		  CRVideo.queInfo = eval(json.ques)  ; 
	    };
	  	CRVideo_InitQueueDatRslt.callback(json.RspCode,"");
	},
	GetQueueStatus: function(json,jsonName){
		if(json.RspCode == 0){
		    var  length = CRVideo.queStatusInfo.length;
			var  hasque = false ;
			var obj =eval(json.status) ;
            for(var i=0;i< CRVideo.queStatusInfo.length;i++){
                 var quetmp=CRVideo.queStatusInfo[i];
                 if (quetmp.queID==obj.queID) {
					 CRVideo.queStatusInfo[i]=obj;
					 hasque =true;
					 continue;
				 }
            }										
			if  (!hasque) {
			   CRVideo.queStatusInfo.push(obj);	
			} 
	    };
	  	CRVideo_GetQueueStatusRslt.callback(json.status);
	},
	UserEnter: function(json,jsonName){
		CRVideo_StartQueuingRslt.callback(json ,json.RspCode,"");
	},
	UserLeave: function(json,jsonName){
		CRVideo_StopQueuingRslt.CallBack(json);
	},
	AgentEnter: function(json,jsonName){
		if(json.RspCode == 0){
		  CRVideo.queServiceInfo  =CRVideo.queServiceInfo+","+jsonName.queID+"-queID" ;
		  console.log("queServiceInfo =" +CRVideo.queServiceInfo);
	    }
	  	CRVideo_StartServiceRslt.callback(jsonName.queID,json.RspCode,"");
	},
	AgentLeave: function(json,jsonName){
		if(json.RspCode == 0){
		  var item = ","+jsonName.queID+"-queID" ;
		  CRVideo.queServiceInfo =CRVideo.queServiceInfo.replace(item,"");
	    }
	  	CRVideo_StopServiceRslt.callback(jsonName.queID,json.RspCode,"");
	},
	StartStatusPush: function(json,jsonName){
		CRVideo_StartUserStatusNotifyRslt.callback(json.RspCode,"");
	},
	StopStatusPush: function(json,jsonName){
		CRVideo_StopUserStatusNotifyRslt.callback(json.RspCode,"");
	},
	GetUserStatus: function(json,jsonName){
		if(json.RspCode == 0){						  
			CRVideo_GetUserStatusSuccess.callback(json.userStatus,"");
		}
		else {
			 CRVideo_GetUserStatusFail.callback(json.RspCode,"");
		}
	},
	ClientCustomStatusUpdate: function(json,jsonName){
		if(json.RspCode == 0){
			CRVideo_SetDNDStatusSuccess.callback(json);
		}
		else {
			CRVideo_SetDNDStatusFail.callback(json);
		}
	},
	RequestUser: function(json,jsonName){
		CRVideo_ReqAssignUserRslt.callback(json.RspCode,json,"");
	},
	AcceptCall : function(json,jsonName){
		console.log(json)
		if(json.RspCode == 0){
			CRVideo_AcceptCallSuccess.callback(json.RspCode,jsonName,"");
		}else{
			CRVideo_AcceptCallFail.callback(json.RspCode,json,"");
		}
	},
	ClientCall : function(json,jsonName){
		console.log(json)
		if(json.RspCode == 0){
			CRVideo_CallSuccess.callback(jsonName.callID,"");
		}else{
			CRVideo_CallFail.callback(json.RspCode,json.RspCode,"");
		}
	},
	ClientCancelInvite : function(json,jsonName){
		 CRVideo_CancelCallMorePartyRslt.callback(jsonName.inviteID,json.RspCode,"")
		 
	},
	ClientReleaseCall: function(json,jsonName){
		if(json.RspCode == 0){
			CRVideo_HangupCallSuccess.callback(json.callID,"");
		}else{
			CRVideo_HangupCallFail.callback(json.RspCode,json.RspCode,"");
		}
		 
	},
}; 
var CRVideo_SetServerAddr = function(server){
	CRVideo.callserverName = server;
};
var CRVideo_sendCmdName = {
	"NotifyQueueStatus": CRVideo_sendCmdNameFunc.NotifyQueueStatus,
	"NotifyPosition": CRVideo_sendCmdNameFunc.NotifyPosition,
	"AssignUser": CRVideo_sendCmdNameFunc.AssignUser,
	"AssignCancel": CRVideo_sendCmdNameFunc.AssignCancel,
	"ServerAccept": CRVideo_sendCmdNameFunc.ServerAccept,
	"ServerCall": CRVideo_sendCmdNameFunc.ServerCall,
	"ServerPushUserStatus": CRVideo_sendCmdNameFunc.ServerPushUserStatus,
	"ServerDecline": CRVideo_sendCmdNameFunc.ServerDecline,
	"ServerKickoutUser": CRVideo_sendCmdNameFunc.ServerKickoutUser,
	"ServerReleaseCall" : CRVideo_sendCmdNameFunc.ServerReleaseCall,
	"ServerCancelCall" : CRVideo_sendCmdNameFunc.ServerCancelCall,
	 
	"ServerNotifyInvite" : CRVideo_sendCmdNameFunc.ServerNotifyInvite
};
var CRVideo_webSendCmdName = {
	"Login": CRVideo_webSendCmdNameFunc.Login,
	"ShakeHand": CRVideo_webSendCmdNameFunc.ShakeHand,
	"GetServiceData": CRVideo_webSendCmdNameFunc.GetServiceData,
	"GetQueueStatus": CRVideo_webSendCmdNameFunc.GetQueueStatus,
	"UserEnter": CRVideo_webSendCmdNameFunc.UserEnter,
	"UserLeave": CRVideo_webSendCmdNameFunc.UserLeave,
	"AgentEnter": CRVideo_webSendCmdNameFunc.AgentEnter,  
	"AgentLeave": CRVideo_webSendCmdNameFunc.AgentLeave,  
	"StartStatusPush": CRVideo_webSendCmdNameFunc.StartStatusPush,
	"StopStatusPush": CRVideo_webSendCmdNameFunc.StopStatusPush,
	"GetUserStatus": CRVideo_webSendCmdNameFunc.GetUserStatus,
	"ClientCustomStatusUpdate": CRVideo_webSendCmdNameFunc.ClientCustomStatusUpdate,
	"RequestUser": CRVideo_webSendCmdNameFunc.RequestUser,
	"AcceptCall" : CRVideo_webSendCmdNameFunc.AcceptCall,
	"ClientCall" : CRVideo_webSendCmdNameFunc.ClientCall,
	"clientInvite" : CRVideo_webSendCmdNameFunc.clientInvite,
	"ClientCancelInvite" : CRVideo_webSendCmdNameFunc.ClientCancelInvite,
	"ClientReleaseCall" : CRVideo_webSendCmdNameFunc.ClientReleaseCall
};

CRVideo_GetAllQueueInfo = function(){
	          return CRVideo.queInfo;
}	
		  
var CmdI = Ice.Class(SendCmd.Cmd,{ 
      sendCmd: function(para ,current)
    	{

		 var backJson = JSON.parse(para);
		  console.log("received callback #" + para); 
		 var backcmdName = backJson.cmd;
		 var backModule = backJson.module;
		if(backcmdName != undefined){
			console.log(backcmdName)
			CRVideo_sendCmdName[backcmdName](backJson);
		}
    },sendBuffer: function(para ,data ,current)
    	{

		 
		  console.log("sendBuffer  received callback #" + para); 
		 
    }  
});
var LoggerI = Ice.Class(LogSpace.ClientLogServer,{
     log: function(param){
     	console.log(param)
    },logFatal: function(param){
		 console.log(param);
    },usrReport:function(param){
    	 console.log(param);
    },logDetail:function(param){
    	 console.log(param);
    }
});
//var this._clientLogServer = LogSpace.ClientLogServerPrx.uncheckedCast(loginResponse.modules.get("ClientLogServer"));

CRVideo_SetAdapter = function(){
	Ice.Promise.try2(
	    function()
	    {
          
		   CRVideo.Server= SendCmd.CmdPrx.checkedCast(CRVideo.proxy).then(
	            function(server)
	            {
	               
	                CRVideo.ic.createObjectAdapter("").then(
	                    function(adapter)
	                    {
                             
							var r= adapter.add(new CmdI(), Ice.stringToIdentity('jclient'));
						 
							console.log("adapter = " + r.ice_getIdentity().category + r.ice_getIdentity().name );
						 
	                        CRVideo.proxy.ice_getCachedConnection().setAdapter(adapter);
							console.log("adapter getName = " + adapter.getName() );
	                        console.log("SendCmd finidhed " );
							 
	                    });
	            });
	    }
	).exception(
	    function(ex)
	    {
	        console.log(ex.toString());
	        Ice.Promise.try2(
	            function()
	            {
	                if(CRVideo.ic)
	                {
	                    CRVideo.ic.destroy();
	                }
	            }
	        ).finally(
	            function()
	            {
	                process.exit(1);
	            });
	    });
}
CRVideo_LoggerAdapter = function(){
	Ice.Promise.try2(
	    function()
	    {

		   CRVideo.ServerLogger= LogSpace.ClientLogServerPrx.checkedCast(CRVideo.logproxy).then(
	            function(server)
	            {

	                CRVideo.ic.createObjectAdapter("").then(
	                    function(adapter)
	                    {

							var r= adapter.add(new LoggerI(), Ice.stringToIdentity('jclient'));

							console.log("adapter = " + r.ice_getIdentity().category + r.ice_getIdentity().name );

	                        CRVideo.logproxy.ice_getCachedConnection().setAdapter(adapter);
							console.log("adapter getName = " + adapter.getName() );
	                        console.log("ClientLogServerPrx finidhed " );

	                    });
	            });
	    }
	).exception(
	    function(ex)
	    {
	        console.log(ex.toString());
	        Ice.Promise.try2(
	            function()
	            {
	                if(CRVideo.ic)
	                {
	                    CRVideo.ic.destroy();
	                }
	            }
	        ).finally(
	            function()
	            {
	                process.exit(1);
	            });
	    });
}
CRVideo_SendBufferTest = function(){
	//var blob = new Blob(["ddd"],{type:"text/plain"});  
	
	var json = {
                 cmd:"SendCMD",
                 module:"CallServer", 
                 sessionID: CRVideo.sessionID,
				 sourceUserId:"qq",
				 targetUserId:"dd" 
                };
	var s ="d"	;							 
	var result = [];
    for(var i = 0; i < s.length; i+=2)
    {
      result.push(parseInt(s.substring(i, i + 2), 16));
    }
     result = Uint8Array.from(result)
 
    CRVideo.webSendBuffer(json,result);
	console.log("CRVideo_SendBuffer finished"+JSON.stringify(json) );
	 
}


CRVideo_SendBuffer = function(json,data){
	//var blob = new Blob(["ddd"],{type:"text/plain"});  
	
	 
	var result = [];
    for(var i = 0; i < data.length; i+=2)
    {
      result.push(parseInt(data.substring(i, i + 2), 16));
    }
    result = Uint8Array.from(result)
 
    CRVideo.webSendBuffer(json,result);
	console.log("CRVideo_SendBuffer finished"+JSON.stringify(json) );
	 
}

CRVideo.webSendBuffer = function(jsonName,data){
	Ice.Promise.try2(
	    function()
	    {
	        SendCmd.CmdPrx.checkedCast(CRVideo.proxy).then(
	            function(server)
	            {
	              
					 server.sendBuffer(JSON.stringify(jsonName),data).then(function(jsons)
						{
							var sendcmdName = jsonName.cmd;
							console.log("webSendBuffer result" +jsons);
						 
					}).exception(function(ex){
                        console.log('ex = ' +ex);
                       console.log('reason = ' +ex.reason);
                    });
				 
					 
	        });      
	    }
	).exception(
	    function(ex)
	    {
	        console.log(ex.toString());
	        Ice.Promise.try(
	            function()
	            {
	                if(CRVideo.ic)
	                {
	                    CRVideo.ic.destroy();
	                }
	            }
	        ).finally(
	            function()
	            {
	                process.exit(1);
	            });
	    });
};


 CRVideo.webSendcmd = function(jsonName){
	Ice.Promise.try2(
	    function()
	    {
	        SendCmd.CmdPrx.checkedCast(CRVideo.proxy).then(
	            function(server)
	            {
	                server.sendCmd(JSON.stringify(jsonName)).then(function(jsons)
						{
							var sendcmdName = jsonName.cmd;
							//console.log(sendcmdName);
							var sendModule = jsonName.module;
							var json = JSON.parse(jsons);
							CRVideo_webSendCmdName[sendcmdName](json,jsonName);		
					}); 
	        });      
	    }
	).exception(
	    function(ex)
	    {
	        console.log(ex.toString());
	        Ice.Promise.try(
	            function()
	            {
	                if(CRVideo.ic)
	                {
	                    CRVideo.ic.destroy();
	                }
	            }
	        ).finally(
	            function()
	            {
	                process.exit(1);
	            });
	    });
};
//详细日志上报
CRVideo.webLogDetail = function(confId,filename,content){
	Ice.Promise.try2(
	    function()
	    {
	        LogSpace.ClientLogServerPrx.checkedCast(CRVideo.logproxy).then(
	            function(server)
	            {
	                server.logDetail(confId,filename,content).then(function(jsons)
						{
							console.log('上传日志成功');
					}); 
	        });      
	    }
	).exception(
	    function(ex)
	    {
	        console.log(ex.toString());
	        Ice.Promise.try(function(){if(CRVideo.ic){CRVideo.ic.destroy();}}).finally(function(){process.exit(1);});
	    });
};
CRVideo_Login = function(account,psw,nick_name,user_id,cookie){
	   
	CRVideo.LoginParam = {
		"account" : account,
		"psw" : psw,
		"nick_name" : nick_name,
		"user_id" : user_id,
		"cookie" :cookie
	}
	CRVideo_GetCallServerInfo(CRVideo.callserverName,account,psw);
  	console.log("CRVideo.Login begin" );
} 
 
	
 
CRVideo_InitQueueDat = function(){
	  console.log("CRVideo.InitQueueDat begin" );
	  var initQueueJson = {
                     cmd:"GetServiceData",
                     module:"Queue",
                     sessionID: CRVideo.sessionID
                    };
					
		 
		CRVideo.webSendcmd(initQueueJson);
		console.log("initQueueJson =  " +JSON.stringify(initQueueJson) );
		console.log("CRVideo.InitQueueDat finished" );
 
	
}

 CRVideo_GetQueueStatus = function(queID){
	        //console.log("GetQueueStatus begin" );
	         var GetQueueStatus = {
                                 cmd:"GetQueueStatus",
                                 module:"Queue",
								 queID: queID,
                                 sessionID:CRVideo.sessionID
                        };
			 //console.log("GetQueueStatus.queID=" +queID);
						
			 CRVideo.webSendcmd(GetQueueStatus);
	       // console.log("GetQueueStatus finished" );
 
	
} 

CRVideo_RefreshAllQueueStatus = function(){
	        console.log("RefreshAllQueueStatus begin" );
	        var que_info =CRVideo.queInfo;
	 
	        var queInfos_length = que_info.length;
			console.log("queInfos_length "+ queInfos_length);
			for(var i = 0;i < queInfos_length;i++) {
					
				var item = que_info[i];
				CRVideo_GetQueueStatus(item.queID)	;
						
			}
	        console.log("RefreshAllQueueStatus finished" );
 
	
}    
CRVideo_StartQueuing= function(queID){
	         console.log("CRVideo_StartQueuing begin" );
	          //客服开始排队
		      //{ "cmd": "UserEnter",  "module": "Queue",  "queID": 96, "sessionID": "B564CBE9-227C-47EA-803B-5975EAFE1B1F",  "usrExDat": "hahh"}
		      
			 var UserEnter = {
                      cmd:"UserEnter",
                      module:"Queue",
					  queID: queID,
                                 sessionID:CRVideo.sessionID,
								 usrExDat: "hahh"
                                };
						 
						
			CRVideo.webSendcmd(UserEnter);
			CRVideo.queuingID =queID;
            console.log("CRVideo_StartQueuing finished "+JSON.stringify(UserEnter) );
 
	
}    
CRVideo_StopQueuing= function(){
	         console.log("StopQueuing begin" );
	          //客服开始排队
		      //IcePjserversendCmd|{ "cmd": "UserLeave", "module": "Queue", "queID": 96,  "sessionID": "8B16519E-6453-4896-BF50-1B97F43F1B1F"}
		      
			 var UserLeave = {
                      cmd:"UserLeave",
                      module:"Queue",
					  queID: CRVideo.queuingID,
                      sessionID:CRVideo.sessionID
             };
						 
						
			CRVideo.webSendcmd(UserLeave);
			
            console.log("CRVideo StopQueuing finished "+JSON.stringify(UserLeave) );
            //CRVideo.queuingID =null ;
	
}    

CRVideo_StartService= function(queID){
	         console.log("CRVideo_StartService begin" );
	          //客服开始排队
		      //{ "cmd": "UserEnter",  "module": "Queue",  "queID": 96, "sessionID": "B564CBE9-227C-47EA-803B-5975EAFE1B1F",  "usrExDat": "hahh"}
		      
			 var AgentEnter = {
                                     cmd:"AgentEnter",
                                     module:"Queue",
								     queID: queID,
                                     sessionID: CRVideo.sessionID
								 
                                    };
						 
			CRVideo.webSendcmd(AgentEnter); 
			CRVideo.queuingID =queID;
            console.log("CRVideo_StartService finished"+JSON.stringify(AgentEnter) );
 
	
}  

CRVideo_StopService= function(queID){
	         console.log("StopService begin" );
	          //客服开始排队
		      //{ "cmd": "UserEnter",  "module": "Queue",  "queID": 96, "sessionID": "B564CBE9-227C-47EA-803B-5975EAFE1B1F",  "usrExDat": "hahh"}
		      
			 var AgentLeave = {
                                     cmd:"AgentLeave",
                                     module:"Queue",
								     queID: queID,
                                     sessionID: CRVideo.sessionID
								 
                                    };
						 
			CRVideo.webSendcmd(AgentLeave); 
			CRVideo.queuingID =queID;
            console.log("StopService finished"+JSON.stringify(AgentLeave) );
 
	
}  

CRVideo_SetDNDStatus= function(state){
	         console.log("setSrvDNDState begin" );
	          //客服设置消息免打搅
		      
		   //   { "cmd": "ClientCustomStatusUpdate", "customStatus": 0, "module": "CallServer", "sessionID": "CA8448FD-2366-4B1F-92D5-550526FE3823"}

			 var ClientCustomStatusUpdate = {
                                     cmd:"ClientCustomStatusUpdate",
                                     module:"CallServer",							    
									 customStatus: state,
                                     sessionID: CRVideo.sessionID
								 
                                    };
						 
			CRVideo.webSendcmd(ClientCustomStatusUpdate); 
			 
            console.log("setSrvDNDState finished"+JSON.stringify(ClientCustomStatusUpdate) );
 
	
}  

//启用客户状态监听
CRVideo_StartUserStatusNotify= function(){
	         console.log("StartUserStatusNotify begin" );
	          //客服设置消息免打搅
		      
		   //   { "cmd": "StartStatusPush" "module": "CallServer", "sessionID": "CA8448FD-2366-4B1F-92D5-550526FE3823"}

			 var StartUserStatusNotify = {
                                     cmd:"StartStatusPush",
                                     module:"CallServer",							    	
                                     sessionID: CRVideo.sessionID
								 
                                    };
						 
			CRVideo.webSendcmd(StartUserStatusNotify); 
			 
            console.log("StartUserStatusNotify finished"+JSON.stringify(StartUserStatusNotify) );
 
	
}  
//停止客户状态监听
CRVideo_StopUserStatusNotify= function(){
	         console.log("StopUserStatusNotify begin" );
	          //客服设置消息免打搅
		      
		   //   { "cmd": "StopStatusPush" "module": "CallServer", "sessionID": "CA8448FD-2366-4B1F-92D5-550526FE3823"}

			 var StopStatusPush = {
                                     cmd:"StopStatusPush",
                                     module:"CallServer",							    	
                                     sessionID: CRVideo.sessionID
								 
                                    };
						 
			CRVideo.webSendcmd(StopStatusPush); 
			 
            console.log("StopUserStatusNotify finished"+JSON.stringify(StopStatusPush) );
 
	
}  

//获取客户状态
CRVideo_GetUserStatus= function(){
	         console.log("GetUserStatus begin" );
	          //客服设置消息免打搅
		      
		     //   { "cmd": "GetUserStatus", "module": "CallServer",  "sessionID": "81E9CA89-0C85-47B0-9842-50DF3C4A1B1F"}

			 var GetUserStatus = {
                                     cmd:"GetUserStatus",
                                     module:"CallServer",							    	
                                     sessionID: CRVideo.sessionID
								 
                                    };
						 
			CRVideo.webSendcmd(GetUserStatus); 
			 
            console.log("GetUserStatus finished"+JSON.stringify(GetUserStatus) );
 
	
} 


 
CRVideo_ShakeHand= function(){
	         //console.log("CRVideo.ShakeHand begin" );
	          //客服开始排队
		      //{ "cmd": "UserEnter",  "module": "Queue",  "queID": 96, "sessionID": "B564CBE9-227C-47EA-803B-5975EAFE1B1F",  "usrExDat": "hahh"}
			 if (CRVideo.LoginFlag ==0) {
				 return ;
			 }  
		     if  (CRVideo.HandErrTimes >4) {
				 CRVideo.LoginFlag =0;
				 CRVideo.HandErrTimes =0;
                 CRVideo_LineOff.callback("");
				
				
             }
			 else {
				
			    var ShakeHand ={};
				 
				 if (!CRVideo.CallID) {
					 ShakeHand = {
                                     cmd:"ShakeHand",
                                     module:"CallServer", 
                                     sessionID: CRVideo.sessionID,
								     timeStamp: Math.round(new Date().getTime()/1000)
                                    };
				 }
				 else {
					    ShakeHand = {
                                     cmd:"ShakeHand",
                                     module:"CallServer", 
                                     sessionID: CRVideo.sessionID,
									 callID:CRVideo.CallID,
								     timeStamp: Math.round(new Date().getTime()/1000)
                                    };
				 }
			  
						 
			    CRVideo.webSendcmd(ShakeHand); 
			    CRVideo.HandErrTimes =CRVideo.HandErrTimes +1;	 
				//console.log("CRVideo_ShakeHand  HandErr " +CRVideo.HandErrTimes);
			    //console.log("CRVideo.ShakeHand finished" +JSON.stringify(ShakeHand) );  
			 }
			
          
 
	
}  

CRVideo_RejectAssignUser= function(queID,userID){
	          console.log("CRVideo.RejectAssignUser begin" );
	          //客服开始排队
		      //{ "accept": 1, "cmd": "AssignResponse","module": "Queue","queID": 12,  "sessionID": "AB3AA04E-084C-4799-80E8-417D2F4C3823","userID": "UI"}
		      
			 var RejectAssignUser = {
				                     accept:0,
                                     cmd:"AssignResponse",
                                     module:"Queue", 
									 queID:queID,
                                     sessionID: CRVideo.sessionID,
								     userID: userID
                                    };
						 
			CRVideo.webSendcmd(RejectAssignUser); 
             console.log("CRVideo.RejectAssignUser finished" +JSON.stringify(RejectAssignUser) );
 
	
}  


/*
{
    "callID": "a5d350c1-75be-41b5-83fe-a41f7a2841c1",  "called": "UI", "calledOEMKey": "CLOUDROOM", "calledType": 0,  "cmd": "ClientCall",
    "meeting": {  "ID": 78186783,  "pswd": "",   "pubMeetUrl": "http://10.8.8.220/43get8",   "subject": "test" }, 
	"module": "CallServer", "sessionID": "AB3AA04E-084C-4799-80E8-417D2F4C3823","usrExDat": ""
}


meetCreateJson
{
{
 "CRMTStr": "CRMT:LU1FRVRVUkw9MTAuOC44LjIyMC9zZXJ2bGV0L2dldENsaWVudEFjY0tleQotTUVFVD02Njc4ODM5NzswNGNlZjQ5M2ViZDczMGFkYWFmY2M5NzZkOTA4MTlhMgotQUNOVD0xMDAwMDA1NjM5OzE7OWFmYTVkN2M5MmNlNzRlZWQ4NGNjNjgxM2I0M2FlYWU7NjE2NDZkNjk2ZTsKLUxBTkc9emhfQ04KLU1FRVRUWVBFPU1BSU4KLUxPR0NGRz0wCi1XRUJTVlI9MTAuOC44LjIyMAotRE9NQUlOPTA=",
  "HostUrl": "http://10.8.8.220/tnay52","PublicUrl": "http://10.8.8.220/tzmw6a", "MeetPswd": "","HostPwd": "177951", "MeetID": 66788397, "RspCode": 0,"RspDesc": "", "UpdateUrl": null, "NewVersion": null, "PublicIP": "10.8.8.17", "residentVersion": null,
  "advertiseVersion": null,"AndroidNetTvVsersion": null, "tvType": 0,  "Data": null
}

}

  建立呼叫
*/
CRVideo_Call= function(callUserID,meetCreateJson){
		console.log("会议ID值："+meetCreateJson.ID);
		console.log("会议地址："+meetCreateJson.pubMeetUrl)
		CRVideo.pubMeetUrl = meetCreateJson.pubMeetUrl;
	    console.log("CRVideo.Call begin" );
	          
		      
			 var call ={
                          callID: Ice.generateUUID(),
                          called: callUserID,
                          calledOEMKey: "CLOUDROOM",
                          calledType: 0,
                          cmd: "ClientCall",
                          meeting: {
                              ID: meetCreateJson.ID,
                              pswd: meetCreateJson.pswd,
                              pubMeetUrl: meetCreateJson.pubMeetUrl,
                              subject: CRVideo.meetSubject
                         },
                        module: "CallServer",
                        sessionID:  CRVideo.sessionID,
                        usrExDat: ""
             }

			CRVideo.webSendcmd(call); 
            console.log("CRVideo.Call finished" +JSON.stringify(call) );
 
	
}  
/** 
  * 客户端会话
  *
*/
CRVideo_ClientReleaseCall= function(id){
	 var call ={
                callID: id,
                sessionID:  CRVideo.sessionID,
                cmd: "ClientReleaseCall",
                module: "CallServer",
     }

	CRVideo.webSendcmd(call); 
    console.log("CRVideo_ClientReleaseCall" +JSON.stringify(call) );
 
	
}  
CRVideo_AcceptAssignUser= function(queID,userID){
	          console.log("CRVideo.AcceptAssignUser begin" );
	          //客服开始排队
		      //{ "accept": 1, "cmd": "AssignResponse","module": "Queue","queID": 12,  "sessionID": "AB3AA04E-084C-4799-80E8-417D2F4C3823","userID": "UI"}
		      
			 var AcceptAssignUser = {
				                     accept:1,
                                     cmd:"AssignResponse",
                                     module:"Queue", 
									 queID:queID,
                                     sessionID: CRVideo.sessionID,
								     userID: userID
                                    };
						 
			CRVideo.webSendcmd(AcceptAssignUser); 
             console.log("CRVideo.AcceptAssignUser finished" +JSON.stringify(AcceptAssignUser) );
 
	
}  
 
 
CRVideo_AcceptCall = function(callId,meetObj){
	console.log("CRVideo_AcceptCall："+meetObj)
	CRVideo.pubMeetUrl = meetObj.pubMeetUrl;
	console.log("会议ID值："+meetObj.ID);
	console.log("会议地址："+meetObj.pubMeetUrl)
	  //客服接收呼叫 
	 //{ "callID": "a7b76875-36d5-487b-803f-c7421285ba05",   "cmd": "ClientAccept",  
	  // "meeting": {   "ID": 25503254,    "pswd": "",  "pubMeetUrl": "http://10.8.8.220/eejqei",   "subject": "dd" },
     //  "module": "CallServer", "sessionID": "BC963A06-72A6-448C-A3E3-0BD413E43823",   "usrExDat": "}
		      
			 var AcceptCall = {
				        callID: callId,
                        cmd: "ClientAccept",
                       meeting: meetObj ,
                       module: "CallServer",
                       sessionID: CRVideo.sessionID,
                       usrExDat: ""
             };
						 
			 CRVideo.webSendcmd(AcceptCall);
			 CRVideo.CallID = callId; 
			 console.log("CRVideo.AcceptCall CRVideo.CallID=" +callId ) 
             console.log("CRVideo.AcceptCall finished" +JSON.stringify(AcceptCall) ) 
}

CRVideo_ReqAssignUser= function(){
	  //客服接收呼叫 
	 
		      
			 var RequestUser = {
				      
                        cmd: "RequestUser",
                        module: "Queue",
                        sessionID: CRVideo.sessionID,
             };
						 
			 CRVideo.webSendcmd(RequestUser); 
             console.log("CRVideo.RequestUser finished" +JSON.stringify(RequestUser) ) 
};
CRVideo_CallMoreParty= function(called,meetObj,usrExtDat,cookie){
	  // 第三方呼叫                    
	 
		     var inviteID = Ice.generateUUID();
			 var CallMoreParty = {
                 callID: CRVideo.CallID,
                 called: "called",
                 calledOEMKey: "CLOUDROOM",
                 cmd: "ClientInvite",
                 inviteID :  CRVideo.inviteID,
                 meeting:  meetObj,
                 module: "CallServer",
                 sessionID: CRVideo.sessionID,
                 usrExDat: "{\n    \"clientInvite\": 1\n}\n"
             }
						 
			 CRVideo.webSendcmd(CallMoreParty); 
			 return inviteID;
             //console.log("CRVideo.CallMoreParty finished" +JSON.stringify(CallMoreParty) ) 
};
CRVideo_ClientCancelInvite= function(inviteID,cookie){
	  // 第三方呼叫                    
	 
		     
			 var CancelInvite =  {
                 cmd: "ClientCancelInvite",
                 inviteID: inviteID,
                 module: "CallServer",
                 reason: "cancel",
                 sessionID: CRVideo.sessionID,
                 usrExDat: ""
             }
						 
			 CRVideo.webSendcmd(CancelInvite); 
			 return inviteID;
             //console.log("CRVideo.CancelInvite finished" +JSON.stringify(CancelInvite) ) 
};
CRVideo_CreateMeeting= function(server_addr,account,pwd,meetSubject){
	var url = CRVideo.protocol + '//'+server_addr + '/servlet/ClientCreateNetMeet' ;
	
	 
	var _data_ = {
		RequestId : Ice.generateUUID(), 
		UserName :account, 
		UserPswd: pwd, 
		MeetSubject:  encodeURI(meetSubject),
		IsRegular : 0,
		NeedPswd : '0'
		}
		var params = {
			 jsoncallback: 'CreateMeetingCallBack',
			 _data_ : JSON.stringify(_data_)
		}
		CRVideo.meetSubject =meetSubject;
		$.ajax({
		url : url,
		data : params,
				dataType : 'jsonp',
				success : function(result){}
		}) 

}

CRVideo_GetCallServerInfoSuccess.callback = function(json)  ///////参数变化 
{
    console.log("GetCallServerInfoSuccessCallBack："+ JSON.stringify(json));
    var callSvrList = json.callSvrList ;
    var tmp= new Array()
    tmp = callSvrList.split(":");
    var callSvr= new Array(); //定义一数组  
    if (tmp.length !=2) {
       console.log("获取服务列表失败");
	   return ;
    }
    callSvr = tmp[0].split(";");
   CRVideo_initIce(callSvr[0],tmp[1]);
    if( json.uploadUrl){
        var logSvrList = json.uploadUrl.split(";")[0] ? json.uploadUrl.split(";")[0] : json.uploadUrl.split(";")[1];
        var logSvr = logSvrList.split(":")[0];
        var logPort = parseInt(logSvrList.split(":")[1]) + 1;
        //	var logserver =  "Log.ClientLogServer:wss -h logserver.cloudroom.com -p 12006" ;
            var logserver =  CRVideo.logServer || "Log.ClientLogServer:wss -h "+ logSvr +" -p "+ logPort ;
            console.log('logserver: ' + logserver);
            CRVideo.logproxy = CRVideo.ic.stringToProxy(logserver);
            CRVideo_LoggerAdapter();
            var logUUID ='';
            if(window.localStorage){
                logUUID = window.localStorage.getItem('logUUID');
                if(!logUUID){
                    logUUID = Ice.generateUUID();
                    window.localStorage.setItem('logUUID',logUUID );
                }
            }
            CRVideo.logUUID  = logUUID ;
            //调用日志上传
        if (CRVideo.isPlantForm()) { //移动端先不调用
            CRVideo_UploadingReport();
        }
    }
   CRVideo_SetAdapter();
   	var loginJson = {
          	OEMKey:"CLOUDROOM",
          	SDKVersion:"",
          	cmd:"Login",
          	crAcnt:CRVideo.LoginParam.account,
          	crPswd:CRVideo.LoginParam.psw,
          	deviceType:"",
          	language:"",
          	module:"CallServer",
          	productType:"win32_net",
          	userID:CRVideo.LoginParam.user_id,
          	userName:CRVideo.LoginParam.nick_name
    };	
	CRVideo.webSendcmd(loginJson);
	console.log("loginJson =  " +JSON.stringify(loginJson) );
	console.log("CRVideo.Login finished" );
}


/*
{ "ClientVer": "", "IpAddr": "192.168.199.139", "Language": "", "MacAddr": "DC-A9-71-9E-EE-3C", 
"MgrSDKVer": "1.4.0 2018-1-15_11:41:09", 
"OEMKey": "CLOUDROOM", "PRODUCT": "win32_net", "RequestId": "b946c644-bf33-4597-a8a7-eaadcd8ac435-1", "UserName": "demo@cloudroom.com", "UserPswd": "e10adc3949ba59abbe56e057f20f883e"
}: 
*/


function GetCallServerInfoCallBack(json){
	 console.log("CRVideo.GetCallServerInfoCallBack  result " +JSON.stringify(json) ) ;
	 if(json.RspCode == 0){
		 
		 CRVideo_GetCallServerInfoSuccess.callback(json);
		  
	 }
	 else {
		CRVideo_GetCallServerInfoFail.callback(json);
		
	 }
}

CRVideo_Logout = function() {
		 var Logout = {
				      
                        cmd: "Logout",
                        module: "CallServer",
                        sessionID: CRVideo.sessionID,
             };

			var logInfoEnd = {type:'End',info:'注销登录'};
			//CRVideo_UploadingLog('',logInfoEnd);
			 CRVideo.webSendcmd(Logout); 
			 CRVideo.CallID ="";
			 CRVideo.HandErrTimes =0;
             console.log("CRVideo.Logout finished" +JSON.stringify(Logout) );


}

var CRVideo_GetCallServerInfo = function(server_addr,account,pwd){
	
	var url = CRVideo.protocol + '//'+server_addr  + '/servlet/getJsCallServerInfo' ;
	
	var _data_ = {
		ClientVer : "",
		IpAddr : "192.168.199.139",
		Language: "", 
		MacAddr: "DC-A9-71-9E-EE-3C", 
		MgrSDKVer: "1.4.0 2018-1-15_11:41:09", 
		OEMKey: "CLOUDROOM",
		PRODUCT: "win32_net",
		RequestId : Ice.generateUUID(), 
		UserName :account, 
		UserPswd: pwd
	}
	$.ajax({
		url : url,
		type : "get",
		data : _data_,
		success : function(result){
			GetCallServerInfoCallBack(result);
		}
	}) 
};

function CreateMeetingCallBack(json){
	 var  meetObj =   {
                              ID: json.MeetID,
                              pswd: json.MeetPswd,
                              pubMeetUrl: json.PublicUrl,
                              subject: CRVideo.meetSubject
                         } ;
	 if(json.RspCode == 0){
		 
		CRVideo_CreateMeetingSuccess.callback(meetObj,"") ;
	 }
	 else {
		CRVideo_CreateMeetingFail.callback(json.RspCode,"")  ;
	 }
}

 /*
 {
    "ClientVer": "",
    "MeetID": 25503254,
    "MeetPswd": "",
    "NickName": "dd",
    "OEMKey": "CLOUDROOM",
    "PRODUCT": "win32_net",
    "RequestId": "7828321d-00f4-4dcb-9779-974a883e7bc4-3",
    "UserType": 4
}
*/


CRVideo_EnterMeeting = function(meetID,pwd,seat_id,nickname,usrExDat){
	
	var url = CRVideo.protocol + '//'+ CRVideo.callserverName + '/servlet/joinMeetingAPI' ;
	
	console.log("CRVideo.EnterMeeting  begin： "+meetID  )
	var _data_ = {
		ClientVer : "", 
		RequestId : Ice.generateUUID(), 
		MeetID :meetID, 
		UserPswd: pwd, 
		NickName: encodeURI(nickname),
		OEMKey: "CLOUDROOM",
		PRODUCT: "win32_net",
		UserType: 4
		}
	    console.log("CRVideo.EnterMeeting  " +JSON.stringify(_data_) ) 
		var params = {
			 jsoncallback: 'EnterMeetingCallBack',
			 _data_ : JSON.stringify(_data_)
		}
		$.ajax({
			url : url,
			data : params,
			dataType : 'jsonp',
			success : function(result){	
			}
		});
}
//------------------------------
				//
				//登录处理
				//
//------------------------------
CRVideo_ShakeHandRslt.callback= function(josn) {
	console.log("CRVideo_ShakeHandRslt callback" +JSON.stringify(josn));
	CRVideo.HandErrTimes =CRVideo.HandErrTimes-1;
	console.log("CRVideo_ShakeHandRslt HandErrTimes" +CRVideo.HandErrTimes);
					 
}
CRVideo_AcceptCallSuccess.callback= function(RspCode,json,cookie) {
	 
					 
}

CRVideo_AcceptCallFail.callback= function(RspCode,json,cookie) {
	 
					 
}
//入会回调
function EnterMeetingCallBack(json){
	console.log("EnterMeetingCallBack")
	  if(json.RspCode == 0){
		 CRVideo.initweb();
		 
	  }else{
	  	console.log("入会失败")
	  }
}
var CRVideo_Init2 = function(dri){
	return "0";

}
var CRVideo_HungupCall = function(id){
	console.log("CRVideo_HungupCall:" + id);
	CRVideo_ClientReleaseCall(id);
};
CRVideo_ShakeHandRslt.callback= function(josn) {
				     
	  CRVideo.HandErrTimes =CRVideo.HandErrTimes-1;
	  //console.log("CRVideo.HandErrTimes",CRVideo.HandErrTimes)
	 
} 











	CRVideo.Container = function()
	{
		
	}
	CRVideo._containerList = [];

	/**
	 * object对象
	 */	
	CRVideo.Container.prototype.handler = function(value)
	{
		if(value === undefined)
		{
			return this._handler;
		}else
		{
			this._handler = value;
		}
	}
	 /**
	 * id
	 */	
	 CRVideo.Container.prototype.__addCallBack = function()
	{

	}
	CRVideo.Container.prototype.id = function(value)
	{
		if(value === undefined)
		{
			return this._handler.id;
		}else
		{
			this._handler.id = value;
		}
		
	}
	CRVideo.Container.prototype.width = function(value)
	{
		if(value === undefined)
		{
			return this._handler.style.width + "px";
		}else
		{
			this._handler.style.width = value + "px";
		}
		
	}
	CRVideo.Container.prototype.height = function(value)
	{
		if(value === undefined)
		{
			return this._handler.style.height + "px";
		}else
		{
			this._handler.style.height = value + "px";
		}
		
	}
	CRVideo.Container.prototype.left = function(value)
	{
		if(value === undefined)
		{
			return this._handler.style.left + "px";
		}else
		{
			this._handler.style.left = value + "px";
		}
		
	}
	CRVideo.Container.prototype.top = function(value)
	{
		if(value === undefined)
		{
			return this._handler.style.top + "px";
		}else
		{
			this._handler.style.top = value + "px";
		}
		
	}
	CRVideo.Container.prototype.shows = function()
	{
		if(value === undefined)
		{
			return this._handler.style.display;
		}else
		{
			this._handler.style.display = "block";
		}
		
	}
	CRVideo.Container.prototype.hidden = function()
	{
		if(value === undefined)
		{
			return this._handler.style.display;
		}else
		{
			this._handler.style.display = "hidden";
		}
		
	}
	CRVideo.VideoContainer = function()
	{
		this._videoID = -1;
		this._usrID = "";
		this._visibleNickName = true;
		CRVideo._containerList.push(this)
	}
	CRVideo.VideoContainer.prototype = new CRVideo.Container()
	 /**
	 * 设置显示的目标用户视频
	 * @access public
	 * @param {string} userID - 目标用户ID
     * @param {number } videoID - 用户的指定视频设备（-1，代表用户的默认视频设备）
	 */	
	CRVideo.VideoContainer.prototype.setVideo = function(usrID,videoID)
	{
		if(videoID == undefined)
		{
			videoID = -1
		}
		this._usrID = usrID;
		this._videoID = videoID;
		this._title = usrID;
		var  chils = this._handler.childNodes;
		var videoName,nickNameNode;
		for(var i=0;i<chils.length;i++){
			if(chils[i].nodeName == "VIDEO"){
				videoName = chils[i];
				//需要将usrID变为termID
				videoName.id = "video" + usrID;
			}else if(chils[i].nodeName == "DIV"){
				nickNameNode = chils[i];
				nickNameNode.id = "nickname" + usrID;
			}
		};
		var videoNode = document.getElementById("video" + usrID);
		var nameNode = document.getElementById("nickname" + usrID);
		nameNode.innerHTML = usrID;
		if(usrID == CRVideo.userinfo.userID){
			if(CRVideo.userinfo.stream){
				videoNode.srcObject = CRVideo.userinfo.stream;
			}
			
		}else if(usrID == CRVideo.userinfo.userID){
			if(CRVideo.remoteinfo.stream){
				videoNode.srcObject = CRVideo.remoteinfo.stream;
			}
			
		}
	}
	
	/**
	 * 获取当前显示的用户的视频设备
	 * @access public
	 * @return {string} 视频ID
	 */	
	CRVideo.VideoContainer.prototype.getVideoID = function()
	{
		return window.videotrack;
	}
    /**
	 * 清理当前图像
	 * @access public
	 */	
	CRVideo.VideoContainer.prototype.clear = function()
	{
		var  chils = this._handler.childNodes;
		var videoName;
		for(var i=0;i<chils.length;i++){
			if(chils[i].nodeName == "VIDEO"){
				videoName = chils[i];
			}
		};
	}
     /**
	 * 设置是否显示昵称
	 * @access public
     * @param {bool} value - 否显示昵称
	 */	
	CRVideo.VideoContainer.prototype.setVisibleNickName = function(value)
	{
		this._visibleNickName = value
		this._handler.visibleNickName = value;
		var nickname = document.getElementById("nickname" + this._usrID);
		if(value){
			
			nickname.style.display = "block";
		}else{
			nickname.style.display = "none";
		}

	}
    /**
	 * 获取是否显示昵称
	 * @access public
     * @return {bool} 否显示昵称
	 */	
	CRVideo.VideoContainer.prototype.getVisibleNickName = function()
	{
		return this._handler.visibleNickName;
	}
    /**
	 * 拍照
	 * @access public
     * @param {string} pathFileName - 本地绝对路径文件名(支持格式：bmp, png, gif, jpg, jpeg)
     * @return {bool} 0:成功； 非0：保存遇到的错误码；
	 */	
	CRVideo.VideoContainer.prototype.savePic = function(pathFileName)
	{
		return this._handler.savePic(pathFileName);
	}
     /**
	 * 检查图像是否为空
     * @return {bool} 图像是否为空
	 */	
	CRVideo.VideoContainer.prototype.isPicEmpty = function()
	{
		if(CRVideo.userinfo.stream){
			return true
		}else{
			return false;
		}
		
	}
     /**
	 * 设置显示的视频画面是否保持比例
     * @param {bool} value - true: 保持比例不拉伸， false:不保持比例进行拉伸
	 */	
    CRVideo.VideoContainer.prototype.keepAspectRatio = function(value)
	{
        if(value === undefined)
        {
            return this._handler.keepAspectRatio;
        }else
        {
            this._handler.keepAspectRatio = value;
        }
	}
	/**
	 * 检查昵称是否可见
     * @param {bool} value - 0: 可见， 1:不可见
	 */	
    CRVideo.VideoContainer.prototype.visibleNickName = function(value)
	{
        if(value === undefined)
        {
            return this._handler.visibleNickName;
        }else
        {
            this._handler.visibleNickName = value;
        }
	}      


	CRVideo_CreatVideoObj = function()
	{
		var handler,videsdk;
		handler  =  document.createElement("div");
		handler.style.width = "100%";
		handler.style.height = '100%';
		handler.className = "CRVideo_VideoObj"

		videsdk = document.createElement("video");
	    videsdk.style.width = '100%';
	    videsdk.style.height = '100%';
	    videsdk.poster = '/webrtc/image/ycBg.jpg';
	    videsdk.autoplay =true;
        videsdk.setAttribute('muted', '');
        videsdk.setAttribute('playsinline', '');

	    var nickName = document.createElement("div");
	    nickName.style.width = '100px';
	    nickName.style.height = '30px';
	    nickName.style.color = '#fff';
	    nickName.style.position = 'absolute';
	    nickName.name = "nodename";
	    nickName.style.display = "none";
	    nickName.style.left = "30px";
	    nickName.style.top = "30px";
	    nickName.style.zIndex = "2";
	    nickName.style.opacity = "0.5"
	    nickName.style.filter = 'alpha(opacity:50)'; //设置IE的透明度 
	    nickName.style.fontWeight="800";


		handler.appendChild(nickName);
	   	handler.appendChild(videsdk);
	    //设置元素为隐藏 
		var video = new CRVideo.VideoContainer();
		video.handler(handler);
		return video;
	}
CRVideo.LOCAL_KEY; // 全局变量识别码
CRVideo.KEEPLIVE_COMMIT = false;
CRVideo.KEEPALIVE_TIMER = -1; // keepLive握手事件的状态判断码 判断目前是否是直播状态
CRVideo.REFRESH_SESSION = -1; // 心跳包事件
CRVideo.COUNT_VIDEO_PLAY = 1; // 统计视频是否被点击播放
CRVideo.DOMAIN_MAIN = "";
CRVideo.isLine = 0; //是否在线                      
CRVideo.roominfo = {};
CRVideo.userinfo = {}; //用户对象
CRVideo.remoteinfo = {}; //订阅者对象
CRVideo.isMyVideoStream = false; // 当前本地视频流是否已存在
CRVideo.configuration = {
  "iceServers": [{
    urls: 'stun:121.42.156.84:3478'
  }]
};
CRVideo.videotrack = {};
CRVideo.videotrack.id = "";
CRVideo.getAllMemberInfo = null; //获取所有入会者者信息
CRVideo.maxBps = "512";
CRVideo.sizeTypeArry = [[0, 0, 0],[144, 80, 56],[224, 128, 72],[288, 160, 100],[336, 192, 150],[448, 256, 200],[512, 288, 250],[576, 320, 300],[640, 360, 350],[720, 400, 420],[848, 480, 500],[1024, 576, 650],[1280, 720, 1024],[1920, 1080, 2048]];
//,rtcpMuxPolicy: "negotiate"
/**********************************************************  会议登录相关逻辑 *****************************************************/
CRVideo.initweb = function () {
  var serverName = CRVideo.callserverName;
  var meetName = CRVideo.pubMeetUrl.substr(CRVideo.pubMeetUrl.length - 6);
  var userName = CRVideo.LoginParam.nick_name;
  CRVideo.roominfo.roomid = meetName;
  var client_codeid =  window.localStorage.getItem('client_pcid') ? window.localStorage.getItem('client_pcid') : Ice.generateUUID();
  CRVideo.userinfo = {
    "nickname": userName,
    "userID": CRVideo.LoginParam.user_id,
    "headerUrl": "",
    "userCode": 　client_codeid,         
    "openId": ""
  }
  CRVideo.urlHref = CRVideo.callserverName;
  var config = {
    "LiveCode": meetName,
    "NickName": userName,
    "headerUrl": "",
    "userCode": client_codeid,
    "openId": ""
  }
  window.localStorage.setItem('client_pcid',client_codeid)
  // 判断当期使用哪一种地址
  CRVideo.DOMAIN_MAIN = CRVideo.protocol + "//" + CRVideo.urlHref;
  var params = config || {};
  params._callback_ = "CRVideo.initLive";
  $.ajax({
    url: CRVideo.DOMAIN_MAIN + "/api/getLiveInfoAPI",
    type: "get",
    data: params,
    dataType: "jsonp",
    jsonp: "callback",
    error: function (textStatus, errorThrown) {},
    success: function (data) {}
  });
};
CRVideo.initLive = function (data) {
  CRVideo.LIVE_INFO = data.liveInfo;
  if (CRVideo.protocol == "https:") {
    CR__Init('js', {
      "protocol": "wss",
      "CheckFlash": false
    });
  } else {
    CR__Init('js', {
      "protocol": "ws",
      "CheckFlash": false
    });
  }

};
// 初始化回调
CR_InitRslt.callback = function (errCode, errDesc) {
  if (errCode == 0) {
    console.log("初始化成功")
    CRVideo.loginWebMeeting();
  }
};
// 判断当前直播是什么平台
CRVideo.isPlantForm = function () {
  var isWhatPlant = true;
  var userAgentInfo = navigator.userAgent;
  var Agents = new Array("Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod");
  var agentinfo = null;
  for (var i = 0; i < Agents.length; i++) {
    if (userAgentInfo.indexOf(Agents[i]) > 0) {
      agentinfo = userAgentInfo;
      break;
    }
  }
  if (agentinfo) {
    isWhatPlant = false;
  } else {
    isWhatPlant = true;
  }
  return isWhatPlant;
};
CRVideo.loginWebMeeting = function () {
  var myDetail = {};
  var myDetail2 = {};
  myDetail2.nickname = CRVideo.userinfo.nickname || '';
  var userCode = CRVideo.userinfo.userCode;
  var openId = CRVideo.userinfo.openId ? CRVideo.userinfo.openId : "";
  //登录（是否重登）
  CRVideo.KEEPLIVE_COMMIT = true;
  //要将上一次会议登录的信息置空，否则会登录上一次的会议
  Cr.crmt = null;
  CR__Login(CRVideo.LIVE_INFO.dataStr, localStorage.getItem(CRVideo.LOCAL_KEY + "_USERID_" + CRVideo.roominfo.roomid), myDetail2, userCode, CRVideo.userinfo.openId);
}
//登录回调
CR_LoginRslt.callback = function (errCode, errDesc, data) {
  console.log('登录回调 errCode: '+ errCode +' ----errDesc: \n' +errDesc);
  CRVideo.meetingInfo = data;
  console.log(CRVideo.meetingInfo)
  if (errCode == "1") {
    console.log("超过并发数")
    return;
  } else if (errCode == "4") {
    console.log("初始化成功，昵称重复")
  } else if (errCode == "0") {
    console.log("登录成功")
    CRVideo.userinfo.detail = data.myDetail;
    CRVideo.userinfo.termId = data.termId;
    //获取所有聊天数据；传值0则获取最后一条
    CRVideo.KEEPALIVE_TIMER = setTimeout(function () {
      CR__KeepAlive(CRVideo.COUNT_VIDEO_PLAY)
    }, 30000);
    CRVideo.REFRESH_SESSION = setTimeout(function () {
      CR__RefreshSession()
    }, 15000);
    CR__GetActiveMembers();

    var deviceInfos = navigator.mediaDevices.enumerateDevices();
    // console.log({'===138==deviceInfos=====: ': deviceInfos});
    
    CRVideo.getDevicesMedia(deviceInfos);
    var member = data.activeMembers;
    for (var i = 0; i < member.length; i++) {
      if (member[i].termId != data.termId) {
        CRVideo.remoteinfo.termId = member[i].termId;
        CRVideo.remoteinfo.nickname = member[i].nickname;
      }
    }
  } else {
    console.log("初始化失败");
    //CRVideo.initweb();
  }
  CRVideo_EnterMeetingRslt.callback(errCode);
};
CR__RefreshSessionRslt.callback = function (errCode, errDesc) {
  if (errCode == CR_NOERR && CRVideo.REFRESH_SESSION != -1) { //连接正常
    CRVideo.REFRESH_SESSION = setTimeout(function () {
      CR__RefreshSession();
    }, 15000);
  }
};
//服务器连接监听
CR__KeepAliveRslt.callback = function (errCode, errDesc) {
  if (errCode == CR_NOERR && CRVideo.KEEPALIVE_TIMER != -1) { //连接正常
    CRVideo.KEEPALIVE_TIMER = setTimeout(function () {
      CR__KeepAlive(CRVideo.COUNT_VIDEO_PLAY);
    }, 30000)
  }
};
//直播频道结束监听  C
CR__MeetEnded.callback = function (terminalId) {
  CR__UnInit();
}
var CRVideo_Uninit = function () {
  CR__UnInit();
}
// 监听页面切换并保持握手事件
$(function () {
  // 页面加载时的监听事件
  var hiddenProperty = "hidden" in document ? "hidden" :
    "webkitHidden" in document ? "webkitHidden" :
    "mozHidden" in document ? "mozHidden" :
    null;
  var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, "visibilitychange");
  var onVisibilityChange = function () {
    if (!document[hiddenProperty]) {
      if (CRVideo.KEEPLIVE_COMMIT && CRVideo.KEEPALIVE_TIMER != -1 && CRVideo.REFRESH_SESSION != -1) {
        clearTimeout(CRVideo.KEEPALIVE_TIMER);
        CRVideo.KEEPALIVE_TIMER = -1;
        CR__KeepAlive(CRVideo.COUNT_VIDEO_PLAY);
        clearTimeout(CRVideo.REFRESH_SESSION)
        CRVideo.REFRESH_SESSION = -1;
        CR__RefreshSession();
      }
      //这里应该再加上shakhand的方法
    }
  }
  document.addEventListener(visibilityChangeEvent, onVisibilityChange);
});
/****************************************************************** 入会后 webrtc相关代码 ******************************************************/
navigator.mediaDevices.enumerateDevices().then(CRVideo.getDevicesMedia).catch(function (error) {
  console.log('navigator.getUserMedia error: ', error)
});
CRVideo.getDevicesMedia = function (MediaDeviceInfo) {
   console.log({'===204==deviceInfos=====: ': MediaDeviceInfo});
   CRVideo.audioInput = [];
   CRVideo.audioOutput = [];
   CRVideo.videoInput = [];
      for (var i = 0; i < MediaDeviceInfo.length; i++) {
        var deviceItem = MediaDeviceInfo[i];
        if (deviceItem.kind == "audioinput" && deviceItem.deviceId.length > 20) {
            var audioItem = {}
            audioItem.id = deviceItem.deviceId;
            audioItem.name = deviceItem.label;
            CRVideo.audioInput.push(audioItem);  
        } else if (deviceItem.kind == "audiooutput" && deviceItem.deviceId.length > 20) {
            var audioItem2 = {}
            audioItem2.id = deviceItem.deviceId;
            audioItem2.name = deviceItem.label;
            CRVideo.audioOutput.push(audioItem2);
        } else if (deviceItem.kind == "videoinput" && deviceItem.deviceId.length > 20) {
            var videoItem = {}
            videoItem.id = deviceItem.deviceId;
            videoItem.name = deviceItem.label;
            CRVideo.videoInput.push(videoItem);
        }
    }
}
var CRVideo_GetAudioMicNames = function () {
  return CRVideo.audioInput;
}
var CRVideo_GetAudioSpkNames = function () {
  return CRVideo.audioOutput;
}
var CRVideo_GetAllVideoInfo = function () {
  return CRVideo.videoInput;
}
var CRVideo_OpenMic = function (id) {
  var myAudio = document.createElement('audio') //生成一个audio元素 
  myAudio.autoplay = true //这样控件才能显示出来 
  myAudio.style.display = 'none' //音乐的路径 
  myAudio.id = 'mainAudio' //音乐的路径 
  document.body.appendChild(myAudio) //把它添加到页面中
  window.audioConstraints = {
    video: false,
    audio: true
  }
  openAndChangeAudioDevices(window.audioConstraints);
}
var CRVideo_CloseMic = function (id) {
  if (window.audioStream) {
    window.audioStream.getTracks().forEach(function (track) {
      track.stop();
    });
  };
  CR__CloseMicEx(CRVideo.userinfo.termId)
}
var CRVideo_OpenVideo = function (userId) {
  if (CRVideo.isPlantForm()) {
    if(CRVideo.videotrack && CRVideo.videotrack.id && CRVideo.videotrack.id != ""){
        window.videoConstraints = {video: {width:{exact:640},aspectRatio: {exact: 16 / 9},deviceId:{exact: CRVideo.videotrack.id}},audio: false};
    }else{
        window.videoConstraints = {video: {width:{exact:640},aspectRatio: {exact: 16 / 9}},audio: false};
    }
  } else {
    window.videoConstraints = {
      video: {
        facingMode: 'user'
      }, // facingMode: user 前置 / environment 后置摄像头
      audio: false
    };
  }
  CRVideo.maxBps ="350";
  openAndChangeVideoDevices(window.videoConstraints);

}
var CRVideo_CloseVideo = function () {
  if (window.videoStream) {
    window.videoStream.getTracks().forEach(function (track) {
      track.stop();
    });
  };
  CR__StopVideo();
};
var CRVideo_UpdateVideoRate = function(){
    if (window.videoStream) {
        window.videoStream.getTracks().forEach(function (track) {
            track.stop();
        });
    };
    CR__StopVideo();
    if(window.videotrack){
        window.videotrack.stop();
    }
    if(window.myVideoConnection){
        window.myVideoConnection.close();
        window.myVideoConnection = null;
    }
    window.localVideoOffer = "";
    window.myvideo_cb = null;
  
}
// 设置及请求RTCpeerconnection
var setupVideoPeerConnection = function (stream) {
  window.myVideoConnection = new RTCPeerConnection(CRVideo.configuration);
  window.myVideoConnection.addStream(stream);
  window.myVideoConnection.createOffer(function (offer) {
    CRVideo.maxBps =  CRVideo.maxBps ? CRVideo.maxBps : "512";
    console.log("c=IN IP4 0.0.0.0\r\nb=AS:" +　CRVideo.maxBps)
    offer.sdp = offer.sdp.replace("c=IN IP4 0.0.0.0", "c=IN IP4 0.0.0.0\r\nb=AS:" +　CRVideo.maxBps);
    window.localVideoOffer = offer;
    window.myVideoConnection.setLocalDescription(offer);
  }, function (error) {
    alert("An error has occurred.");
  });
  window.myVideoConnection.onaddstream = function (e) {

  };
  var candidates = [];
  var isFirt = 0;
  window.myVideoConnection.onicecandidate = function (event) {
    if (event.candidate) {
      if (!isFirt) {
        var ip = event.candidate.candidate.split(' ')[4];
        var comp_id = event.candidate.candidate.split(' ')[1];
        if (ip && comp_id == '1' && ip.length <= 15 && !ip.match('10\\.') && !ip.match('172\\.') && !ip.match('192\\.') && !ip.match('169\\.254\\.')) {
          candidates.push(event.candidate);
          console.log("ICE GATHERING NOT COMPLETED, BUT HAVE NOT NAT IP ADDRESS!");
          CRVideo.myVideoMsid = 0;
          candidates = JSON.stringify(candidates);
          console.log("myVideoConnection--candidates:"+ candidates)
          var params = new Ice.HashMap();
          params.set('sdp', window.localVideoOffer.sdp);
          params.set('icecandidate', candidates);
          window.myvideo_cb.ice_response(CRVideo.myVideoMsid, params);
          isFirt = 1;

        };
      };

    };
  };
};
// 设置及请求本地音频信息
var setupAudioPeerConnection = function (stream) {
  window.myAudioConnection = new RTCPeerConnection(CRVideo.configuration);
  window.myAudioConnection.addStream(stream);

  window.myAudioConnection.createOffer(function (offer) {
    window.localAudioOffer = offer;
    window.myAudioConnection.setLocalDescription(offer);
  }, function (error) {
    alert("An error has occurred.");
  });
  window.myAudioConnection.onaddstream = function (e) {
    document.getElementById('mainAudio').srcObject = e.stream;
  };
  var candidates = [];
  var isFirt = 0;
  window.myAudioConnection.onicecandidate = function (event) {
    if (event.candidate) {
      if (!isFirt) {
        var ip = event.candidate.candidate.split(' ')[4];
        var comp_id = event.candidate.candidate.split(' ')[1];
        //candidates.push(event.candidate);
        if (ip && comp_id == '1' && ip.length <= 15 && !ip.match('10\\.') && !ip.match('172\\.') && !ip.match('192\\.') && !ip.match('169\\.254\\.')) {
          candidates.push(event.candidate);
          console.log("ICE GATHERING NOT COMPLETED, BUT HAVE NOT NAT IP ADDRESS!");
          CRVideo.myAudioMsid = 2;
          candidates = JSON.stringify(candidates);
          console.log("myAudioConnection--candidates:"+ candidates);
          var params = new Ice.HashMap();
          params.set('sdp', window.localAudioOffer.sdp);
          params.set('icecandidate', candidates);
          window.myaudio_cb.ice_response(CRVideo.myAudioMsid, params);
          isFirt = 1;

        }
      }

    }
  };
}
// 开始连接
CR__SetVideoDeviceStatusRslt.callback = function (error, err) {
  //这个是视频
  error = error == 0 ? "成功" : "失败"
  console.log("CR__SetVideoDeviceStatusRslt----"+ error)
}
CR__SetAudioDeviceStatusRslt.callback = function (error, err) {
  //这是音频
  if (error == "0") {
    CR__AskForMic();
  }
  error = error == 0 ? "成功" : "失败"
  console.log("CR__SetAudioDeviceStatusRslt---"+ error);
}
CR__SubscribeFocusWindow2Rslt.callback = function (error, err) {
  error = error == 0 ? "成功" : "失败"
  console.log("CR__SubscribeFocusWindow2Rslt"+ err)
}
CR__VideoAllocRawExt2.callback = function (cb, vsParam, srcSelf, strParams) {
  //第一个参数为回调函数  第三个参数为是否是本人的摄像头
  if (srcSelf) {
    //是本人的摄像头
    window.myvideo_cb = cb;
    if(window.videoStream){
         setupVideoPeerConnection(window.videoStream)
    }
  } else {
    //不是本人的摄像头
    window.remotevideo_cb = cb;
    initRemotVideo();
  }
};
CR__AudioAllocRawExt2.callback = function (cb, asParam, strParams) {

  console.log(asParam)
  if (asParam.shareListen) {
    //如果为true就不上报自己的信息
    window.remoteaudio_cb = cb;
    initRemotAudio();
  } else {
    //如果为false，就上报自己的信息
    window.myaudio_cb = cb;
    setupAudioPeerConnection(window.audioStream)
  }
}
CR__ModifyPeerAddrExt.callback = function (MSID, strParams) {
  console.log("CR__ModifyPeerAddrExt: " + MSID + ' ' + strParams.get('sdp'));
  var answer = {
    type: 'answer',
    sdp: strParams.get('sdp')
  }
  if (0 == MSID) {
    window.localSdp = answer;
  } else if (1 == MSID) {
    answer.sdp = answer.sdp.replace("a=sendrecv", "a=sendonly");
    window.pcVideoRemote.setRemoteDescription(new RTCSessionDescription(answer)).then(function () {
      console.log("set remote video answer ok");
    }, function (err) {
      console.log("set remote video answer desc fail" + err);
    })
  } else if (2 == MSID) {
    window.myAudioConnection.setRemoteDescription(new RTCSessionDescription(answer));
  } else if (3 == MSID) {
    window.pcAudioRemote.setRemoteDescription(new RTCSessionDescription(answer)).then(function () {
      console.log("set remote audio answer ok");
    }, function (err) {
      console.log("set remote audio answer desc fail" + err);
    });
  }
}
// 设置及请求RTCpeerconnection
function initRemotVideo() {
  window.pcVideoRemote = new RTCPeerConnection(CRVideo.configuration);
  var offerOptions = {
    offerToReceiveAudio: false,
    offerToReceiveVideo: true,
    voiceActivityDetection: false
  };
  window.pcVideoRemote.createOffer(function (offer) {
    offer.sdp = offer.sdp.replace("c=IN IP4 0.0.0.0", "c=IN IP4 0.0.0.0\r\nb=AS:512");
    window.remoteVideoOffer = offer
    window.pcVideoRemote.setLocalDescription(offer);
  }, function (error) {
    console.log("An error has occurred.");
  }, offerOptions);

  window.pcVideoRemote.onaddstream = function (e) {
    CRVideo.remoteinfo.stream = e.stream;
    console.log("mainVideo："+e.stream);
    if (document.getElementById('video' + 　CRVideo.remoteinfo.userID)) {
      document.getElementById('video' + 　CRVideo.remoteinfo.userID).srcObject = e.stream;
    }
  };
  var candidates = [];
  var isFirt = 0;
  window.pcVideoRemote.onicecandidate = function (event) {
    if (event.candidate) {
      if (!isFirt) {
        var ip = event.candidate.candidate.split(' ')[4];
        var comp_id = event.candidate.candidate.split(' ')[1];
        if (ip && comp_id == '1' && ip.length <= 15 && !ip.match('10\\.') && !ip.match('172\\.') && !ip.match('192\\.') && !ip.match('169\\.254\\.')) {
          candidates.push(event.candidate);
          console.log("ICE GATHERING NOT COMPLETED, BUT HAVE NOT NAT IP ADDRESS!");
          CRVideo.remoteVideoMsid = 1;
          candidates = JSON.stringify(candidates);
          console.log("pcVideoRemote--candidates："+candidates)
          var params = new Ice.HashMap();
          params.set('sdp', window.remoteVideoOffer.sdp);
          params.set('icecandidate', candidates);
          window.remotevideo_cb.ice_response(CRVideo.remoteVideoMsid, params);
          isFirt = 1;

        }
      }

    }
  };
};
// 设置及请求远端的音频信息RTCpeerconnection
function initRemotAudio() {
  window.pcAudioRemote = new RTCPeerConnection(CRVideo.configuration);
  window.pcAudioRemote.createOffer(function (offer) {
    window.remoteAudioOffer = offer
    window.pcAudioRemote.setLocalDescription(offer);
  }, function (error) {
    console.log("An error has occurred.");
  });
  window.pcAudioRemote.onaddstream = function (e) {
    console.log("mainAudio："+e.stream)
    document.getElementById('mainAudio').srcObject = e.stream;
  };
  var candidates = [];
  var isFirt = 0;
  window.pcAudioRemote.onicecandidate = function (event) {
    if (event.candidate) {
      if (!isFirt) {
        var ip = event.candidate.candidate.split(' ')[4];
        var comp_id = event.candidate.candidate.split(' ')[1];
        // candidates.push(event.candidate);
        if (ip && comp_id == '1' && ip.length <= 15 && !ip.match('10\\.') && !ip.match('172\\.') && !ip.match('192\\.') && !ip.match('169\\.254\\.')) {
          candidates.push(event.candidate);
          console.log("ICE GATHERING NOT COMPLETED, BUT HAVE NOT NAT IP ADDRESS!");
          CRVideo.remoteAudioMsid = 3;
          candidates = JSON.stringify(candidates);
          console.log("pcVideoRemote--candidates："+candidates)
          var params = new Ice.HashMap();
          params.set('sdp', window.remoteAudioOffer.sdp);
          params.set('icecandidate', candidates);
          window.remoteaudio_cb.ice_response(CRVideo.remoteAudioMsid, params);
          isFirt = 1;
        }
      }

    }
  };
};

function getCamereInfo() {
  console.log("CR__UpdateAllCameraInfos---"+"1;WebCam;0;0\n");
  CR__UpdateAllCameraInfos("1;WebCam;0;0\n")
  CR__SetOpenedCameraNumber([1, 1]);
}


function openAndChangeVideoDevices(constraints){
    if(window.videoStream){
        CRVideo_UpdateVideoRate();
    }
    navigator.mediaDevices.getUserMedia(constraints).then(function(myStream) {
       console.log("myVideostream--:",myStream)
       if(document.getElementById('video' +  CRVideo.userinfo.userID)){
           document.getElementById('video' +  CRVideo.userinfo.userID).srcObject = myStream;
       }
       CR__SetVideoDeviceStatus(true);
       window.videoStream = myStream;
       CRVideo.userinfo.stream = myStream;
       window.videotrack = myStream.getVideoTracks()[0];
        if (CRVideo.isPlantForm()) { //qq下报错
            window.capabilities = myStream.getVideoTracks()[0].getCapabilities();
        }
       CRVideo.isMyVideoStream = true;
       window.myVideoName = CRVideo.meetingInfo.myDetail.nickname;
       myStream.oninactive = function() {
          console.log('Stream inactive');
        };
        getCamereInfo();
        console.log("CRVideo_OpenVideo",window.videotrack);
        return navigator.mediaDevices.enumerateDevices();
    }).then(function(deviceInfos) {
        console.log('===deviceInfos===: ',deviceInfos);
        CRVideo.getDevicesMedia(deviceInfos);
    }).catch(function(error){
        if(CRVideo.videotrack && CRVideo.videotrack.id && CRVideo.videotrack.id != ""){
            window.videoConstraints = {video: {width:{exact:640},aspectRatio: {exact: 16 / 9},frameRate: {ideal: 20,max: 20},deviceId:{exact: CRVideo.videotrack.id}},audio: false};
        }else{
            window.videoConstraints = {video: {width:{exact:640},aspectRatio: {exact: 16 / 9},frameRate: {ideal: 20,max: 20}},audio: false};
        }
        console.log(window.videoConstraints)
        CRVideo.maxBps ="350";
        CRVideo_SetDefaultVideo(CRVideo.userinfo.userID,CRVideo.videotrack.id)
        //openAndChangeVideoDevices(window.videoConstraints);
    });
}


/*
  // ---未修改前代码--
  function openAndChangeVideoDevices(constraints) {
    navigator.mediaDevices.getUserMedia({"video":true}).then(function (myStream) {
      console.log("myVideostream--："+ myStream)

      window.videoStream = myStream;
      CRVideo.userinfo.stream = myStream;
      window.videotrack = myStream.getVideoTracks()[0];
      console.log("Using video device："+ window.videotrack.label);
      window.myVideoName = CRVideo.meetingInfo.myDetail.nickname;

      window.videotrack.applyConstraints(constraints).then().catch();
      
      if (document.getElementById('video' + CRVideo.userinfo.userID)) {
        document.getElementById('video' + CRVideo.userinfo.userID).srcObject = myStream;
      }
      CR__SetVideoDeviceStatus(true);
      myStream.oninactive = function () {
        console.log('Stream inactive');
      };
      getCamereInfo();
      console.log("CRVideo_OpenVideo："+window.videotrack);
      var videoname = {
        name: window.videotrack.label,
        id: window.videotrack.deviceId
      }
      CRVideo.videoInput.push(videoname);
      return navigator.mediaDevices.enumerateDevices();
    }).then(function (deviceInfos) {
      console.log(deviceInfos);
      CRVideo.getDevicesMedia(deviceInfos);
    }).catch(function (error) {
      CR__SetVideoDeviceStatus(false);
      console.log(error);
      if (error.name == "OverconstrainedError") {
        alert("当前设备不支持" + error.constraint);
      } else if (error.name == "AbortError") {
        alert("硬件异常");
      } else if (error.name == "NotAllowedError") {
        alert("拒绝错误");
      } else if (error.name == "NotFoundError") {
        alert("找不到满足请求参数的媒体类型");
      } else if (error.name == "NotReadableError") {
        alert("无法读取硬件");
      } else if (error.name == "SecurityError") {
        alert("安全错误")
      } else if (error.name == "TypeError") {
        alert("对象未设置")
      }
    });
  }
*/


function openAndChangeAudioDevices(constraints) {
  navigator.mediaDevices.getUserMedia(constraints).then(function (myStream) {
    console.log("localAudio--：" +myStream)
    CR__SetAudioDeviceStatus(true);

    window.audiotrack = myStream.getAudioTracks()[0];
    var constraints = window.audiotrack.getConstraints();
    console.log('Result constraints: ' + JSON.stringify(constraints));
    $("#mic_select").val(window.audiotrack.label)

    console.log('Using audio device: ' + window.audiotrack.label);
    myStream.oninactive = function () {
      console.log('Stream inactive');
    };
    window.audioStream = myStream;
    var auduoSource = {
      name: window.audiotrack.label,
      id: window.audiotrack.deviceId
    }
    CRVideo.audioInput.push(auduoSource);
    return navigator.mediaDevices.enumerateDevices();
  }).then(function (deviceInfos) {
    console.log(deviceInfos);
    CRVideo.getDevicesMedia(deviceInfos);
  }).catch(function (error) {
    CR__SetAudioDeviceStatus(false);
    console.log(error)
    if (error.name == "OverconstrainedError") {
      alert("当前设备不支持" + error.constraint);
    } else if (error.name == "AbortError") {
      alert("硬件异常");
    } else if (error.name == "NotAllowedError") {
      alert("拒绝错误");
    } else if (error.name == "NotFoundError") {
      alert("找不到满足请求参数的媒体类型");
    } else if (error.name == "NotReadableError") {
      alert("无法读取硬件");
    } else if (error.name == "SecurityError") {
      alert("安全错误")
    } else if (error.name == "TypeError") {
      alert("对象未设置")
    }
  });
}


CR__UpdateAllCameraInfosRslt.callback = function (error, dec) {
  error = error == 0 ? "成功" : "失败"
  console.log("CR__UpdateAllCameraInfos："+ error)
}
CR__SetOpenedCameraNumberRslt.callback = function (error, dec) {
  error = error == 0 ? "成功" : "失败"
  console.log("CR__SetOpenedCameraNumberRslt："+ error);
  CR__StartVideo();
}
CR__StartVideoRslt.callback = function (error, dec) {
  error = error == 0 ? "成功" : "失败"
  console.log("CR__StartVideoRslt："+ error)
}

//禁止终端上传视频到公网(ACCESS)
CR__DisableSendVideo2Internet.callback = function (cameraID) {
  console.log("CR__DisableSendVideo2Internet："+ cameraID)
}
//允许终端上传视频到公网(ACCESS)
CR__EnableSendVideo2Internet.callback = function (cameraID) {
  console.log("CR__EnableSendVideo2Internet："+ cameraID +' '+ window.localSdp);
  window.myVideoConnection.setRemoteDescription(new RTCSessionDescription(window.localSdp));

}
CR__NotifySetOpenedCameraNumber.callback = function (termId, carmId) {
  console.log("CR__NotifySetOpenedCameraNumber："+ termId+' '+ carmId)
  if (CRVideo.userinfo.termId != termId) {
    CR__BatchSubscribeVideo2(termId, carmId[0], 2);
  }
}
CR__BatchSubscribeVideo2Rslt.callback = function (errCode, errDesc) {
  console.log(errCode)
}
CRVideo_UserEnter.callback = function (args) {
  console.log(args);
  var userleftName = "";
  if (args.termId != CRVideo.userinfo.termId) {
    CRVideo.remoteinfo.nickname = args.nickname;
    CRVideo.remoteinfo.termId = args.termId;
  }
  CRVideo_UserEnterMeeting.callback(args.nickname);
};
CR__UserLeftMeet.callback = function (id, reson) {
  var userleftName = "";
  if (id == CRVideo.userinfo.termId) {
    userleftName = CRVideo.userinfo.nickname
  } else if (id == CRVideo.remoteinfo.termId) {
    userleftName = CRVideo.remoteinfo.nickname
  }
  CRVideo_UserLeftMeeting.callback(userleftName);
  console.log(userleftName + "离线，离线原因：" + reson);
}
CRVideo_ExitMeeting = function () {
  //关闭自己的摄像头
  CR__StopVideo();
  CR__CloseMicEx(CRVideo.userinfo.termId);
  if(window.videotrack){
     window.videotrack.stop();
  }
  if(window.audiotrack){
     window.audiotrack.stop();
  }
 
  if(window.myVideoConnection){
    window.myVideoConnection.close();
    window.myVideoConnection = null;
  }
  
  window.audioStream = "";
  window.videoStream = "";
  window.myVideoName = "";
  if(window.pcVideoRemote){
      window.pcVideoRemote.close();
    window.pcVideoRemote = null;
  }

  window.localVideoOffer = "";
  if(window.myAudioConnection){
     window.myAudioConnection.close();
     window.myAudioConnection = null;
  }
 
  window.localAudioOffer = "";
  if (window.pcAudioRemote) {
    window.pcAudioRemote.close();
    window.pcAudioRemote = null;
  }

  window.remoteAudioOffer = null;
  window.remoteaudio_cb = null;
  window.myvideo_cb = null;

  window.remoteaudio_cb = null;

  window.myaudio_cb = null;


  clearTimeout(CRVideo.KEEPALIVE_TIMER);
  CRVideo.KEEPALIVE_TIMER = -1;
  clearTimeout(CRVideo.REFRESH_SESSION)
  CRVideo.REFRESH_SESSION = -1;
  $("video").remove();
  $("audio").remove();
  $(".CRVideo_VideoObj").remove();
  CR__Exit("退出会议");
}
CR__ExitRslt.callback = function (errCode, errDesc) {
  console.log("CR__ExitRslt："+errCode);
  CR__UnInit();
}
//媒体流被释放
CR__Free.callback = function (msId) {
  //某一种流被释放了
  console.log({"===msid===":msId});
  if (msId == CRVideo.myAudioMsid) {

  } else if (msId == CRVideo.remoteAudioMsid) {

  } else if (msId == CRVideo.myVideoMsid) {
    document.getElementById('video' + CRVideo.userinfo.userID).src = "";
  } else if (msId == CRVideo.remoteVideoMsid) {
    document.getElementById('video' + CRVideo.remoteinfo.userID).src = "";
  }
}
CR__AskForMicRslt.callback = function (errCode, errDesc) {
  console.log("CR__AskForMicRslt："+errCode);
  CR__OpenMicEx(CRVideo.userinfo.termId)
}
CR__StopVideoRslt.callback = function (errCode, errDesc) {
  console.log("CR__StopVideoRslt："+ errCode)
}
CR__CloseMicExRslt.callback = function (errCode, errDesc) {
  console.log("CR__CloseMicExRslt："+errCode)
}
CR__GetActiveMembersRslt.callback = function (errCode, errDesc, data) {
  console.log("CR__GetActiveMembersRsltdata："+ data);
  if (errCode == 0) {
    for (var i = 0; i < data.length; i++) {
      if (data[i].openedCamIDs != undefined && data[i].termId != CRVideo.userinfo.termId) {
        CR__BatchSubscribeVideo2(data[i].termId, data[i].openedCamIDs, 2);
      }
      if (data[i].termId != CRVideo.userinfo.termId) {
        CRVideo.remoteinfo.termId = data[i].termId;
        CRVideo.remoteinfo.nickname = data[i].nickname;
        CRVideo.remoteinfo.audioStatus = data[i].audioStatus;
        CRVideo.remoteinfo.videoStatus = data[i].videoStatus;
      } else {
        CRVideo.userinfo.audioStatus = data[i].audioStatus;
        CRVideo.userinfo.videoStatus = data[i].videoStatus;
      }
    }
  };
};
//获取指定用户的用户信息
function CRVideo_GetMemberInfo(userID) {
  var thisMember;
  if (userID == CRVideo.remoteinfo.userID) {
    thisMember = CRVideo.remoteinfo.userID;
  } else {
    thisMember = CRVideo.userinfo.userID;
  }
  return thisMember;
}

function CRVideo_GetAllMembers() {
  var allMember = [];
  allMember.push(CRVideo.userinfo);
  allMember.push(CRVideo.remoteinfo);
  return allMember;
}
// 设置视频参数
function CRVideo_SetVideoCfg(cfg) {
  var sizeType = cfg.sizeType ? cfg.sizeType : 8;
  var frameRateFps = cfg.fps ? cfg.fps : 15;
  if(CRVideo.isMyVideoStream && window.capabilities.width){
    if(window.capabilities.width.max < CRVideo.sizeTypeArry[sizeType][0] || window.capabilities.height.max < CRVideo.sizeTypeArry[sizeType][1]){
      alert("此设备不支持"); 
      return;
    }
  }
  if(CRVideo.videotrack && CRVideo.videotrack.id && CRVideo.videotrack.id != ""){
    window.videoConstraints = {video: {width:{exact:CRVideo.sizeTypeArry[sizeType][0]},aspectRatio: {exact: 16 / 9},frameRate: {ideal: frameRateFps,max: 20}, deviceId:{exact: CRVideo.videotrack.id}},audio: false};
  }else{
    window.videoConstraints = {video: {width:{exact:CRVideo.sizeTypeArry[sizeType][0]},aspectRatio: {exact: 16 / 9},frameRate: {ideal: frameRateFps,max: 20}},audio: false};

  }
  if (window.videoStream) {
    window.videoStream.getTracks().forEach(function (track) {
      track.stop();
      // CR__StopVideo();
    });
    
  };
  cfg.maxbps = (cfg.maxbps == 1000) ? 1024 : cfg.maxbps;
  cfg.maxbps = (cfg.maxbps == 2000) ? 2048 : cfg.maxbps;
  CRVideo.maxBps = cfg.maxbps ? cfg.maxbps : "512";
  openAndChangeVideoDevices(window.videoConstraints);
  
  var supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
  console.log(supportedConstraints)
};

//选择视频设备时的设置函数
function CRVideo_SetDefaultVideo(termID, camID) {
  var videoId = "";
  for (var i = 0; i < CRVideo.videoInput.length; i++) {
    if (camID == CRVideo.videoInput[i].id) {
      videoId = CRVideo.videoInput[i].id;
      CRVideo.videotrack =  CRVideo.videoInput[i];
      console.log( CRVideo.videoInput[i])
    }
  }
  var sizeType = 8;
  var frameRateFps = 30;
  if(CRVideo.videotrack && CRVideo.videotrack.id && CRVideo.videotrack.id != ""){
    window.videoConstraints = {video: {width:{exact:CRVideo.sizeTypeArry[sizeType][0]}, height: {exact: CRVideo.sizeTypeArry[sizeType][1]},aspectRatio: {exact: 16 / 9},frameRate: {ideal: frameRateFps,max: 20}, deviceId:{exact: CRVideo.videotrack.id}},audio: false};
  }else{
    window.videoConstraints = {video: {width:{exact:CRVideo.sizeTypeArry[sizeType][0]}, height: {exact: CRVideo.sizeTypeArry[sizeType][1]},aspectRatio: {exact: 16 / 9},frameRate: {ideal: frameRateFps,max: 20}},audio: false};

  }
  // window.videoConstraints = {
  //   video: {
  //     width: {
  //       exact: CRVideo.sizeTypeArry[sizeType][0]
  //     },
  //     height: {
  //       exact: CRVideo.sizeTypeArry[sizeType][1]
  //     },
  //     aspectRatio: {
  //       exact: 16 / 9
  //     },
  //     frameRate: {
  //       ideal: frameRateFps,
  //       max: 20
  //     },
  //     deviceId: videoId ? {
  //       exact: videoId
  //     } : undefined
  //   },
  //   audio: false
  // };
  if (window.videoStream) {
    window.videoStream.getTracks().forEach(function (track) {
      track.stop();
    });
  };
  CRVideo.maxBps ="350";
  openAndChangeVideoDevices(window.videoConstraints);
}
var CRVideo_SetAudioCfg = function (cfg) {
  console.log(cfg);
  //当选择不同的麦克风奇迹扬声器时调用的方法
  //cfg.micName     cfg.speakerName
  var audioSource, sinkId;
  var outputElement = document.getElementById('mainAudio');
  for (var i = 0; i < CRVideo.audioInput.length; i++) {
    if (cfg.micName == CRVideo.audioInput[i].name) {
      audioSource = CRVideo.audioInput[i].id
    }
  }
  for (var i = 0; i < CRVideo.audioOutput.length; i++) {
    if (cfg.speakerName == CRVideo.audioOutput[i].name) {
      sinkId = CRVideo.audioOutput[i].id;
    }
  }
  window.audioConstraints = {
    video: false,
    audio: {
      deviceId: audioSource ? {
        exact: audioSource
      } : undefined
    },
  };
  if (window.audioStream) {
    window.audioStream.getTracks().forEach(function (track) {
      track.stop();
    });
  };
  openAndChangeAudioDevices(window.audioConstraints);
  outputElement.setSinkId(sinkId).then(function () {
    console.log('Success, audio output device attached: ' + sinkId);
  }).catch(function (error) {
    var errorMessage = error;
    if (error.name === 'SecurityError') {
      errorMessage = 'You need to use HTTPS for selecting audio output ' +
        'device: ' + error;
    }
    console.error(errorMessage);
  });

}
//获取视频摄像头信息
function CRVideo_GetVideoStatus(id) {
  //0摄像头状态未知    1没有摄像头设备   2摄像头处于关闭状态   3摄像头处于打开状态   4 向服务器发送打开消息中
  var VideoStatusMark = 0;
  if (window.videoStream) {
    var VideoStatus = window.videoStream.getVideoTracks()[0].readyState;
    //该值有 live ended new三种状态
    console.log(VideoStatus);
    if (VideoStatus == "live") {
      VideoStatusMark = 1;
    } else if (VideoStatus == "ended") {
      //结束及关闭
      VideoStatusMark = 2;
    } else {
      VideoStatusMark = 0;
    }
  } else {
    VideoStatusMark = 0;
  }
  return VideoStatusMark;
}
//获取麦克风信息
function CRVideo_GetAudioStatus(id) {
  var audioStatusMark = 0;
  if (window.audioStream) {
    var audioStatus = window.audioStream.getAudioTracks()[0].readyState;
    //该值有 live ended new三种状态
    console.log(audioStatus);
    if (audioStatus == "live") {
      //可用
      audioStatusMark = 1;
    } else if (audioStatus == "ended") {
      //结束及关闭
      audioStatusMark = 2;
    } else {
      audioStatusMark = 0;
    }
  } else {
    audioStatusMark = 0;
  }
  return audioStatusMark;

}
//设备支持哪些属性
/**********************************************获取会议成员信息  接口 ******************************************************/
//获取某用户的昵称
function CRVideo_GetMemberNickName(userId) {
  if (userId == CRVideo.userinfo.userID) {
    return CRVideo.userinfo.nickname;
  } else if (userId == CRVideo.remoteinfo.userID) {
    return CRVideo.userinfo.nickname;
  }
}
//判断某用户是否在会议中
function CRVideo_IsUserInMeeting(userId) {
  if (userId == CRVideo.remoteinfo.userID || userId == CRVideo.userinfo.userID) {
    return true;
  } else {
    return false;
  }
}
//获取默认摄像头信息
function CRVideo_GetDefaultVideo(userId){
  return 1;
}
/*******************************************************  云端录制功能相关 ***************************************************/
//云端录制状态变化
CR__NotifySvrRecordStateChanged.callback = function(a,b,c,d){
  console.log("CR__NotifySvrRecordStateChanged")
}
// 云端录制参数变化
CR__NotifySvrRecordCfgChanged.callback = function(a,b,c){
  console.log("CR__NotifySvrRecordCfgChanged")
}
// 开始云端录制 回调
CR__StartSvrRecordRslt.callback = function(errCode,errDesc){
  console.log("CR__StartSvrRecordRslt",errCode)
}

// 更新云端录制信息回调
CR__UpdateSvrRecCfgRslt.callback= function(errCode,errDesc){
  console.log("CR__UpdateSvrRecCfgRslt",errCode)
}
// 停止云端录制信息回调
CR__StopSvrRecordRslt.callback= function(errCode,errDesc){
  console.log("CR__StopSvrRecordRslt",errCode)
}
// 开始云端录制
var CRVideo_StartSvrRecording = function(recordCfgObj, recordContentsArr){
  var recCfg = {};
  recCfg["fileName"] = recordCfgObj.filePathName;
  recCfg["dstResolutionWidth"] = recordCfgObj.recordWidth;
  recCfg["dstResolutionHeight"] = recordCfgObj.recordHeight;
  recCfg["fps"] = recordCfgObj.frameRate;
  recCfg["maxBPS"] = recordCfgObj.bitRate;
  recCfg["qp"] = recordCfgObj.defaultQP;
  recCfg["isUploadOnRecording"] = true;
  recCfg["serverPathFileName"] = recordCfgObj.serverPathFileName;
  recordContentsArr.forEach(function (item) {
    if(item["type"] == 4){
      item["param"] = {};
      item.param.bgcolor = null;
      item.param.prefixtext = null;
      item.param.resourceid = "7865e862-67ef-4ae6-b6d8-1286220c03ab";
      item.param.textcolor = null;
    }
    if(item["type"] == 0){
      var camid = item.param.camid;
      var userid = CRVideo.userinfo.userID;
      var remoteid = CRVideo.remoteinfo.userID;
      if(camid.indexOf(userid) > -1){
        item.param = {};
        item.param.camId = +camid.substr(userid.length + 1);
        item.param.termId = CRVideo.userinfo.termId;
      }else if(camid.indexOf(remoteid) > -1){
        item.param = {};
        item.param.camId = +camid.substr(remoteid.length + 1);
        item.param.termId = CRVideo.remoteinfo.termId;
      }
    }
  })
  var jsonCfg = {};
  jsonCfg["clientType"] = 1;
  jsonCfg["contents"] = recordContentsArr;
  jsonCfg["recCfg"] = recCfg;
  CRVideo.svr_recJsonCfg = jsonCfg;
  CR__StartSvrRecord(JSON.stringify(jsonCfg))
}
//结束云端录制
var CRVideo_StopRecord = function(){
  CR__StopSvrRecord();
}
//更新云端录制状态
var CRVideo_UpdateSvrRecordContents = function(newContents){
  newContents.forEach(function (item) {
    if(item["type"] == 4){
      item["param"] = {};
      item.param.bgcolor = null;
      item.param.prefixtext = null;
      item.param.resourceid = "7865e862-67ef-4ae6-b6d8-1286220c03ab";
      item.param.textcolor = null;
    }
    if(item["type"] == 0){
      var camid = item.param.camid;
      var userid = CRVideo.userinfo.userID;
      var remoteid = CRVideo.remoteinfo.userID;
      if(camid.indexOf(userid) > -1){
        item.param = {};
        item.param.camId = +camid.substr(userid.length + 1);
        item.param.termId = CRVideo.userinfo.termId;
      }else if(camid.indexOf(remoteid) > -1){
        item.param = {};
        item.param.camId = +camid.substr(remoteid.length + 1);
        item.param.termId = CRVideo.remoteinfo.termId;
      }
    }
  })
  var jsonCfg = CRVideo.svr_recJsonCfg;
  jsonCfg["contents"] = newContents;
  CR__UpdateSvrRecCfg(JSON.stringify(jsonCfg))
}
/**
 * Created by admin on 2018/4/20.
 */
CRVideo.isUploadLog = 1 ; //是否开启上传日志，1 为开启，0 为不开启
CRVideo.logAry = [] ; //所有日志保存全局变量
CRVideo.browserInfo ='' ;//浏览器信息
function sdkDebug() {
    var self = this;

    // OPTIONS
    self.num = 0 ;
    self.logFilename = 'sdkDebug.log'; // filename of log downloaded with downloadLog()

    self.output = '';
    /*
     USER METHODS
     */
    this.getLog = function() {
        return self.output ;
    };
    this.clear = function(){
        self.output = '';
    };
    // immediately downloads the log - for desktop browser use
    this.downloadLog = function() {
        var file = "data:text/plain;charset=utf-8,";
        var logFile = self.getLog();
        var encoded = encodeURIComponent(logFile);
        file += encoded;
        var a = document.createElement('a');
        a.href = file;
        a.target   = '_blank';
        a.download = self.logFilename;
        document.body.appendChild(a);
        a.click();
        a.remove();
    }
    // records a log
    this.log = function(obj,type,module) {
        // log in real time
        var dataLog ='';
        var type = type || 'INF' ;
        var module = module || '--';
        if(obj != null){
            if(typeof object =='object'){
                var addition = JSON.stringify(obj);
            }else{
                var addition = obj;
            }
        }
        var logTime = new Date();
        dataLog += self.formatTimestamp(logTime);
        dataLog += '['+ type+'] ';
        dataLog += '['+ module+':'+ self.num +'] ';
        dataLog += addition ;
        // if(type == 'INF'){
        //     console.log(dataLog);
        // }else if(type =='DUG '){
        //     console.trace(dataLog);
        // }else if(type =='WAR'){
        //     console.warn(dataLog);
        // }else if(type == 'ERR'){
        //     console.error(dataLog)
        // }
        self.output += dataLog +'\n';
        self.num ++ ;
        if(self.num == 256){
            self.num = 0;
        }
        if((self.output.length / 1024 ).toFixed(2) > 500){ //如果大于500Kb
            alert('日志大于1M,请查后台日志是否大于1M');
            CRVideo_UploadingLog();//直接日志上报调用
        }
        //window.localStorage.setItem('sdkLog', self.output);
    };
    // calculate testing time
    this.formatTimestamp = function(timestamp) {
        var year = timestamp.getFullYear();
        var date = timestamp.getDate();
        var month = ('0' + (timestamp.getMonth() +1)).slice(-2);
        var hrs = Number(timestamp.getHours());
        var mins = ('0' + timestamp.getMinutes()).slice(-2);
        var secs = ('0' + timestamp.getSeconds()).slice(-2);
        return '['+ year + '-' + month + '-' + date + ' ' + hrs + ':' + mins + ':'+secs + '] ';
    };
}
console.oldLog = console.log;
var sdkLog = new sdkDebug;
console.log = function(str,type,module) {
    console.oldLog(str);
    sdkLog.log(str,type,module);
};
CRVideo.browserInfo = getBrowser();
console.log('浏览器信息'+CRVideo.browserInfo);
//设置是否开启日志
CRVideo_EnableLog2File = function(bEnable){
    CRVideo.isUploadLog = bEnable ;
};
//开始向服务器上报存储在本地的日志
CRVideo_StartLogReport = function(reporter,servers){
    CRVideo.isUploadLog = 1 ;
    CRVideo.logServer = servers ;
    CRVideo_UploadingReport()
};
//停止向服务器上报本地日志
CRVideo_StopLogReport = function(){
    CRVideo.isUploadLog = 0 ;
};
//定时日志上报
CRVideo_UploadingReport = function(reporter){
    setTimeout(function(){
        CRVideo_UploadingLog(reporter);//直接日志上报调用
        CRVideo_UploadingReport();
    },2*60*1000)
};
//直接日志上报调用
CRVideo_UploadingLog = function(reporter,logInfo){
    //当日志够256行，也要释放变量
    var allLogStr = sdkLog.getLog();
    if(logInfo){
       allLogStr += logInfo.type+':'+ logInfo.info
    }
    sdkLog.clear();//把数据清空
    if(CRVideo.isUploadLog == 0){
        return;
    }
    var date = new Date();
    var m = date.getMonth() + 1;
    m = m < 10 ? ('0' + m) : m;
    var d = date.getDate();
    d = d < 10 ? ('0' + d) : d;
    var useName = CRVideo.LoginParam.user_id ;
    var reporterName =useName;
    if(useName.length > 4){
        reporterName = useName.slice(-4);
    }
    if(reporter){
        reporterName = reporter ;
    }
    var fileName = CRVideo.LoginParam.account +'/'+reporterName+'/'+ CRVideo.LoginParam.user_id +'_'+CRVideo.logUUID +'_webrtc_'+ CRVideo.browserInfo +'_'+ m + d +'.log' ;

    var ut8ary = new TextEncoder("utf-8").encode(allLogStr);
    var deflate = new Zlib.Deflate(ut8ary);
    var compressed = deflate.compress();
    CRVideo.webLogDetail(0,fileName,compressed);
};
//监听报错时日志上传
/**
 * @param {String}  errorMessage   错误信息
 * @param {String}  scriptURI      出错的文件
 * @param {Long}    lineNumber     出错代码的行号
 * @param {Long}    columnNumber   出错代码的列号
 * @param {Object}  errorObj       错误的详细信息，Anything
 */
window.onerror = function(errorMessage, scriptURI, lineNumber,columnNumber,errorObj) {
    var err = '\n出错的文件：'+ scriptURI;
        err += '\n出错的代码行号：'+ lineNumber ;
        err += '\n错误的详细信息：'+ errorObj ;
    var logInfo = {type:'Error',info:err};
    CRVideo_UploadingLog('',logInfo);
};
function getBrowser(){
    var system = '';
    if(!!navigator.userAgent.match(/AppleWebKit.*Mobile.*/)){
        if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {
            system ='ios';
            //苹果端
        } else if (/(Android)/i.test(navigator.userAgent)) {
            system ='android';
            //安卓端
        }else{
            system ='mobile';
        }
        var ua = navigator.userAgent.toLowerCase();//获取判断用的对象
        if (ua.match(/MicroMessenger/i) == "micromessenger") {
            //在微信中打开
            return system +'_WX' ;
        }else if (ua.match(/QQ/i) == "qq") {
            //在QQ空间打开
           return system+'_qq' ;
        }else if(ua.indexOf("liebao") > 0){
            return system+'_leibao';
        }else if(ua.match(/ubrowser/) != null){
            return system +'_uc';
        }else if(ua.indexOf("chrome") > 0 || ua.indexOf("crios") > 0){
            return system +'_chrome';
        }else if(ua.indexOf("safari") > 0){
            return system +'_safari';
        }
    }else {
        //pc端
        //否则就是PC浏览器
        var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
        var isOpera = userAgent.indexOf("Opera") > -1; //判断是否Opera浏览器
        var isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera; //判断是否IE浏览器
        var isFF = userAgent.indexOf("Firefox") > -1; //判断是否Firefox浏览器
        var isSafari = userAgent.indexOf("Safari") > -1; //判断是否Safari浏览器
        var isChrome = userAgent.indexOf("Chrome") > -1; //判断是否Chrome浏览器或者360浏览器
        if (isFF) {
            return "PC_FF" ;
        } else if (isOpera) {
            return "PC_Opera" ;
        }else if (isChrome) {
            var is360 = _mime("type", "application/vnd.chromium.remoting-viewer");
            function _mime(option, value) {
                var mimeTypes = navigator.mimeTypes;
                for (var mt in mimeTypes) {
                    if (mimeTypes[mt][option] == value) {
                        return true;
                    }
                }
                return false;
            }
            if(is360) {
                return "PC_360" ;
            }else{
                return "pc_chrome";
            }
        }else if(isSafari){
           return "PC_Safari";

        }else if(isIE) {//判断是否IE浏览器
            return "IE";
        }
    }
}
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';function m(d){throw d;}var w=void 0,z=!0,aa=this;function A(d,a){var c=d.split("."),e=aa;!(c[0]in e)&&e.execScript&&e.execScript("var "+c[0]);for(var b;c.length&&(b=c.shift());)!c.length&&a!==w?e[b]=a:e=e[b]?e[b]:e[b]={}};var G="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function I(d,a){this.index="number"===typeof a?a:0;this.i=0;this.buffer=d instanceof(G?Uint8Array:Array)?d:new (G?Uint8Array:Array)(32768);2*this.buffer.length<=this.index&&m(Error("invalid index"));this.buffer.length<=this.index&&this.f()}I.prototype.f=function(){var d=this.buffer,a,c=d.length,e=new (G?Uint8Array:Array)(c<<1);if(G)e.set(d);else for(a=0;a<c;++a)e[a]=d[a];return this.buffer=e};
I.prototype.d=function(d,a,c){var e=this.buffer,b=this.index,f=this.i,g=e[b],h;c&&1<a&&(d=8<a?(Q[d&255]<<24|Q[d>>>8&255]<<16|Q[d>>>16&255]<<8|Q[d>>>24&255])>>32-a:Q[d]>>8-a);if(8>a+f)g=g<<a|d,f+=a;else for(h=0;h<a;++h)g=g<<1|d>>a-h-1&1,8===++f&&(f=0,e[b++]=Q[g],g=0,b===e.length&&(e=this.f()));e[b]=g;this.buffer=e;this.i=f;this.index=b};I.prototype.finish=function(){var d=this.buffer,a=this.index,c;0<this.i&&(d[a]<<=8-this.i,d[a]=Q[d[a]],a++);G?c=d.subarray(0,a):(d.length=a,c=d);return c};
var ba=new (G?Uint8Array:Array)(256),ca;for(ca=0;256>ca;++ca){for(var R=ca,ha=R,ia=7,R=R>>>1;R;R>>>=1)ha<<=1,ha|=R&1,--ia;ba[ca]=(ha<<ia&255)>>>0}var Q=ba;function ja(d){this.buffer=new (G?Uint16Array:Array)(2*d);this.length=0}ja.prototype.getParent=function(d){return 2*((d-2)/4|0)};ja.prototype.push=function(d,a){var c,e,b=this.buffer,f;c=this.length;b[this.length++]=a;for(b[this.length++]=d;0<c;)if(e=this.getParent(c),b[c]>b[e])f=b[c],b[c]=b[e],b[e]=f,f=b[c+1],b[c+1]=b[e+1],b[e+1]=f,c=e;else break;return this.length};
ja.prototype.pop=function(){var d,a,c=this.buffer,e,b,f;a=c[0];d=c[1];this.length-=2;c[0]=c[this.length];c[1]=c[this.length+1];for(f=0;;){b=2*f+2;if(b>=this.length)break;b+2<this.length&&c[b+2]>c[b]&&(b+=2);if(c[b]>c[f])e=c[f],c[f]=c[b],c[b]=e,e=c[f+1],c[f+1]=c[b+1],c[b+1]=e;else break;f=b}return{index:d,value:a,length:this.length}};function S(d){var a=d.length,c=0,e=Number.POSITIVE_INFINITY,b,f,g,h,k,p,q,r,n,l;for(r=0;r<a;++r)d[r]>c&&(c=d[r]),d[r]<e&&(e=d[r]);b=1<<c;f=new (G?Uint32Array:Array)(b);g=1;h=0;for(k=2;g<=c;){for(r=0;r<a;++r)if(d[r]===g){p=0;q=h;for(n=0;n<g;++n)p=p<<1|q&1,q>>=1;l=g<<16|r;for(n=p;n<b;n+=k)f[n]=l;++h}++g;h<<=1;k<<=1}return[f,c,e]};function ka(d,a){this.h=na;this.w=0;this.input=G&&d instanceof Array?new Uint8Array(d):d;this.b=0;a&&(a.lazy&&(this.w=a.lazy),"number"===typeof a.compressionType&&(this.h=a.compressionType),a.outputBuffer&&(this.a=G&&a.outputBuffer instanceof Array?new Uint8Array(a.outputBuffer):a.outputBuffer),"number"===typeof a.outputIndex&&(this.b=a.outputIndex));this.a||(this.a=new (G?Uint8Array:Array)(32768))}var na=2,oa={NONE:0,r:1,k:na,N:3},pa=[],T;
for(T=0;288>T;T++)switch(z){case 143>=T:pa.push([T+48,8]);break;case 255>=T:pa.push([T-144+400,9]);break;case 279>=T:pa.push([T-256+0,7]);break;case 287>=T:pa.push([T-280+192,8]);break;default:m("invalid literal: "+T)}
ka.prototype.j=function(){var d,a,c,e,b=this.input;switch(this.h){case 0:c=0;for(e=b.length;c<e;){a=G?b.subarray(c,c+65535):b.slice(c,c+65535);c+=a.length;var f=a,g=c===e,h=w,k=w,p=w,q=w,r=w,n=this.a,l=this.b;if(G){for(n=new Uint8Array(this.a.buffer);n.length<=l+f.length+5;)n=new Uint8Array(n.length<<1);n.set(this.a)}h=g?1:0;n[l++]=h|0;k=f.length;p=~k+65536&65535;n[l++]=k&255;n[l++]=k>>>8&255;n[l++]=p&255;n[l++]=p>>>8&255;if(G)n.set(f,l),l+=f.length,n=n.subarray(0,l);else{q=0;for(r=f.length;q<r;++q)n[l++]=
f[q];n.length=l}this.b=l;this.a=n}break;case 1:var s=new I(G?new Uint8Array(this.a.buffer):this.a,this.b);s.d(1,1,z);s.d(1,2,z);var t=qa(this,b),x,E,B;x=0;for(E=t.length;x<E;x++)if(B=t[x],I.prototype.d.apply(s,pa[B]),256<B)s.d(t[++x],t[++x],z),s.d(t[++x],5),s.d(t[++x],t[++x],z);else if(256===B)break;this.a=s.finish();this.b=this.a.length;break;case na:var C=new I(G?new Uint8Array(this.a.buffer):this.a,this.b),L,v,M,Y,Z,gb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],da,Fa,ea,Ga,la,sa=Array(19),
Ha,$,ma,D,Ia;L=na;C.d(1,1,z);C.d(L,2,z);v=qa(this,b);da=ra(this.L,15);Fa=ta(da);ea=ra(this.K,7);Ga=ta(ea);for(M=286;257<M&&0===da[M-1];M--);for(Y=30;1<Y&&0===ea[Y-1];Y--);var Ja=M,Ka=Y,K=new (G?Uint32Array:Array)(Ja+Ka),u,N,y,fa,J=new (G?Uint32Array:Array)(316),H,F,O=new (G?Uint8Array:Array)(19);for(u=N=0;u<Ja;u++)K[N++]=da[u];for(u=0;u<Ka;u++)K[N++]=ea[u];if(!G){u=0;for(fa=O.length;u<fa;++u)O[u]=0}u=H=0;for(fa=K.length;u<fa;u+=N){for(N=1;u+N<fa&&K[u+N]===K[u];++N);y=N;if(0===K[u])if(3>y)for(;0<y--;)J[H++]=
0,O[0]++;else for(;0<y;)F=138>y?y:138,F>y-3&&F<y&&(F=y-3),10>=F?(J[H++]=17,J[H++]=F-3,O[17]++):(J[H++]=18,J[H++]=F-11,O[18]++),y-=F;else if(J[H++]=K[u],O[K[u]]++,y--,3>y)for(;0<y--;)J[H++]=K[u],O[K[u]]++;else for(;0<y;)F=6>y?y:6,F>y-3&&F<y&&(F=y-3),J[H++]=16,J[H++]=F-3,O[16]++,y-=F}d=G?J.subarray(0,H):J.slice(0,H);la=ra(O,7);for(D=0;19>D;D++)sa[D]=la[gb[D]];for(Z=19;4<Z&&0===sa[Z-1];Z--);Ha=ta(la);C.d(M-257,5,z);C.d(Y-1,5,z);C.d(Z-4,4,z);for(D=0;D<Z;D++)C.d(sa[D],3,z);D=0;for(Ia=d.length;D<Ia;D++)if($=
d[D],C.d(Ha[$],la[$],z),16<=$){D++;switch($){case 16:ma=2;break;case 17:ma=3;break;case 18:ma=7;break;default:m("invalid code: "+$)}C.d(d[D],ma,z)}var La=[Fa,da],Ma=[Ga,ea],P,Na,ga,va,Oa,Pa,Qa,Ra;Oa=La[0];Pa=La[1];Qa=Ma[0];Ra=Ma[1];P=0;for(Na=v.length;P<Na;++P)if(ga=v[P],C.d(Oa[ga],Pa[ga],z),256<ga)C.d(v[++P],v[++P],z),va=v[++P],C.d(Qa[va],Ra[va],z),C.d(v[++P],v[++P],z);else if(256===ga)break;this.a=C.finish();this.b=this.a.length;break;default:m("invalid compression type")}return this.a};
function ua(d,a){this.length=d;this.G=a}
var wa=function(){function d(b){switch(z){case 3===b:return[257,b-3,0];case 4===b:return[258,b-4,0];case 5===b:return[259,b-5,0];case 6===b:return[260,b-6,0];case 7===b:return[261,b-7,0];case 8===b:return[262,b-8,0];case 9===b:return[263,b-9,0];case 10===b:return[264,b-10,0];case 12>=b:return[265,b-11,1];case 14>=b:return[266,b-13,1];case 16>=b:return[267,b-15,1];case 18>=b:return[268,b-17,1];case 22>=b:return[269,b-19,2];case 26>=b:return[270,b-23,2];case 30>=b:return[271,b-27,2];case 34>=b:return[272,
b-31,2];case 42>=b:return[273,b-35,3];case 50>=b:return[274,b-43,3];case 58>=b:return[275,b-51,3];case 66>=b:return[276,b-59,3];case 82>=b:return[277,b-67,4];case 98>=b:return[278,b-83,4];case 114>=b:return[279,b-99,4];case 130>=b:return[280,b-115,4];case 162>=b:return[281,b-131,5];case 194>=b:return[282,b-163,5];case 226>=b:return[283,b-195,5];case 257>=b:return[284,b-227,5];case 258===b:return[285,b-258,0];default:m("invalid length: "+b)}}var a=[],c,e;for(c=3;258>=c;c++)e=d(c),a[c]=e[2]<<24|e[1]<<
16|e[0];return a}(),xa=G?new Uint32Array(wa):wa;
function qa(d,a){function c(b,c){var a=b.G,d=[],e=0,f;f=xa[b.length];d[e++]=f&65535;d[e++]=f>>16&255;d[e++]=f>>24;var g;switch(z){case 1===a:g=[0,a-1,0];break;case 2===a:g=[1,a-2,0];break;case 3===a:g=[2,a-3,0];break;case 4===a:g=[3,a-4,0];break;case 6>=a:g=[4,a-5,1];break;case 8>=a:g=[5,a-7,1];break;case 12>=a:g=[6,a-9,2];break;case 16>=a:g=[7,a-13,2];break;case 24>=a:g=[8,a-17,3];break;case 32>=a:g=[9,a-25,3];break;case 48>=a:g=[10,a-33,4];break;case 64>=a:g=[11,a-49,4];break;case 96>=a:g=[12,a-
65,5];break;case 128>=a:g=[13,a-97,5];break;case 192>=a:g=[14,a-129,6];break;case 256>=a:g=[15,a-193,6];break;case 384>=a:g=[16,a-257,7];break;case 512>=a:g=[17,a-385,7];break;case 768>=a:g=[18,a-513,8];break;case 1024>=a:g=[19,a-769,8];break;case 1536>=a:g=[20,a-1025,9];break;case 2048>=a:g=[21,a-1537,9];break;case 3072>=a:g=[22,a-2049,10];break;case 4096>=a:g=[23,a-3073,10];break;case 6144>=a:g=[24,a-4097,11];break;case 8192>=a:g=[25,a-6145,11];break;case 12288>=a:g=[26,a-8193,12];break;case 16384>=
a:g=[27,a-12289,12];break;case 24576>=a:g=[28,a-16385,13];break;case 32768>=a:g=[29,a-24577,13];break;default:m("invalid distance")}f=g;d[e++]=f[0];d[e++]=f[1];d[e++]=f[2];var h,k;h=0;for(k=d.length;h<k;++h)n[l++]=d[h];t[d[0]]++;x[d[3]]++;s=b.length+c-1;r=null}var e,b,f,g,h,k={},p,q,r,n=G?new Uint16Array(2*a.length):[],l=0,s=0,t=new (G?Uint32Array:Array)(286),x=new (G?Uint32Array:Array)(30),E=d.w,B;if(!G){for(f=0;285>=f;)t[f++]=0;for(f=0;29>=f;)x[f++]=0}t[256]=1;e=0;for(b=a.length;e<b;++e){f=h=0;
for(g=3;f<g&&e+f!==b;++f)h=h<<8|a[e+f];k[h]===w&&(k[h]=[]);p=k[h];if(!(0<s--)){for(;0<p.length&&32768<e-p[0];)p.shift();if(e+3>=b){r&&c(r,-1);f=0;for(g=b-e;f<g;++f)B=a[e+f],n[l++]=B,++t[B];break}0<p.length?(q=ya(a,e,p),r?r.length<q.length?(B=a[e-1],n[l++]=B,++t[B],c(q,0)):c(r,-1):q.length<E?r=q:c(q,0)):r?c(r,-1):(B=a[e],n[l++]=B,++t[B])}p.push(e)}n[l++]=256;t[256]++;d.L=t;d.K=x;return G?n.subarray(0,l):n}
function ya(d,a,c){var e,b,f=0,g,h,k,p,q=d.length;h=0;p=c.length;a:for(;h<p;h++){e=c[p-h-1];g=3;if(3<f){for(k=f;3<k;k--)if(d[e+k-1]!==d[a+k-1])continue a;g=f}for(;258>g&&a+g<q&&d[e+g]===d[a+g];)++g;g>f&&(b=e,f=g);if(258===g)break}return new ua(f,a-b)}
function ra(d,a){var c=d.length,e=new ja(572),b=new (G?Uint8Array:Array)(c),f,g,h,k,p;if(!G)for(k=0;k<c;k++)b[k]=0;for(k=0;k<c;++k)0<d[k]&&e.push(k,d[k]);f=Array(e.length/2);g=new (G?Uint32Array:Array)(e.length/2);if(1===f.length)return b[e.pop().index]=1,b;k=0;for(p=e.length/2;k<p;++k)f[k]=e.pop(),g[k]=f[k].value;h=za(g,g.length,a);k=0;for(p=f.length;k<p;++k)b[f[k].index]=h[k];return b}
function za(d,a,c){function e(b){var c=k[b][p[b]];c===a?(e(b+1),e(b+1)):--g[c];++p[b]}var b=new (G?Uint16Array:Array)(c),f=new (G?Uint8Array:Array)(c),g=new (G?Uint8Array:Array)(a),h=Array(c),k=Array(c),p=Array(c),q=(1<<c)-a,r=1<<c-1,n,l,s,t,x;b[c-1]=a;for(l=0;l<c;++l)q<r?f[l]=0:(f[l]=1,q-=r),q<<=1,b[c-2-l]=(b[c-1-l]/2|0)+a;b[0]=f[0];h[0]=Array(b[0]);k[0]=Array(b[0]);for(l=1;l<c;++l)b[l]>2*b[l-1]+f[l]&&(b[l]=2*b[l-1]+f[l]),h[l]=Array(b[l]),k[l]=Array(b[l]);for(n=0;n<a;++n)g[n]=c;for(s=0;s<b[c-1];++s)h[c-
1][s]=d[s],k[c-1][s]=s;for(n=0;n<c;++n)p[n]=0;1===f[c-1]&&(--g[0],++p[c-1]);for(l=c-2;0<=l;--l){t=n=0;x=p[l+1];for(s=0;s<b[l];s++)t=h[l+1][x]+h[l+1][x+1],t>d[n]?(h[l][s]=t,k[l][s]=a,x+=2):(h[l][s]=d[n],k[l][s]=n,++n);p[l]=0;1===f[l]&&e(l)}return g}
function ta(d){var a=new (G?Uint16Array:Array)(d.length),c=[],e=[],b=0,f,g,h,k;f=0;for(g=d.length;f<g;f++)c[d[f]]=(c[d[f]]|0)+1;f=1;for(g=16;f<=g;f++)e[f]=b,b+=c[f]|0,b<<=1;f=0;for(g=d.length;f<g;f++){b=e[d[f]];e[d[f]]+=1;h=a[f]=0;for(k=d[f];h<k;h++)a[f]=a[f]<<1|b&1,b>>>=1}return a};function U(d,a){this.l=[];this.m=32768;this.e=this.g=this.c=this.q=0;this.input=G?new Uint8Array(d):d;this.s=!1;this.n=Aa;this.B=!1;if(a||!(a={}))a.index&&(this.c=a.index),a.bufferSize&&(this.m=a.bufferSize),a.bufferType&&(this.n=a.bufferType),a.resize&&(this.B=a.resize);switch(this.n){case Ba:this.b=32768;this.a=new (G?Uint8Array:Array)(32768+this.m+258);break;case Aa:this.b=0;this.a=new (G?Uint8Array:Array)(this.m);this.f=this.J;this.t=this.H;this.o=this.I;break;default:m(Error("invalid inflate mode"))}}
var Ba=0,Aa=1,Ca={D:Ba,C:Aa};
U.prototype.p=function(){for(;!this.s;){var d=V(this,3);d&1&&(this.s=z);d>>>=1;switch(d){case 0:var a=this.input,c=this.c,e=this.a,b=this.b,f=a.length,g=w,h=w,k=e.length,p=w;this.e=this.g=0;c+1>=f&&m(Error("invalid uncompressed block header: LEN"));g=a[c++]|a[c++]<<8;c+1>=f&&m(Error("invalid uncompressed block header: NLEN"));h=a[c++]|a[c++]<<8;g===~h&&m(Error("invalid uncompressed block header: length verify"));c+g>a.length&&m(Error("input buffer is broken"));switch(this.n){case Ba:for(;b+g>e.length;){p=
k-b;g-=p;if(G)e.set(a.subarray(c,c+p),b),b+=p,c+=p;else for(;p--;)e[b++]=a[c++];this.b=b;e=this.f();b=this.b}break;case Aa:for(;b+g>e.length;)e=this.f({v:2});break;default:m(Error("invalid inflate mode"))}if(G)e.set(a.subarray(c,c+g),b),b+=g,c+=g;else for(;g--;)e[b++]=a[c++];this.c=c;this.b=b;this.a=e;break;case 1:this.o(Da,Ea);break;case 2:for(var q=V(this,5)+257,r=V(this,5)+1,n=V(this,4)+4,l=new (G?Uint8Array:Array)(Sa.length),s=w,t=w,x=w,E=w,B=w,C=w,L=w,v=w,M=w,v=0;v<n;++v)l[Sa[v]]=V(this,3);if(!G){v=
n;for(n=l.length;v<n;++v)l[Sa[v]]=0}s=S(l);E=new (G?Uint8Array:Array)(q+r);v=0;for(M=q+r;v<M;)switch(B=Ta(this,s),B){case 16:for(L=3+V(this,2);L--;)E[v++]=C;break;case 17:for(L=3+V(this,3);L--;)E[v++]=0;C=0;break;case 18:for(L=11+V(this,7);L--;)E[v++]=0;C=0;break;default:C=E[v++]=B}t=G?S(E.subarray(0,q)):S(E.slice(0,q));x=G?S(E.subarray(q)):S(E.slice(q));this.o(t,x);break;default:m(Error("unknown BTYPE: "+d))}}return this.t()};
var Ua=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],Sa=G?new Uint16Array(Ua):Ua,Va=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],Wa=G?new Uint16Array(Va):Va,Xa=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],Ya=G?new Uint8Array(Xa):Xa,Za=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],$a=G?new Uint16Array(Za):Za,ab=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,
10,11,11,12,12,13,13],bb=G?new Uint8Array(ab):ab,cb=new (G?Uint8Array:Array)(288),W,db;W=0;for(db=cb.length;W<db;++W)cb[W]=143>=W?8:255>=W?9:279>=W?7:8;var Da=S(cb),eb=new (G?Uint8Array:Array)(30),fb,hb;fb=0;for(hb=eb.length;fb<hb;++fb)eb[fb]=5;var Ea=S(eb);function V(d,a){for(var c=d.g,e=d.e,b=d.input,f=d.c,g=b.length,h;e<a;)f>=g&&m(Error("input buffer is broken")),c|=b[f++]<<e,e+=8;h=c&(1<<a)-1;d.g=c>>>a;d.e=e-a;d.c=f;return h}
function Ta(d,a){for(var c=d.g,e=d.e,b=d.input,f=d.c,g=b.length,h=a[0],k=a[1],p,q;e<k&&!(f>=g);)c|=b[f++]<<e,e+=8;p=h[c&(1<<k)-1];q=p>>>16;q>e&&m(Error("invalid code length: "+q));d.g=c>>q;d.e=e-q;d.c=f;return p&65535}
U.prototype.o=function(d,a){var c=this.a,e=this.b;this.u=d;for(var b=c.length-258,f,g,h,k;256!==(f=Ta(this,d));)if(256>f)e>=b&&(this.b=e,c=this.f(),e=this.b),c[e++]=f;else{g=f-257;k=Wa[g];0<Ya[g]&&(k+=V(this,Ya[g]));f=Ta(this,a);h=$a[f];0<bb[f]&&(h+=V(this,bb[f]));e>=b&&(this.b=e,c=this.f(),e=this.b);for(;k--;)c[e]=c[e++-h]}for(;8<=this.e;)this.e-=8,this.c--;this.b=e};
U.prototype.I=function(d,a){var c=this.a,e=this.b;this.u=d;for(var b=c.length,f,g,h,k;256!==(f=Ta(this,d));)if(256>f)e>=b&&(c=this.f(),b=c.length),c[e++]=f;else{g=f-257;k=Wa[g];0<Ya[g]&&(k+=V(this,Ya[g]));f=Ta(this,a);h=$a[f];0<bb[f]&&(h+=V(this,bb[f]));e+k>b&&(c=this.f(),b=c.length);for(;k--;)c[e]=c[e++-h]}for(;8<=this.e;)this.e-=8,this.c--;this.b=e};
U.prototype.f=function(){var d=new (G?Uint8Array:Array)(this.b-32768),a=this.b-32768,c,e,b=this.a;if(G)d.set(b.subarray(32768,d.length));else{c=0;for(e=d.length;c<e;++c)d[c]=b[c+32768]}this.l.push(d);this.q+=d.length;if(G)b.set(b.subarray(a,a+32768));else for(c=0;32768>c;++c)b[c]=b[a+c];this.b=32768;return b};
U.prototype.J=function(d){var a,c=this.input.length/this.c+1|0,e,b,f,g=this.input,h=this.a;d&&("number"===typeof d.v&&(c=d.v),"number"===typeof d.F&&(c+=d.F));2>c?(e=(g.length-this.c)/this.u[2],f=258*(e/2)|0,b=f<h.length?h.length+f:h.length<<1):b=h.length*c;G?(a=new Uint8Array(b),a.set(h)):a=h;return this.a=a};
U.prototype.t=function(){var d=0,a=this.a,c=this.l,e,b=new (G?Uint8Array:Array)(this.q+(this.b-32768)),f,g,h,k;if(0===c.length)return G?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);f=0;for(g=c.length;f<g;++f){e=c[f];h=0;for(k=e.length;h<k;++h)b[d++]=e[h]}f=32768;for(g=this.b;f<g;++f)b[d++]=a[f];this.l=[];return this.buffer=b};
U.prototype.H=function(){var d,a=this.b;G?this.B?(d=new Uint8Array(a),d.set(this.a.subarray(0,a))):d=this.a.subarray(0,a):(this.a.length>a&&(this.a.length=a),d=this.a);return this.buffer=d};function ib(d){if("string"===typeof d){var a=d.split(""),c,e;c=0;for(e=a.length;c<e;c++)a[c]=(a[c].charCodeAt(0)&255)>>>0;d=a}for(var b=1,f=0,g=d.length,h,k=0;0<g;){h=1024<g?1024:g;g-=h;do b+=d[k++],f+=b;while(--h);b%=65521;f%=65521}return(f<<16|b)>>>0};function jb(d,a){var c,e;this.input=d;this.c=0;if(a||!(a={}))a.index&&(this.c=a.index),a.verify&&(this.M=a.verify);c=d[this.c++];e=d[this.c++];switch(c&15){case kb:this.method=kb;break;default:m(Error("unsupported compression method"))}0!==((c<<8)+e)%31&&m(Error("invalid fcheck flag:"+((c<<8)+e)%31));e&32&&m(Error("fdict flag is not supported"));this.A=new U(d,{index:this.c,bufferSize:a.bufferSize,bufferType:a.bufferType,resize:a.resize})}
jb.prototype.p=function(){var d=this.input,a,c;a=this.A.p();this.c=this.A.c;this.M&&(c=(d[this.c++]<<24|d[this.c++]<<16|d[this.c++]<<8|d[this.c++])>>>0,c!==ib(a)&&m(Error("invalid adler-32 checksum")));return a};var kb=8;function lb(d,a){this.input=d;this.a=new (G?Uint8Array:Array)(32768);this.h=X.k;var c={},e;if((a||!(a={}))&&"number"===typeof a.compressionType)this.h=a.compressionType;for(e in a)c[e]=a[e];c.outputBuffer=this.a;this.z=new ka(this.input,c)}var X=oa;
lb.prototype.j=function(){var d,a,c,e,b,f,g,h=0;g=this.a;d=kb;switch(d){case kb:a=Math.LOG2E*Math.log(32768)-8;break;default:m(Error("invalid compression method"))}c=a<<4|d;g[h++]=c;switch(d){case kb:switch(this.h){case X.NONE:b=0;break;case X.r:b=1;break;case X.k:b=2;break;default:m(Error("unsupported compression type"))}break;default:m(Error("invalid compression method"))}e=b<<6|0;g[h++]=e|31-(256*c+e)%31;f=ib(this.input);this.z.b=h;g=this.z.j();h=g.length;G&&(g=new Uint8Array(g.buffer),g.length<=
h+4&&(this.a=new Uint8Array(g.length+4),this.a.set(g),g=this.a),g=g.subarray(0,h+4));g[h++]=f>>24&255;g[h++]=f>>16&255;g[h++]=f>>8&255;g[h++]=f&255;return g};function mb(d,a){var c,e,b,f;if(Object.keys)c=Object.keys(a);else for(e in c=[],b=0,a)c[b++]=e;b=0;for(f=c.length;b<f;++b)e=c[b],A(d+"."+e,a[e])};A("Zlib.Inflate",jb);A("Zlib.Inflate.prototype.decompress",jb.prototype.p);mb("Zlib.Inflate.BufferType",{ADAPTIVE:Ca.C,BLOCK:Ca.D});A("Zlib.Deflate",lb);A("Zlib.Deflate.compress",function(d,a){return(new lb(d,a)).j()});A("Zlib.Deflate.prototype.compress",lb.prototype.j);mb("Zlib.Deflate.CompressionType",{NONE:X.NONE,FIXED:X.r,DYNAMIC:X.k});}).call(this);
